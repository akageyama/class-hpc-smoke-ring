var tipuesearch = {"pages":[{"title":" Smoke Ring ","text":"Smoke Ring 概要 これは、神戸大学情報知能工学科の講義 \"HPC\" （B3対象）用サンプルコードである。\n  3次元ナビエ・ストークス方程式を解いて渦輪の形成と伝播のシミュレーションを行う。 シミュレーション領域 直方体領域。3次元周期境界条件。カーテシアン座標。 計算手法 空間離散化は2次中心差分法。時間積分は4次ルンゲ・クッタ法。 実行方法 cd src make cd ../slice_grapher make clean make","tags":"home","loc":"index.html"},{"title":"constants.f90 – Smoke Ring","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~params.f90 params.f90 sourcefile~params.f90->sourcefile~constants.f90 sourcefile~ut.f90 ut.f90 sourcefile~params.f90->sourcefile~ut.f90 sourcefile~field.f90 field.f90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~grid.f90 grid.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~job.f90 job.f90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~job.f90->sourcefile~ut.f90 sourcefile~ut.f90->sourcefile~constants.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~solver.f90->sourcefile~ut.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~debug.f90 debug.f90 sourcefile~solver.f90->sourcefile~debug.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~grid.f90->sourcefile~ut.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~constants.f90 sourcefile~main.f90->sourcefile~params.f90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~main.f90->sourcefile~job.f90 sourcefile~main.f90->sourcefile~ut.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~main.f90->sourcefile~grid.f90 sourcefile~main.f90->sourcefile~debug.f90 sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90->sourcefile~slicedata.f90 sourcefile~debug.f90->sourcefile~constants.f90 sourcefile~debug.f90->sourcefile~params.f90 sourcefile~debug.f90->sourcefile~ut.f90 sourcefile~slicedata.f90->sourcefile~params.f90 sourcefile~slicedata.f90->sourcefile~field.f90 sourcefile~slicedata.f90->sourcefile~ut.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 sourcefile~slicedata.f90->sourcefile~debug.f90 var pansourcefileconstantsf90AfferentGraph = svgPanZoom('#sourcefileconstantsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules constants_m Source Code constants.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  date: 2020.01.22 ! !  Fortran定数と数学定数 ! !@note 定数であることが目で見てわかりやすいように全ての文字を !      大文字で書く。コンパイラには無意味であるので注意。 ! !@note シミュレーション領域は直方体と仮定している。 !      x方向の長さXMAX-XMINである。座標系の原点を !      シミュレーション領域の中心におくためには !      XMAXとXMIN絶対値を等しくとる。 ! !@note シミュレーションの（x方向の）空間解像度を上げる !      ためには同じXMAX-XMINに対して格子点数NXを上げれば良い。 ! !@note x,y,z それぞれの方向の空間解像度、 !      つまり格子間隔dx,dy,dzが異なっていても構わないが、 !      その差が極端に大きくしないほうがよい。 ! module constants_m implicit none ! << f90 constants >> integer , parameter :: SI = selected_int_kind ( 8 ) ! 単精度整数種別値 integer , parameter :: DI = selected_int_kind ( 16 ) ! 倍精度整数種別値 integer , parameter :: SR = selected_real_kind ( 6 ) ! 単精度実数種別値 integer , parameter :: DR = selected_real_kind ( 12 ) ! 倍精度実数種別値 ! << Mathematical constants >> real ( DR ), parameter :: PI = 3.1415926535897932_DR ! 円周率 real ( DR ), parameter :: TWOPI = PI * 2 ! 円周率の2倍 ! << Grid Size >> integer ( SI ), parameter :: NX = 60 ! 格子点数 x方向 粗い解像度 integer ( SI ), parameter :: NY = 20 ! 格子点数 y方向 粗い解像度 integer ( SI ), parameter :: NZ = 20 ! 格子点数 z方向 粗い解像度 ! integer(SI), parameter :: NX =  92    ! 格子点数 x方向 ! integer(SI), parameter :: NY =  32    ! 格子点数 y方向 ! integer(SI), parameter :: NZ =  32    ! 格子点数 z方向 ! integer(SI), parameter :: NX = 152  ! 格子点数 x方向 少し高めの解像度 ! integer(SI), parameter :: NY =  52  ! 格子点数 y方向 少し高めの解像度 ! integer(SI), parameter :: NZ =  52  ! 格子点数 z方向 少し高めの解像度 ! << Box Size >> real ( DR ), parameter :: XMIN = - 1.5_DR ! 計算領域範囲 +x real ( DR ), parameter :: XMAX = + 1.5_DR ! 計算領域範囲 -x real ( DR ), parameter :: YMIN = - 0.5_DR ! 計算領域範囲 +y real ( DR ), parameter :: YMAX = + 0.5_DR ! 計算領域範囲 -y real ( DR ), parameter :: ZMIN = - 0.5_DR ! 計算領域範囲 +z real ( DR ), parameter :: ZMAX = + 0.5_DR ! 計算領域範囲 -z end module constants_m","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"job.f90 – Smoke Ring","text":"This file depends on sourcefile~~job.f90~~EfferentGraph sourcefile~job.f90 job.f90 sourcefile~constants.f90 constants.f90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~ut.f90 ut.f90 sourcefile~job.f90->sourcefile~ut.f90 sourcefile~ut.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~job.f90~~AfferentGraph sourcefile~job.f90 job.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~job.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90->sourcefile~slicedata.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules job_m Source Code job.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  license: MIT !  date: 2020.01.22 ! !  シミュレーションジョブの制御 ! !@note !   配列演算を多用している。つまり一行で書かれている部分も !   実際は3重do loopで書かれような大量の演算をしているところが !   多い。このコードをOpenMP化する時には、そのような部分を !   3重do loopに展開して書き直す必要がある。 ! module job_m use constants_m ! 定数定義 use ut_m ! ユーティリティ implicit none ! 暗黙の型宣言無効化。必須 private ! このモジュール内の変数・ルーチン等はデフォルトで非公開 public :: & ![variable] job__karte public :: & ![routines] job__finalize type , public :: job__karte_t ! ジョブの「健康状態」を記したカルテ用構造体 character ( len = 20 ) :: state = \"fine\" ! 初期は「健康」 contains procedure :: set => job__karte_set ! カルテの設定関数 end type job__karte_t type ( job__karte_t ) :: job__karte ! カルテ contains subroutine job__finalize ( nloop ) !! ジョブ終了時の後始末。実際には健康状態カルテに応じた !! メッセージを標準出力に書くだけ !! !! MPI化した場合、MPI_Finalizeをおくのはここがいいだろう。 !! !! ut__messageの第一引数と第二引数はどちらも文字（列） !! 変数であるが、第一引数はシングルクォーテーションマーク、 !! 第二引数はダブルクオーテーションマークで囲っている。これは !! コンパイラにとっては無意味。Fortranでは2つのクォーテーション !! マークは区別しない。 integer ( DI ), intent ( in ) :: nloop !! ループカウンタ select case ( trim ( job__karte % state )) case ( \"fine\" , \"loop_max\" ) call ut__message ( '#' , \"Successfully finished.\" ) ! #で第2引数を囲む。 case ( \"time_out\" ) call ut__message ( '-' , \"Time out at nloop = \" , nloop ) case ( \"over_flow\" ) call ut__message ( '%' , \"Overflow at nloop = \" , nloop ) case ( \"negative_anormaly\" ) call ut__message ( '%' , \"Underflow at nloop = \" , nloop ) case default call ut__message ( '?' , \"Stopped at nloop = \" , nloop ) end select end subroutine job__finalize subroutine job__karte_set ( self , state_ ) !! ジョブカルテの設定終了時の後始末。実際には健康状態カルテに応じた !! !! 構造体のメンバー関数としてcallするときその !! 構造体変数そのものがselfとして自動的に引数にはいる。 !! ここでの変数名はselfという名前でなくても構わない。 class ( job__karte_t ), intent ( out ) :: self !! ジョブカルテ character ( len =* ), intent ( in ) :: state_ !! 設定する状態 select case ( trim ( state_ )) case ( \"fine\" ) ! 問題なく計算が進行している self % state = \"fine\" case ( \"time_out\" ) ! ジョブの時間切れ self % state = \"time_out\" case ( \"loop_max\" ) ! 設定されたループカウンタの最大値に到達した self % state = \"loop_max\" case ( \"over_flow\" ) ! 計算途中にオーバーフローが発生した self % state = \"over_flow\" case ( \"negative_anormaly\" ) ! 密度など正でなければいけない量が負になった self % state = \"negative_anormaly\" case default ! そんなstateは想定していない call ut__fatal ( \"<job__karte_set> case error.\" ) end select end subroutine job__karte_set end module job_m","tags":"","loc":"sourcefile/job.f90.html"},{"title":"ut.f90 – Smoke Ring","text":"This file depends on sourcefile~~ut.f90~~EfferentGraph sourcefile~ut.f90 ut.f90 sourcefile~constants.f90 constants.f90 sourcefile~ut.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ut.f90~~AfferentGraph sourcefile~ut.f90 ut.f90 sourcefile~params.f90 params.f90 sourcefile~params.f90->sourcefile~ut.f90 sourcefile~job.f90 job.f90 sourcefile~job.f90->sourcefile~ut.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~ut.f90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~debug.f90 debug.f90 sourcefile~solver.f90->sourcefile~debug.f90 sourcefile~field.f90 field.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~grid.f90->sourcefile~ut.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~ut.f90 sourcefile~main.f90->sourcefile~params.f90 sourcefile~main.f90->sourcefile~job.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~main.f90->sourcefile~grid.f90 sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90->sourcefile~slicedata.f90 sourcefile~main.f90->sourcefile~debug.f90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~slicedata.f90->sourcefile~ut.f90 sourcefile~slicedata.f90->sourcefile~params.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 sourcefile~slicedata.f90->sourcefile~debug.f90 sourcefile~slicedata.f90->sourcefile~field.f90 sourcefile~debug.f90->sourcefile~ut.f90 sourcefile~debug.f90->sourcefile~params.f90 sourcefile~field.f90->sourcefile~grid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ut_m Source Code ut.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  license: MIT !  date: 2020.01.22 ! !  ユーティリティライブラリ ! !  @note よく使う関数・ルーチンをまとめている。 ! !  @note 冒頭でuse constants_mとしているが、 !        このモジュールで使うのはconstants !        モジュールで定義された定数の中で !        DR等のFortran関連の定数だけである。 !        それ以外のシミュレーション関係の定数は !        使用しないこういう場合は単なる !        use文にonlyというキーワードを !        つけてDR等だけを使うことを明示的に !        示すことができる。 ! module ut_m use constants_m ! 定数定義 implicit none ! 暗黙の型宣言無効化。必須 private ! このモジュール内の変数・ルーチン等はデフォルトで非公開 public :: ut__assert , & ut__fatal , & ut__int_to_str3 , & ut__int_to_str7 , & ut__message interface ut__message !! 文字列（+ 数値）を標準出力に書き出すルーチンの多重定義 !! !! `message_decorated_なんとか` は飾り文字で囲む !! !! `message_型名[_型名]` は文字列の後のその型の数値を同じ行に書く module procedure message_decorated_str , & message_decorated_str_dint , & message_decorated_str_sint , & message_str , & message_str_double , & message_str_float , & message_str_dint , & message_str_dint_double , & message_str_dint_double_double , & message_str_sint , & message_str_sint_double , & message_str_sint_double_double end interface contains subroutine message_decorated_str ( mark , string ) !! 飾り文字でメーセージ文を囲む !! !!   Usage: !! !!      call message_decorated_str('#',\"This is a test.\") !! !!   Output: !! !!      ################### !!      # This is a test. # !!      ################### !! character , intent ( in ) :: mark !! この文字でメーセージを囲む character ( len =* ), intent ( in ) :: string !! 出力メーセージ（文字列） integer ( SI ) :: len len = len_trim ( string ) + 4 write ( 6 , * ) repeat ( mark , len ) write ( 6 , * ) mark // ' ' // trim ( string ) // ' ' // mark write ( 6 , * ) repeat ( mark , len ) end subroutine message_decorated_str subroutine message_decorated_str_dint ( mark , string , int ) !!  飾り文字でメーセージ文と倍精度整数を囲む !! !!  Usage: !! !!     call mess...('#','This is message at nloop = ', nloop) !! character , intent ( in ) :: mark !! この文字で全体を囲む character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( DI ), intent ( in ) :: int !! 文字列の後に書く倍精度整数 character ( len = 200 ) :: string_int write ( string_int , '(a,i8)' ) string , int call message_decorated_str ( mark , string_int ) end subroutine message_decorated_str_dint subroutine message_decorated_str_sint ( mark , string , int ) !!  飾り文字でメーセージ文と単精度整数を囲む !! !!  Usage: !! !!     call mess...('#','This is message at nloop = ', nloop) character , intent ( in ) :: mark !! この文字で全体を囲む character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( SI ), intent ( in ) :: int !! 文字列の後に書く単精度整数 character ( len = 200 ) :: string_int write ( string_int , '(a,i8)' ) string , int call message_decorated_str ( mark , string_int ) end subroutine message_decorated_str_sint subroutine message_str ( string ) !! 普通のprint文 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 write ( 6 , * ) string end subroutine message_str subroutine message_str_double ( string , double ) !! 文字列 + 倍精度実数2つの出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 real ( DR ), intent ( in ) :: double !! 書き出される実数 write ( 6 , * ) string , double end subroutine message_str_double subroutine message_str_float ( string , float ) !! 文字列 + 単精度実数2つの出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 real ( SR ), intent ( in ) :: float !! 書き出される実数 write ( 6 , * ) string , float end subroutine message_str_float subroutine message_str_dint ( string , int ) !! 文字列 + 倍精度整数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( DI ), intent ( in ) :: int !! 書き出される整数 write ( 6 , * ) string , int end subroutine message_str_dint subroutine message_str_sint ( string , int ) !! 文字列 + 単精度整数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( SI ), intent ( in ) :: int !! 書き出される整数 write ( 6 , * ) string , int end subroutine message_str_sint subroutine message_str_dint_double ( string , i1 , d1 ) !! 文字列 + 倍精度整数 + 倍精度実数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( DI ), intent ( in ) :: i1 !! 書き出される整数 real ( DR ), intent ( in ) :: d1 !! 書き出される実数 write ( 6 , * ) string , i1 , d1 end subroutine message_str_Dint_double subroutine message_str_sint_double ( string , i1 , d1 ) !! 文字列 + 単精度整数 + 倍精度実数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( SI ), intent ( in ) :: i1 !! 書き出される整数 real ( DR ), intent ( in ) :: d1 !! 書き出される実数 write ( 6 , * ) string , i1 , d1 end subroutine message_str_sint_double subroutine message_str_dint_double_double ( string , i1 , d1 , d2 ) !! 文字列 + 倍精度整数 + 倍精度実数 + 倍精度実数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( DI ), intent ( in ) :: i1 !! 書き出される整数 real ( DR ), intent ( in ) :: d1 , d2 !! 書き出される実数 write ( 6 , * ) string , i1 , d1 , d2 end subroutine message_str_Dint_double_double subroutine message_str_sint_double_double ( string , i1 , d1 , d2 ) !! 文字列 + 単精度整数 + 倍精度実数 + 倍精度実数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( SI ), intent ( in ) :: i1 !! 書き出される整数 real ( DR ), intent ( in ) :: d1 , d2 !! 書き出される実数 write ( 6 , * ) string , i1 , d1 , d2 end subroutine message_str_sint_double_double ! ! Private  これより上が非公開の関数・ルーチン !=================================================== ! Public   これより下が公開する関数・ルーチン ! subroutine ut__assert ( condition , last_will ) !! アサーション logical , intent ( in ) :: condition !! 必須条件 character ( len =* ), intent ( in ) :: last_will !! 遺言 if (. not . condition ) then call ut__fatal ( last_will ) end if end subroutine ut__assert subroutine ut__fatal ( last_will ) !! 致命的エラー !! !!   遺言を書き出してプログラムを停止する !! character ( len =* ), intent ( in ) :: last_will call ut__message ( '!' , last_will ) stop 'Program stopped by ut__fatal.' end subroutine ut__fatal function ut__int_to_str3 ( i ) result ( str3 ) !! 整数を文字列（3文字固定）に変換する !! !!             e.g., i=1    --> str3=\"001\" !!                   i=12   --> str3=\"012\" !!                   i=123  --> str3=\"123\" !!                   i=1234 --> str3=\"XXX\" !! @bug !!    i<0の時におかしくなる !! integer ( SI ), intent ( in ) :: i character ( len = 3 ) :: str3 if ( i > 999 ) then str3 = 'XXX' else write ( str3 , '(i3.3)' ) i end if end function ut__int_to_str3 function ut__int_to_str7 ( i ) result ( str7 ) !! 整数を文字列（7文字固定）に変換する !! !!             e.g., i=1        --> str7=\"0000001\" !!                   i=12       --> str7=\"0000012\" !!                   i=123      --> str7=\"0000123\" !!                   i=12345678 --> str7=\"XXXXXXX\" !! @bug !!    i<0の時におかしくなる !! integer ( SI ), intent ( in ) :: i character ( len = 7 ) :: str7 if ( i > 9999999 ) then str7 = 'XXXXXXX' else write ( str7 , '(i7.7)' ) i end if end function ut__int_to_str7 end module ut_m","tags":"","loc":"sourcefile/ut.f90.html"},{"title":"slicedata.f90 – Smoke Ring","text":"This file depends on sourcefile~~slicedata.f90~~EfferentGraph sourcefile~slicedata.f90 slicedata.f90 sourcefile~field.f90 field.f90 sourcefile~slicedata.f90->sourcefile~field.f90 sourcefile~ut.f90 ut.f90 sourcefile~slicedata.f90->sourcefile~ut.f90 sourcefile~solver.f90 solver.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 sourcefile~debug.f90 debug.f90 sourcefile~slicedata.f90->sourcefile~debug.f90 sourcefile~params.f90 params.f90 sourcefile~slicedata.f90->sourcefile~params.f90 sourcefile~constants.f90 constants.f90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~grid.f90 grid.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~ut.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~ut.f90 sourcefile~solver.f90->sourcefile~debug.f90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~job.f90 job.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~solver.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~debug.f90->sourcefile~ut.f90 sourcefile~debug.f90->sourcefile~params.f90 sourcefile~debug.f90->sourcefile~constants.f90 sourcefile~params.f90->sourcefile~ut.f90 sourcefile~params.f90->sourcefile~constants.f90 sourcefile~job.f90->sourcefile~ut.f90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~grid.f90->sourcefile~ut.f90 sourcefile~grid.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~slicedata.f90~~AfferentGraph sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~slicedata.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules slicedata_m Source Code slicedata.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  license: MIT !  date: 2020.01.22 ! !  断面データの作成とディスクへの出力 ! !  書き出されたデータはslice_grapherディレクトリにあるプログラムで !  可視化される。 ! !  @note !    ここで書き出す断面データは単精度浮動小数点数である。可視化には !    単精度で十分である。 ! !  @note !    サブルーチンmake_single_precision_fieldでは !    fieldモジュールで定義されたcurlを計算するルーチンを呼び出している。 !    ここで.curl.などの演算子を使うと記述が簡潔になるが、 !    現在はこれをコメントアウトしている。Fortranコンパイラが !    自己定義演算子を問題なく使えるのであれば !    .curl.などを使うようにコメントを外せばよい。 !    詳しくはfieldモジュールを見よ。 module slicedata_m use ut_m ! ユーティリティ。constantsモジュールは間接的にuseされる use field_m ! 流体場 use params_m ! パラメータ use debug_m ! デバッグ関係 use solver_m ! ナビエ・ストークス方程式ソルバ implicit none ! 暗黙の型宣言無効化。必須 private ! このモジュール内の変数・ルーチン等はデフォルトで非公開 public :: slicedata__initialize , & slicedata__write ! 2次元単精度実数配列 real ( SR ), dimension (:,:), allocatable :: Slice_vx ! 速度のx成分 real ( SR ), dimension (:,:), allocatable :: Slice_vy ! 速度のy成分 real ( SR ), dimension (:,:), allocatable :: Slice_vz ! 速度のz成分 real ( SR ), dimension (:,:), allocatable :: Slice_ps ! 圧力 real ( SR ), dimension (:,:), allocatable :: Slice_en ! エンストロフィ ! Enstrophy とは渦度の二乗 ! 渦度は速度のcurl logical , save :: Initialize_done = . false . ! モジュール初期化済か否か integer ( SI ), parameter :: FILE_SLICEDATA = 20 ! 断面データ出力ファイル番号 contains subroutine make_single_precision_field ( vel , ps ) !! シミュレーションで計算した速度場と圧力場 !! のx-z平面での断面データを求める。 !! その際、倍精度実数から単精度実数に型変換する。 !! !! ここではx-z平面で書き出しているが、 !! x-y平面での断面データなど、同様にとることが可能である。 !! !! サブルーチンmake_single_precision_fieldでは !! x-z面に平行な断面をとっている。その際、 !! その断面位置は !!     j = slice_j = NY / 2 !! としている。NYが偶数の時、 !! この断面は厳密に言えばy=0にはなっていない。 !! なぜならgridモジュールできめたy方向の格子点の !! 定義によればy=0の面はj=NY/2とj=NY/2+1の2つの面 !! の中間にあるからである。正確にy=0面上での可視化 !! をしたいのであればこの2つの面上でのデータ !! の平均値をディスクに書き出すべきである。 !! !! [バグ] !!   NYが奇数のときにちょうどy=0面に対応するのは !!     j = slice_j = NY / 2 + 1 !!   である。偶数のときにもこれでよい。 type ( field__vector3d_t ), intent ( in ) :: vel !! 速度場（3D） real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: ps !! 圧力場（3D） integer ( SI ) :: slice_j = NY / 2 ! 断面をとるy座標の格子点位置 type ( field__vector3d_t ) :: vor ! vorticity、渦度 real ( DR ), dimension ( NX , NY , NZ ) :: enstrophy ! 渦度の2乗 !>        vor = .curl.vel !>  enstrophy = vor.dot.vor vor = operator_curl ( vel ) enstrophy = operator_dot_product ( vor , vor ) Slice_vx = real ( vel % x (:, slice_j ,:), SR ) Slice_vy = real ( vel % y (:, slice_j ,:), SR ) Slice_vz = real ( vel % z (:, slice_j ,:), SR ) Slice_ps = real ( ps (:, slice_j ,:), SR ) Slice_en = real ( enstrophy (:, slice_j ,:), SR ) call debug__print ( 'called slicedata/make_single_precision_field.' ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine make_single_precision_field ! ! Private  これより上が非公開の関数・ルーチン !=================================================== ! Public   これより下が公開する関数・ルーチン ! subroutine slicedata__initialize !! このモジュールの初期化 !! !! 流体の場（fluid）の配列は決め打ち（つまりallocatableにしない）で !! 最初から3次元配列を確保している一方、ここではSlice_??配列を !! アロケータブルにしているのは、このslicedataモジュールは !! シミュレーションには必須ではないためである。 !! 場合によってはこのslicedataモジュールを使わずに !! シュミレーションすることも考えられる。 !! 例えば断面ではなく三次元の可視化をする時など。 !! そのような場合は、このslicedataモジュールは実際には !! 呼びたさないであろう。そのような時に備えて以下のように !! allocatableにしておけばメモリーを無駄遣いしない。 allocate ( Slice_vx ( NX , NZ ), & Slice_vy ( NX , NZ ), & Slice_vz ( NX , NZ ), & Slice_ps ( NX , NZ ), & Slice_en ( NX , NZ )) call debug__print ( 'Slice data allocated.' ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 open ( FILE_SLICEDATA , & file = trim ( params__get_string ( 'Slicedata_tag' )), & form = 'unformatted' ) ! 断面データを書き出すファイルをオープン Initialize_done = . true . ! 初期化終了のフラグをonにする call debug__print ( 'called slicedata__initlilize' ) end subroutine slicedata__initialize subroutine slicedata__write ( nloop , time , fluid ) !! 断面データのディスクへの書き出し integer ( DI ), intent ( in ) :: nloop !! 現在のループカウンタ real ( DR ), intent ( in ) :: time !! 現在の時刻 type ( field__fluid_t ), intent ( in ) :: fluid !! 現在の流体データ type ( field__vector3d_t ) :: vel ! 流れ速度ベクトル場。いまはナビエ・ストークス方程式の ! 基本変数を質量フラックスにしているのでこの流れ速度 ! ベクトル場は基本変数ではなく、基本変数から計算される ! 二次的な量である。 if ( params__get_integer ( 'Slicedata_nskip' ) <= 0 ) return ! 何らかの理由で断面データの ! 出力をしないときには ! parameter中のSlicedata_nskip ! の値を負にする。 if ( mod ( nloop , params__get_integer ( 'Slicedata_nskip' )) /= 0 ) return ! parameter中のSlicedata_nskip ! の値が例えば10の時には ! 10ステップおきに断面データを計算し、 ! ディスクに書き出す。 call ut__assert ( Initialize_done , \"<slicedata__write> Forgot init?\" ) ! モジュールの初期化終了確認 call solver__get_subfield ( fluid , vel ) ! 流体の基本変数から速度場を求める call make_single_precision_field ( vel , fluid % pressure ) ! 断面データを作成 write ( FILE_SLICEDATA ) nloop , real ( time , SR ), & Slice_vx , Slice_vy , Slice_vz , & Slice_ps , Slice_en ! ディスクへの書き出し ! 時刻も単精度に変換している call ut__message ( '#slice data saved at ' , nloop , time ) ! ここはデバッグモードがoffでも ! 書き出すようにしている。 ! 断面データはそれほど頻繁に ! 書き出さない（この行まで到達しない） ! のでこの出力がたくさんあって ! 邪魔になることはあまりないと ! 予想できるためである。 call debug__print ( 'called slicedata__write.' ) end subroutine slicedata__write end module slicedata_m","tags":"","loc":"sourcefile/slicedata.f90.html"},{"title":"params.f90 – Smoke Ring","text":"This file depends on sourcefile~~params.f90~~EfferentGraph sourcefile~params.f90 params.f90 sourcefile~constants.f90 constants.f90 sourcefile~params.f90->sourcefile~constants.f90 sourcefile~ut.f90 ut.f90 sourcefile~params.f90->sourcefile~ut.f90 sourcefile~ut.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~params.f90~~AfferentGraph sourcefile~params.f90 params.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~debug.f90 debug.f90 sourcefile~solver.f90->sourcefile~debug.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~params.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90->sourcefile~slicedata.f90 sourcefile~main.f90->sourcefile~debug.f90 sourcefile~slicedata.f90->sourcefile~params.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 sourcefile~slicedata.f90->sourcefile~debug.f90 sourcefile~debug.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules params_m Source Code params.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  license: MIT !  date: 2020.01.22 ! !  シミュレーションパラメータ ! !  @note !     パラメーターはnamelistを使ってファイルから読み込む ! !  @note !     先頭一文字だけが大文字になっている変数例えば Read_done などは !     このモジュールを名前空間とする変数を意味する。つまりモジュール !     外からはアクセスできないがモジュール内のルーチン関数からは !     アクセスできるものである。 !     このようにスコープの広い変数を乱用するとバグの温床になるが !     この程度の小さなプログラムであれば問題ないであろう。 ! !  @note !     ファイル番号10番をparams__readで使っている。 ! !  @note !    namelistファイルの内容を変更する場合は: !      (1) このファイルの少し下の行にあるnamelist文を書き換える。 !      (2) params__readを書き換える。 !      (3) namelist__get_double, _integer等の対応する行も書き換える。 ! !  @note !    namelist文中のスラッシュで囲まれた名称（たとえば/simulation/） !    や、namelist変数名（たとえばTotal_nloop）はnamelistファイル !    の中での記述と対応していなければいけない。 ! module params_m use constants_m ! 定数定義 use ut_m ! ユーティリティ implicit none ! 暗黙の型宣言無効化。必須 private ! このモジュール内の変数・ルーチン等はデフォルトで非公開 public :: & ![routines] params__get_double , & params__get_integer , & params__get_logical , & params__read , & params__get_string logical , save :: Read_done = . false . ! 読み込みが済んだか否か integer ( SI ), parameter :: STRING_LENGTH_MAX = 200 ! 文字列長 ! 足りなくなったら大きくする。 integer ( SI ) :: Total_nloop ! 一度のジョブで計算するループ回数 integer ( SI ) :: Slicedata_nskip ! 何ステップに一度、断面データを書き出すか character ( len = STRING_LENGTH_MAX ) :: Slicedata_tag ! 断面データファイル名用 real ( DR ) :: Viscosity , Kappa ! 粘性率と熱拡散率 logical :: Debug ! デバッグ出力用フラグ namelist / simulation / Total_nloop namelist / visualization / Slicedata_nskip , Slicedata_tag namelist / fluid_property / Viscosity , Kappa namelist / flags / Debug contains function params__get_double ( variable ) !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が倍精度浮動小数点数の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 real ( DR ) :: params__get_double !! その値 call ut__assert ( Read_done , & '<params__get_double> Read params file first.' ) select case ( variable ) case ( 'Kappa' ) ! 熱拡散率 params__get_double = Kappa case ( 'Viscosity' ) ! 粘性率 params__get_double = Viscosity case default ! そんなnamelist変数は想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( '<params__get_double> not in the params?' ) end select end function params__get_double function params__get_integer ( variable ) !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が整数の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 integer ( SI ) :: params__get_integer !! その値 call ut__assert ( Read_done , & '<params__get_integer> Read params file first.' ) select case ( variable ) case ( 'Slicedata_nskip' ) ! 何ステップごとに params__get_integer = Slicedata_nskip ! 断面をディスクに書き出すか case ( 'Total_nloop' ) ! シミュレーションジョブ params__get_integer = Total_nloop ! の実行最大ループ数 case default ! 想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( '<params__get_integer> not in the params?' ) end select end function params__get_integer function params__get_logical ( variable ) !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が論理値の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 logical :: params__get_logical !! その値 call ut__assert ( Read_done , & '<params__get_logical> Read params file first.' ) select case ( variable ) case ( 'Debug' ) ! デバッグモードか否か params__get_logical = Debug case default ! 想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( '<params__get_logical> not in the params?' ) end select end function params__get_logical subroutine params__read !! namelistファイルをディスクから読み込む。 !! ファイル名はコマンド第一引数。 !! !! ファイル番号10番をここで使っている。他の場所で !! 10番を使う（開きっぱなしにする）場合は問題だが、 !! その場所でもここのようにopenした後、closeしていれば !! 特に問題ではない。 !! !! namelistデータファイルの内容を変更する場合は !! 以下のread文も適宜変更すること。 !! character ( len = STRING_LENGTH_MAX ) :: params_file call ut__assert ( command_argument_count () == 1 , & \"Usage: smoke_ring param_file\" ) call get_command_argument ( 1 , params_file ) !*******<params_file のサンプル>********* ! &simulation      Total_nloop = 2000 / ! &visualization   Slicedata_nskip  = 100, Slicedata_tag = '_data_slice' / ! &fluid_property  Viscosity = 3.0e-2, Kappa = 3.e-2 / ! &flags           Debug = .false. / !*******</params_file のサンプル>********* open ( 10 , file = trim ( params_file )) read ( 10 , nml = simulation ) read ( 10 , nml = visualization ) read ( 10 , nml = fluid_property ) read ( 10 , nml = flags ) close ( 10 ) write ( 6 , nml = simulation ) write ( 6 , nml = visualization ) write ( 6 , nml = fluid_property ) write ( 6 , nml = flags ) Read_done = . true . end subroutine params__read function params__get_string ( variable ) !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が文字列の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 character ( len = STRING_LENGTH_MAX ) :: params__get_string !! その値 call ut__assert ( Read_done , & '<params__get_string> Read params file first.' ) select case ( variable ) case ( 'Slicedata_tag' ) ! 断面ファイル名に使う params__get_string = Slicedata_tag case default call ut__message ( '? arg = ' , variable ) ! 想定外 call ut__fatal ( '<params__get_string> not in the params?' ) end select end function params__get_string end module params_m","tags":"","loc":"sourcefile/params.f90.html"},{"title":"main.f90 – Smoke Ring","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~field.f90 field.f90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~job.f90 job.f90 sourcefile~main.f90->sourcefile~job.f90 sourcefile~ut.f90 ut.f90 sourcefile~main.f90->sourcefile~ut.f90 sourcefile~solver.f90 solver.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~constants.f90 constants.f90 sourcefile~main.f90->sourcefile~constants.f90 sourcefile~grid.f90 grid.f90 sourcefile~main.f90->sourcefile~grid.f90 sourcefile~debug.f90 debug.f90 sourcefile~main.f90->sourcefile~debug.f90 sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90->sourcefile~slicedata.f90 sourcefile~params.f90 params.f90 sourcefile~main.f90->sourcefile~params.f90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~job.f90->sourcefile~ut.f90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~ut.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~solver.f90->sourcefile~ut.f90 sourcefile~solver.f90->sourcefile~constants.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~solver.f90->sourcefile~debug.f90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~grid.f90->sourcefile~ut.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~debug.f90->sourcefile~ut.f90 sourcefile~debug.f90->sourcefile~constants.f90 sourcefile~debug.f90->sourcefile~params.f90 sourcefile~slicedata.f90->sourcefile~field.f90 sourcefile~slicedata.f90->sourcefile~ut.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 sourcefile~slicedata.f90->sourcefile~debug.f90 sourcefile~slicedata.f90->sourcefile~params.f90 sourcefile~params.f90->sourcefile~ut.f90 sourcefile~params.f90->sourcefile~constants.f90 var pansourcefilemainf90EfferentGraph = svgPanZoom('#sourcefilemainf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs main_m Source Code main.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  date: 2020.01.22 ! !  渦輪 (smoke ring) の形成シミュレーション ! !  神戸大学情報知能工学科の講義 \"HPC\" （B3対象）用サンプルコード ! !  ### 形状 !    直方体領域。3次元周期境界条件。カーテシアン座標。 ! !  ### 計算手法 !    空間離散化は2次中心差分法。時間積分は4次ルンゲ・クッタ法。 ! !  ### 実行方法 !    (1) cd src !    (2) make !    (3) cd ../slice_grapher !    (4) make ! program main_m use constants_m ! 定数 use ut_m ! ユーティリティ use params_m ! パラメータ use debug_m ! デバッグ use grid_m ! 格子点情報 use field_m ! 流体場の構造体定義 use slicedata_m ! 可視化用断面データ出力 use solver_m ! ナビエ・ストークス方程式ソルバ use job_m ! ジョブ管理 implicit none ! 暗黙の型宣言無効化。必須 integer ( DI ) :: nloop ! シミュレーションのループカウンタ real ( DR ) :: dt , time ! 時間刻み幅と時刻 type ( field__fluid_t ) :: fluid ! 流体場データの構造体 call params__read ! パラメーターの読み込み。paramsの後に続くアンダースコア ! 二つは、これがparamsモジュールの中にあるサブルーチンの ! 呼び出しであることを意味している。paramsモジュールの ! 名前はparams_mである。params_mはparams.f90にある。 call grid % initialize ! gridモジュールの初期化。 ! パーセント記号はメンバアクセス演算子。 ! ここでは構造体のメンバー関数の呼び出しをしている。 ! gridモジュール（grid_m）はgrid.f90で定義されている。 call solver__initialize ( fluid ) ! solverジュール（solver_m）の初期化。ここでは上の ! gridモジュールの場合と異なりメンバアクセス演算子 ! （パーセント記号）を使っていない理由は特にない。 call slicedata__initialize ! slicedataモジュールの初期化。 ! このモジュールはシミュレーション領域の断面図を出力する。 time = 0.0_DR ! 時刻の初期化。単位は秒。 nloop = 0 ! ループカウンタの初期化。 call solver__diagnosis ( nloop , time , fluid ) ! solverモジュールで定義されているdiagnosis（診断） ! サブルーチンを呼び出す。医者が患者を診るのがdiagnosis ! である。そこでの診断結果はjobモジュールのjob__carte ! という構造体にセットする。carteはカルテである。 dt = solver__set_time_step ( nloop , fluid ) ! 時間刻み幅 dt の決定。dtはCFL条件を満足するように決めるが、 ! CFL条件は流体の状態に流体の状態に依存して変化する。 ! たとえば、流体の一部が高温になると、そこでの音速が速くなり、 ! 音速によって決まるCFL条件が厳しくなる（つまりdtが小さくなる） ! ここでは初期状態における流体の状態に基づいてdtが決まる do while ( job__karte % state == \"fine\" ) ! このシミュレーションのメインループである。ジョブカルテが ! 「健康 (fine)」状態である限りシミュレーションを続行する。 call debug__print ( \"running. nloop=\" , nloop ) ! このdebugモジュール中の標準出力書き出しルーチンの ! 呼び出し。通常のプリント文と異なりデバッグフラグがtrue ! の時だけメッセージを書き出すような仕組みにしている。 ! デバッグフラグがfalseのときには何も書き出さない。 ! デバッグフラグはparamsモジュール内で定義している。 call solver__advance ( time , dt , fluid ) ! ナビエ・ストークス方程式に基づいて流体 (fluid) の状態を ! 一時刻ステップ dt だけ進める。 dt = solver__set_time_step ( nloop , fluid ) ! 流体の状態が変わったのでCFL条件に基づき時間刻み幅dt ! を設定し直す。 ! 厳密に言えば毎ステップこの再設定をしているわけではなく、 ! このsolver__set_time_stepルーチンの冒頭で判断し、 ! 数十ステップに一度だけ実際には変更を行うようなskip操作 ! をしている。CFL条件に基づいた計算は時間がかかるが、 ! 毎ステップdtを精密に調整する必要はないからである。 nloop = nloop + 1 ! ループカウンタのインクリメント call solver__diagnosis ( nloop , time , fluid ) ! 診断。異常があればjob__carteにセットする。 call slicedata__write ( nloop , time , fluid ) ! 断面データのディスクへの書き出し if ( nloop >= params__get_integer ( 'Total_nloop' )) & call job__karte % set ( \"loop_max\" ) ! あらかじめparamsモジュールで設定されたループカウンタの ! 上限値に達したらジョブを停止する。 end do call job__finalize ( nloop ) ! ジョブの後始末。実際にはメーセージを標準出力に書くだけ。 end program main_m","tags":"","loc":"sourcefile/main.f90.html"},{"title":"solver.f90 – Smoke Ring","text":"This file depends on sourcefile~~solver.f90~~EfferentGraph sourcefile~solver.f90 solver.f90 sourcefile~field.f90 field.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~job.f90 job.f90 sourcefile~solver.f90->sourcefile~job.f90 sourcefile~ut.f90 ut.f90 sourcefile~solver.f90->sourcefile~ut.f90 sourcefile~constants.f90 constants.f90 sourcefile~solver.f90->sourcefile~constants.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~debug.f90 debug.f90 sourcefile~solver.f90->sourcefile~debug.f90 sourcefile~params.f90 params.f90 sourcefile~solver.f90->sourcefile~params.f90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~job.f90->sourcefile~ut.f90 sourcefile~job.f90->sourcefile~constants.f90 sourcefile~ut.f90->sourcefile~constants.f90 sourcefile~grid.f90->sourcefile~ut.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~debug.f90->sourcefile~ut.f90 sourcefile~debug.f90->sourcefile~constants.f90 sourcefile~debug.f90->sourcefile~params.f90 sourcefile~params.f90->sourcefile~ut.f90 sourcefile~params.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~solver.f90~~AfferentGraph sourcefile~solver.f90 solver.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90->sourcefile~slicedata.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules solver_m Source Code solver.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  license: MIT !  date: 2020.01.22 ! !  ナビエ・ストークス方程式ソルバ ! !  @note !    Initialize_done, Viscosity など、頭文字だけが大文字の !    変数名はこのモジュール全体にscopeを持つ変数である。 !    つまりこのモジュールの中の任意のサブルーチン・関数からアクセスできる。 !    ただし、このモジュールの外からはアクセスできない（privateである） ! !  @note !    サブルーチンsubfield_velでは構造体の割り算 !       vel = fluid%flux / fluid%density !    をコメントアウトとしている。 !    Fortranコンパイラが自己定義演算子を問題なく使えるのであれば !    コメントを外してこれを使うほうが記述が簡潔になる。 !    詳しくはfieldモジュールを見よ。 ! !    サブルーチンsolver__advanceでの !        gluid = fluid + dfluid01*0.5_DR !    などといった記述についても同様。 ! ! @bug !    サブルーチン solver__diagnosis の発散判定で !        if ( maxval(fluid%flux%x) > ABNORMALLY_LARGE ) then !    としているところ、正しくは !        if ( maxval(abs(fluid%flux%x)) > ABNORMALLY_LARGE ) then !    とすべき。このままだと-x方向に大きな値があるときに引っかからない。 ! !  @bug !    関数 solver__set_time_step で !       vmax = maxval(sqrt(vel%x**2+vel%y**2+vel%z**2)) !    という演算はmaxvalとsqrtは交換して !       vmax = sqrt(maxval(vel%x**2+vel%y**2+vel%z**2)) !    とした方が速くなる可能性が高い。 !    このままだと3次元配列の全要素にsqrt !    を掛けてからそのmaxvalをとっているが、この順番は !    逆にした方が速いだろう。 ! !   @bug !    その少し下の !       sound_v = GAMMA*maxval(sqrt(GASS_CONST_FOR_AIR*tm)) !    も同様に !       sound_v = GAMMA*sqrt(maxval(GASS_CONST_FOR_AIR*tm)) !    とすべきだろう。 ! module solver_m use constants_m ! 定数定義 use grid_m ! 格子点 use ut_m ! ユーティリティ use params_m ! パラメータ use field_m ! 流れ場データ構造体 use debug_m ! デバッグ用 use job_m ! ジョブ管理 implicit none ! 暗黙の型宣言無効化。必須 private ! このモジュール内の変数・ルーチン等はデフォルトで非公開 public :: solver__advance , & solver__diagnosis , & solver__get_subfield , & solver__initialize , & solver__set_time_step interface solver__get_subfield !! 流体の基本変数（質量フラックス、質量密度、圧力） !! から二次的な量（流れ場、温度場、速度の発散） !! を計算するためのルーチン群の多重定義 module procedure subfield_vel , & subfield_vel_tm , & subfield_vel_tm_divv end interface real ( DR ), parameter :: GAMMA = 1.4_DR ! 空気の比熱比 real ( DR ), parameter :: GASS_CONST_FOR_AIR = 2.87e2_DR ! 空気の気体定数 !  空気の状態方程式 !     Pressure = 287 * Mass_density * Temperature logical , save :: Initialize_done = . false . ! モジュール初期化確認フラグ real ( DR ), save :: Viscosity ! 粘性率 real ( DR ), save :: Gamma1_kappa ! (GAMMA-1)*kappa ! kappaは熱拡散率 type ( field__vector3d_t ), save :: Drive_force ! 渦輪を駆動する力 contains function drive_force_factor ( time ) !! 渦輪を駆動する力の時間変化の調整のための係数設定 !! !! @note この係数は0以上1以下。これはassertで確認している。 !! real ( DR ), intent ( in ) :: time !! シミュレーション時刻 real ( DR ) :: drive_force_factor !! 力の強さ係数 0から1 ! !                                      factor !              ___________               | !             /|         |\\              | !      ______/ |         | \\______       +--------> time !            | |         |  | !            | |         |  | !            | t0        t1 | !          t_start         t_end ! real ( DR ), parameter :: T_START = 0.0_DR ! 力をかけ始める時刻 real ( DR ), parameter :: T_END = 0.01_DR ! 力をかけ終わる時刻 ! 試行錯誤で調整せよ real ( DR ), parameter :: T0 = T_START + ( T_END - T_START ) / 4 real ( DR ), parameter :: T1 = T_END - ( T_END - T_START ) / 4 ! 上のコメント図をみよ ! これも試行錯誤で調整せよ real ( DR ), parameter :: ONE = 1.0_DR ! コードの読みやすさのため定義 real ( DR ), parameter :: ZERO = 0.0_DR ! コードの読みやすさのため定義 call ut__assert ( T_START < T0 . and . T0 < T1 . and . T1 < T_END , & \"<solver/drive_force_factor> Time inconsistent.\" ) ! この関係は以下の前提なのでアサートで確認しておく ! 上のコメント図の時間依存係数 if ( time <= T_START ) then drive_force_factor = ZERO else if ( time <= T0 ) then drive_force_factor = ( time - T_START ) / ( T0 - T_START ) else if ( time <= T1 ) then drive_force_factor = ONE else if ( time <= T_END ) then drive_force_factor = ONE - ( time - T1 ) / ( T_END - T1 ) else drive_force_factor = ZERO end if call ut__assert ( drive_force_factor >= 0.0_DR & . and . & drive_force_factor <= 1.0_DR , & \"<solver/drive_force_factor> strange value.\" ) end function drive_force_factor subroutine set_drive_force_field !! 渦輪を駆動するための力の場を設定する !! その力はシミュレーション開始直後、短い時間だけかける。 !! 空間的には局在した力を想定している。その形状は円筒形である。 !! 円筒の軸はx軸上にある。 integer ( SI ) :: i , j , k real ( DR ) :: xx , yy , zz real ( DR ) :: force_region_x_min , force_region_x_max real ( DR ) :: force_center_y , force_center_z real ( DR ) :: force_cylinder_diameter , force_cylinder_radius_sq real ( DR ), parameter :: THE_FORCE = 3.e3_DR ! 瞬間的な力の最大値。 ! 試行錯誤で調整せよ。 ! !     +--------------------------------------+ ZMAX !     |                                      | !     |    +-------+                         | !     |    | Force |                         | !     |    +-------+                         | !     |                                      | !     +--------------------------------------+ ZMIN !    XMIN                                   XMAX ! force_region_x_min = XMIN + ( XMAX - XMIN ) / 5 ! 力をかける局所円筒領域のx方向の最小値 force_region_x_max = force_region_x_min + ( XMAX - XMIN ) / 10 ! 力をかける局所円筒領域のx方向の最大値 force_center_y = ( YMAX + YMIN ) / 2 ! 力をかける局所円筒領域の中心のy座標を中間にとる force_center_z = ( ZMAX + ZMIN ) / 2 ! 力をかける局所円筒領域の中心のz座標を中間にとる force_cylinder_diameter = min ( YMAX - YMIN , ZMAX - ZMIN ) / 4 ! 力をかける局所円筒領域の直径 force_cylinder_radius_sq = ( force_cylinder_diameter / 2 ) ** 2 ! 力をかける局所円筒領域の半径の2乗 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! を回る3重do loop。境界上の格子点で値は境界条件で設定する。 zz = grid % pos % z ( k ) - force_center_z ! 力の中心からのz方向の距離 do j = 2 , NY - 1 yy = grid % pos % y ( j ) - force_center_y ! 力の中心からのy方向の距離 do i = 2 , NX - 1 xx = grid % pos % x ( i ) ! これは格子点のx座標そのもの if ( ( yy ** 2 + zz ** 2 ) < force_cylinder_radius_sq & . and . & ( xx > force_region_x_min ) & . and . & ( xx < force_region_x_max ) ) then ! ここで半径そのもので比較するとsqrtの計算が必要になるが ! このように2乗同士で比較すれば不要。 Drive_force % x ( i , j , k ) = THE_FORCE ! いまはx方向だけに力がかかる Drive_force % y ( i , j , k ) = 0.0_DR ! としている。斜め方向に力を Drive_force % z ( i , j , k ) = 0.0_DR ! かけるにはこの部分を変更。 else Drive_force % x ( i , j , k ) = 0.0_DR Drive_force % y ( i , j , k ) = 0.0_DR Drive_force % z ( i , j , k ) = 0.0_DR end if end do end do end do call field__boundary_condition ( Drive_force ) ! 上の3重do loopで設定していない境界上の格子点に力の場を ! 設定する。周期境界条件。 call ut__assert ( maxval ( Drive_force % x ) == THE_FORCE , & \"<solver/set_drive_force_field> something is wrong.\" ) ! 最大値がTHE_FORCEと仮定しているのでそうでなければ何かがおかしい。 call debug__print ( \"called solver/set_drive_force_field.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine set_drive_force_field subroutine subfield_vel ( fluid , vel ) !! fluidの基本変数から二次的な場vel（流れの速度ベクトル場） !! をもとめる。 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体基本場 type ( field__vector3d_t ), intent ( out ) :: vel !! 流れの速度ベクトル ![  vel = fluid%flux / fluid%density     ! operator defined in field. vel = operator_vector_divby_scalar ( fluid % flux , fluid % density ) ! Fortranコンパイラが自己定義演算子（field.f90で定義） ! を許せば上の簡潔な記述を使うべし。 call debug__print ( \"called solver/subfield_vel.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine subfield_vel subroutine subfield_vel_tm ( fluid , vel , tm ) !! fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm） !! をもとめる。 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体基本場 type ( field__vector3d_t ), intent ( out ) :: vel !! 流れ場 real ( DR ), dimension ( NX , NY , NZ ), intent ( out ) :: tm !! 温度場 ![   vel = fluid%flux / fluid%density ! operator defined in field.f90. vel = operator_vector_divby_scalar ( fluid % flux , fluid % density ) tm = fluid % pressure / ( GASS_CONST_FOR_AIR * fluid % density ) ! Fortranコンパイラが自己定義演算子（field.f90で定義） ! を許せば上の簡潔な記述を使うべし。 call debug__print ( \"called solver/subfield_vel_tm.\" ) end subroutine subfield_vel_tm subroutine subfield_vel_tm_divv ( fluid , vel , tm , divv ) !! fluidの基本変数から二次的な場（速度ベクトル場velと !! 温度場tmと速度の発散divv）をもとめる。 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体基本場 type ( field__vector3d_t ), intent ( out ) :: vel !! 流れ場 real ( DR ), dimension ( NX , NY , NZ ), intent ( out ) :: tm !! 温度場 real ( DR ), dimension ( NX , NY , NZ ), intent ( out ) :: divv !! 流れの発散 ![   vel = fluid%flux     / fluid%density ! operator defined in field.f90. vel = operator_vector_divby_scalar ( fluid % flux , fluid % density ) tm = fluid % pressure / fluid % density ![  divv = .div.vel divv = operator_div ( vel ) ! Fortranコンパイラが自己定義演算子（field.f90で定義） ! を許せば上の簡潔な記述を使うべし。 call debug__print ( \"called solver/subfield_vel_tm_divv.\" ) end subroutine subfield_vel_tm_divv function the_equation ( t , dt , vx , vy , vz , tm , divv , fx , fy , fz , ps ) !! ナビエ・ストークス方程式の右辺（時間変化量）dtを掛けたものを計算 !! !! @note !!    粘性による加熱の効果は小さいので無視している。 !!    この項を入れる場合は圧力の方程式 !!    the_equation%pressure に追加すればよい。 real ( DR ), intent ( in ) :: t , dt !! 時刻と時間刻み幅 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: vx , vy , vz !! 速度3成分 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: tm , divv !! 温度と速度の発散 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: fx , fy , fz !! 質量フラックス real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: ps !! 圧力 type ( field__fluid_t ) :: the_equation !! 時間刻みdtでの流体データの微小変化量 integer ( SI ) :: i , j , k real ( DR ), parameter :: ONE_THIRD = 1.0_DR / 3.0_DR ! 演算回数節約のため real ( DR ) :: gradpx , gradpy , gradpz ! 圧力の勾配 (gradient p) real ( DR ) :: gdivvx , gdivvy , gdivvz ! 速度の発散の勾配 real ( DR ) :: divfvx , divfvy , divfvz ! 速度・密度フラックステンソルの発散 real ( DR ) :: lapvx , lapvy , lapvz , laptm ! 速度と温度のラプラシアン real ( DR ) :: divf ! 質量フラックスの発散 real ( DR ) :: factor ! 渦輪駆動力の係数（時間依存） call ut__assert ( Initialize_done , \"<solver/the_equation> Forgot init?\" ) ! 初期化忘れしていないか確認 factor = drive_force_factor ( t ) ! 渦輪の駆動力はシミュレーション開始直後だけかける。 ! その後は何も力をかけない（渦輪が自然に発生し、リング上の ! 構造が移動していく。）つまりこのfactorはシミュレーション ! 開始直後だけ非ゼロで、残りの殆どの時間はゼロが入っている。 ! 以下のdo loopがこのシミュレーションで最も時間のかかる ! 部分である。したがってここでは.div.などのユーザ定義 ! 演算子は（コンパイラがその使用を許したとしても）あえて ! 使わず、泥臭く書いている。これは将来、 ! 速度向上のためにコードの最適化をしたり、 ! OpenMP化することを見越してのことである。 do k = 2 , NZ - 1 do j = 2 , NY - 1 do i = 2 , NX - 1 ! 以下のコメントでは ! P 圧力 ! V 速度場ベクトル ! F 質量フラックスベクトル ! T 温度 ! grad P gradpx = ( ps ( i + 1 , j , k ) - ps ( i - 1 , j , k ) ) * grid % d1 % x gradpy = ( ps ( i , j + 1 , k ) - ps ( i , j - 1 , k ) ) * grid % d1 % y gradpz = ( ps ( i , j , k + 1 ) - ps ( i , j , k - 1 ) ) * grid % d1 % z ! grad (div V) の3成分 gdivvx = ( divv ( i + 1 , j , k ) - divv ( i - 1 , j , k ) ) * grid % d1 % x gdivvy = ( divv ( i , j + 1 , k ) - divv ( i , j - 1 , k ) ) * grid % d1 % y gdivvz = ( divv ( i , j , k + 1 ) - divv ( i , j , k - 1 ) ) * grid % d1 % z ! VFテンソルの発散 div(VF) の3成分 divfvx = ( fx ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fx ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fx ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fx ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fx ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fx ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z divfvy = ( fy ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fy ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fy ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fy ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fy ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fy ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z divfvz = ( fz ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fz ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fz ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fz ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fz ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fz ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z ! Laplacin V の3成分 lapvx = ( vx ( i + 1 , j , k ) - 2 * vx ( i , j , k ) + vx ( i - 1 , j , k ) ) * grid % d2 % x & + ( vx ( i , j + 1 , k ) - 2 * vx ( i , j , k ) + vx ( i , j - 1 , k ) ) * grid % d2 % y & + ( vx ( i , j , k + 1 ) - 2 * vx ( i , j , k ) + vx ( i , j , k - 1 ) ) * grid % d2 % z lapvy = ( vy ( i + 1 , j , k ) - 2 * vy ( i , j , k ) + vy ( i - 1 , j , k ) ) * grid % d2 % x & + ( vy ( i , j + 1 , k ) - 2 * vy ( i , j , k ) + vy ( i , j - 1 , k ) ) * grid % d2 % y & + ( vy ( i , j , k + 1 ) - 2 * vy ( i , j , k ) + vy ( i , j , k - 1 ) ) * grid % d2 % z lapvz = ( vz ( i + 1 , j , k ) - 2 * vz ( i , j , k ) + vz ( i - 1 , j , k ) ) * grid % d2 % x & + ( vz ( i , j + 1 , k ) - 2 * vz ( i , j , k ) + vz ( i , j - 1 , k ) ) * grid % d2 % y & + ( vz ( i , j , k + 1 ) - 2 * vz ( i , j , k ) + vz ( i , j , k - 1 ) ) * grid % d2 % z ! Laplacin T laptm = ( tm ( i + 1 , j , k ) - 2 * tm ( i , j , k ) + tm ( i - 1 , j , k ) ) * grid % d2 % x & + ( tm ( i , j + 1 , k ) - 2 * tm ( i , j , k ) + tm ( i , j - 1 , k ) ) * grid % d2 % y & + ( tm ( i , j , k + 1 ) - 2 * tm ( i , j , k ) + tm ( i , j , k - 1 ) ) * grid % d2 % z ! div F divf = ( fx ( i + 1 , j , k ) - fx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fy ( i , j + 1 , k ) - fy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fz ( i , j , k + 1 ) - fz ( i , j , k - 1 ) ) * grid % d1 % z ! 以下がナビエ・ストークス方程式 !  密度の時間発展 the_equation % density ( i , j , k ) = - divf * dt !  質量フラックスの時間発展（3成分） the_equation % flux % x ( i , j , k ) = & ( - divfvx & - gradpx & + Drive_force % x ( i , j , k ) * factor & + Viscosity * ( lapvx + ONE_THIRD * gdivvx ) & ) * dt the_equation % flux % y ( i , j , k ) = & ( - divfvy & - gradpy & + Drive_force % y ( i , j , k ) * factor & + Viscosity * ( lapvy + ONE_THIRD * gdivvy ) & ) * dt the_equation % flux % z ( i , j , k ) = & ( - divfvz & - gradpz & + Drive_force % z ( i , j , k ) * factor & + Viscosity * ( lapvz + ONE_THIRD * gdivvz ) & ) * dt !  圧力の時間発展 the_equation % pressure ( i , j , k ) = & ( - ( vx ( i , j , k ) * gradpx & + vy ( i , j , k ) * gradpy & + vz ( i , j , k ) * gradpz & ) & + Gamma1_kappa * laptm & - GAMMA * ps ( i , j , k ) * divv ( i , j , k ) & ) * dt end do end do end do call field__boundary_condition ( the_equation ) ! 境界条件の設定（周期境界条件） ! 上のdo loopは境界面上の格子点を除いた格子点（シミュレーション ! 領域の内部の格子点）上での値を計算するものであった。 ! ここで境界面上の格子点の値の（更新されたばかりの）内部の ! 格子点上のデータをコピーすることで設定する。 call debug__print ( \"called solver/the_equation.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end function the_equation ! ! Private  これより上が非公開の関数・ルーチン !=================================================== ! Public   これより下が公開する関数・ルーチン ! subroutine solver__advance ( t , dt , fluid ) !! 4段4次ルンゲ・クッタ積分法による時間積分の実行 !! !! @note !!   ここでは教科書に書かれている古典的な4段4次の !!   ルンゲ・クッタ積分法をそのまま実装している。 !!   作業用の構造体を5つ使用している（dfluid01からdfluid04とgluid） !!   これらの作業変数の数を減らし、メモリを節約にするためには !!   Runge-Kutta-Gill法などの方法がある。 !! !! @note !!   速度（vel）、温度（tm）, 速度の発散（divv）などの配列などは !!   このスキームでは基本変数から毎回計算すべき一種の作業配列である。 !!   したがって、このモジュール内の他の場所（サブルーチン・関数）でも !!   これらの変数（3次元の大きな配列）を宣言・使用している。 !!   使用メモリを節約するためにはこれらの作業配列は共通のものを !!   一つづつ用意するというのも可能である。しかし、そうするとコードが !!   読みにくくなるであろう。 real ( DR ), intent ( inout ) :: t !! 時刻 real ( DR ), intent ( in ) :: dt !! 時間刻み幅 type ( field__fluid_t ), intent ( inout ) :: fluid !! 流体データ real ( DR ), parameter :: ONE_SIXTH = 1.0_DR / 6.0_DR ! 演算数節約の real ( DR ), parameter :: ONE_THIRD = 1.0_DR / 3.0_DR ! ために定義 type ( field__vector3d_t ) :: vel ! 速度場 real ( DR ), dimension ( NX , NY , NZ ) :: tm ! 温度場 real ( DR ), dimension ( NX , NY , NZ ) :: divv ! 速度場の発散 type ( field__fluid_t ) :: dfluid01 , dfluid02 , dfluid03 , dfluid04 ! 古典的な4段4次ルンゲ・クッタ積分法に必要な4つの作業配列 ! サイズが大きいことに注意。 type ( field__fluid_t ) :: gluid ! work variable ! さらにもう一つの作業配列 ! サイズが大きいことに注意。 !---ルンゲ・クッタの第1段---! call subfield_vel_tm_divv ( fluid , vel , tm , divv ) ! 基本変数から副次的変数である速度、温度、速度の発散を求める dfluid01 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & fluid % flux % x , fluid % flux % y , fluid % flux % z , & fluid % pressure ) t = t + dt / 2 ! 渦輪を駆動する力は時刻（t）の関数として設定しているので、 ! いま解いているナビエ・ストークス方程式は時間に陽に依存する。 !---ルンゲ・クッタの第2段---! ![  gluid = fluid + dfluid01*0.5_DR dfluid01 = operator_fluid_times_real ( dfluid01 , 0.5_DR ) gluid = operator_fluid_add ( fluid , dfluid01 ) ! Fortranコンパイラが自己定義演算子をきちんと処理できる ! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid02 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) !---ルンゲ・クッタの第3段---! ![  gluid = fluid + dfluid02*0.5_DR dfluid02 = operator_fluid_times_real ( dfluid02 , 0.5_DR ) gluid = operator_fluid_add ( fluid , dfluid02 ) ! Fortranコンパイラが自己定義演算子をきちんと処理できる ! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid03 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) t = t + dt / 2 ! 繰り返すが、渦輪を駆動する力は時刻（t）の関数として設定しているので、 ! いま解いているナビエ・ストークス方程式は時間に陽に依存する。 !---ルンゲ・クッタの第4段---! ![  gluid = fluid + dfluid03 gluid = operator_fluid_add ( fluid , dfluid03 ) ! Fortranコンパイラが自己定義演算子をきちんと処理できる ! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid04 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) !--- 最終結果 ---! ![  fluid = fluid  & ![        + ONE_SIXTH*( dfluid01 + 2*dfluid02 + 2*dfluid03 + dfluid04 ) dfluid01 = operator_fluid_times_real ( dfluid01 , ONE_SIXTH ) dfluid02 = operator_fluid_times_real ( dfluid02 , ONE_THIRD ) dfluid03 = operator_fluid_times_real ( dfluid03 , ONE_THIRD ) dfluid04 = operator_fluid_times_real ( dfluid04 , ONE_SIXTH ) fluid = operator_fluid_add ( fluid , dfluid01 ) fluid = operator_fluid_add ( fluid , dfluid02 ) fluid = operator_fluid_add ( fluid , dfluid03 ) fluid = operator_fluid_add ( fluid , dfluid04 ) ! Fortranコンパイラが自己定義演算子をきちんと処理できる ! 場合は一番上の簡潔な記述の方が（読みやすいので）好ましい。 call debug__print ( \"called solver__advance.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine solver__advance subroutine solver__diagnosis ( nloop , time , fluid ) !! 流体の「健康状態」を診断する integer ( DI ), intent ( in ) :: nloop !! ループカウンタ real ( DR ), intent ( in ) :: time !! シミュレーション時刻 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体データ integer ( SI ), parameter :: SKIP = 100 ! このルーチンは結構計算負荷が高いので、 ! 毎ステップではなく、SKIPステップごとに診断を実行する real ( DR ), parameter :: ABNORMALLY_LARGE = 1.e20_DR ! これよりも物理量が大きくなったら異常が生じたと判断する type ( field__vector3d_t ) :: vel ! 流れの速度場 if ( mod ( nloop , SKIP ) /= 0 ) return ! このルーチンは結構計算負荷が高いので、 ! 毎ステップではなく、SKIPステップごとに診断を実行する if ( job__karte % state /= \"fine\" ) return ! Already in error state. ! ジョブの健康状態がfine（つまり健康）以外の値に ! 設定する可能性があるのはここ以外にもある（例えばmain.f90の ! メインループでシミュレーションのループカウンタが最大値が達するなど） ! そのような場合、どうせこの後、ジョブの停止処理に入るので、 ! これ以上計算を進めなくてもよい。 if ( maxval ( fluid % flux % x ) > ABNORMALLY_LARGE ) then ! 質量フラックスのx成分の最大値が異常に大きい ! これはバグである。absを入れ忘れている。 call ut__message ( \"<solver__diagnosis> Massflux_x overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % flux % y ) > ABNORMALLY_LARGE ) then ! 質量フラックスのy成分の最大値が異常に大きい ! これもバグである。absを入れ忘れている。 call ut__message ( \"<solver__diagnosis> Massflux_y overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % flux % z ) > ABNORMALLY_LARGE ) then ! 質量フラックスのz成分の最大値が異常に大きい ! これもバグである。absを入れ忘れている。 call ut__message ( \"<solver__diagnosis> Massflux_z overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % density ) > ABNORMALLY_LARGE ) then ! 質量が異常に大きい call ut__message ( \"<solver__diagnosis> Density overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % pressure ) > ABNORMALLY_LARGE ) then ! 圧力が異常に大きい call ut__message ( \"<solver__diagnosis> Pressure overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( minval ( fluid % pressure ) < 0.0_DR ) then ! 圧力が負になってしまっている call ut__message ( \"<solver__diagnosis> Negative pressure.\" ) call job__karte % set ( \"negative_anormaly\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( minval ( fluid % density ) < 0.0_DR ) then ! 密度が負になってしまっている call ut__message ( \"<solver__diagnosis> Negative density.\" ) call job__karte % set ( \"negative_anormaly\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if call subfield_vel ( fluid , vel ) ! 基本流れデータから副次的な速度場データを求める call ut__message ( '#max vel:' , nloop , time , & sqrt ( maxval ( vel % x ** 2 + vel % y ** 2 + vel % z ** 2 ))) ! 速度の最大値（ベクトルの長さ）を計算し標準出力に書き出す ! わずか1行で書いているが、実際にはここにかなりの計算が ! 含まれている。vel%x**2という配列演算は実際には3重do loop ! であり、maxval関数はその引数の3次元配列をとっている。 ! つまり全要素中の最大値をとっている。そして最後に ! sqrtをとって振幅（ベクトルの長さ）を計算している。 call ut__message ( '#flow energy: ' , nloop , time , & ![                                    .energyintegral.fluid) operator_energyintegral ( fluid )) ! ここでもFortranコンパイラが許せば.energyintegral.という ! 簡潔な演算子表現を使ったほうがよい。ここでもこの1行の ! 実行にはかなりの演算（速度ベクトル場のx,y,z3成分の2乗和に ! 資料密度を掛けたもの体積積分）が必要であることに注意。 call ut__message ( '#total mass: ' , nloop , time , & ![                                    .scalarintegral.(fluid%density)) operator_scalarintegral ( fluid % density )) ! 上と同様。こちらのほうは単なる密度場の体積積分なので ! 演算量は少ないが、シミュレーション領域全体に渡る体積積分 ! なので計算量は大きいことに間違いない。 call debug__print ( 'called solver__diagnosis.' ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine solver__diagnosis subroutine solver__initialize ( fluid ) !! モジュールの初期化 type ( field__fluid_t ), intent ( out ) :: fluid !! 流体データ real ( DR ) :: kappa ! 空気の熱拡散率 ! 物理パラメータの設定 Viscosity = params__get_double ( 'Viscosity' ) ! 空気の粘性率 kappa = params__get_double ( 'Kappa' ) ! 空気の熱拡散率 ! Viscosityと違ってkappaの頭文字が大文字になっていない、つまり ! このモジュールのグローバルスコープを持つ変数としていない ! のはナビエ・ストークス方程式には下で定義するGamma1_kappa ! という量のみを通じてkappaが出てくるからである。 Gamma1_kappa = ( Gamma - 1 ) * kappa ! gammaは比熱比、つまり定積比熱と定圧比熱の比である。 ! 統計力学で習うように、この値は流体（気体）を構成する ! 分子の構造（自由度）で決まる。 ! 流体の初期条件の設定 fluid % pressure = 1.013e5_DR ! 1013 hPa (一気圧) fluid % density = 1.293_DR ! kg/m&#94;3 (空気の密度) ![  fluid%flux     = 0.0_DR      ! 初期速度なし（流れなし） fluid % flux % x = 0.0_DR ! 初期速度なし（流れなし） fluid % flux % y = 0.0_DR fluid % flux % z = 0.0_DR ! コンパイラが許す場合は上の簡潔な代入表現の方が望ましい ! 渦輪を駆動するための力の場の設定 call set_drive_force_field Initialize_done = . true . ! モジュール初期化終了フラグ call debug__print ( \"called solver__initialize.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine solver__initialize function solver__set_time_step ( nloop , fluid ) !! CFL条件に基づいて時間刻み幅dtを設定する integer ( DI ), intent ( in ) :: nloop !! ループカウンタ type ( field__fluid_t ), intent ( in ) :: fluid !! 流体データ real ( DR ) :: solver__set_time_step !! 時間刻み幅 dt type ( field__vector3d_t ) :: vel ! 速度場 real ( DR ), dimension ( NX , NY , NZ ) :: tm ! 温度場 real ( DR ) :: vmax , sound_v ! 流れ速度の最大値と音速 real ( DR ) :: dt_vel , dt_sound , dt_viscous , dt_kappa ! 流れ速度、音波、粘性拡散、熱拡散、それぞれで決まる時間刻み幅 ! 実際のdtはこれらのなかで最も厳しい（小さい）値できまる。 real ( DR ), parameter :: ALMOST_ZERO = 1.e-20_DR ! ゼロ割り演算回避のためにつかう小さい値 real ( DR ), parameter :: ABNORMAL_VALUE = - 99 9.999_DR ! dtとしてありそうにない値（すぐ下で使う） real ( DR ), save :: dt = ABNORMAL_VALUE ! 時間刻み幅そのもの。初期設定でなんらかの失敗した場合 ! を検出するため最初はありそうない値を設定しておくが、 ! CFL条件に基づいて正しい値を一度設定したらその後は ! この宣言文にはsave属性がついているので、 ! この関数を抜けたあともその値を覚えている。 integer ( SI ), parameter :: SKIP = 20 ! dtを毎ステップ計算するのは大変（かなりの時間がかかる） ! のでこのSKIPステップに一度だけ計算する。毎ステップ計算する ! してもdtは1ステップでそれほど大きく変化しないからである。 ! ただし、計算が破綻（発散）するような場合は例外である。 call ut__assert ( Initialize_done , \"<solver__set_tim_step> Forgot init?\" ) ! 初期化忘れ確認 if ( mod ( nloop , SKIP ) == 0 ) then ! ほとんどの場合は、前回計算したdtを使う。 call subfield_vel_tm ( fluid , vel , tm ) ! 基本流体データから速度場と温度場を計算 vmax = maxval ( sqrt ( vel % x ** 2 + vel % y ** 2 + vel % z ** 2 )) ! 速度の最大値（ベクトルの長さの最大値）をもとめる ! ここでは配列演算を駆使して1行で書いているが ! 実際にはかなりの演算をしていることに注意。 ! これはバグではないが、maxvalとsqrtは交換すべき ! だろう。このままだと3次元配列の全要素にsqrt ! を掛けてからそのmaxvalをとっているが、これを ! 逆にした方が速いかもしれない。 vmax = max ( vmax , ALMOST_ZERO ) ! 初期条件では速度場がゼロなのでvmax=0となるが、あとで ! vmaxの割り算が出てくるので問題となる。それを回避するため ! ALMOST_ZEROが十分小さければよい。 sound_v = GAMMA * maxval ( sqrt ( GASS_CONST_FOR_AIR * tm )) ! 音速の最大値 ! これも上と同じ理屈で、maxvalとsqrtは交換すべき ! だろう。このままだと3次元配列の全要素にsqrt ! を掛けてからそのmaxvalをとっているが、これを ! 逆にした方が速いかもしれない。 call ut__assert ( sound_v > ALMOST_ZERO , \"<solver__time_step> sound_v=0?\" ) ! 音速（の最大値）がほとんどゼロになるのは ! 何かがおかしいのですぐに停止 ! 以下では、流れの速さ、音波、粘性拡散、熱拡散の4種類の ! CFL条件で決まる時間刻み幅をそれぞれこの順番に求めている。 dt_vel = 0.8_DR * grid % delta_min / vmax dt_sound = 0.8_DR * grid % delta_min / sound_v dt_viscous = 0.2_DR * ( grid % delta_min ** 2 ) / Viscosity dt_kappa = 0.2_DR * ( grid % delta_min ** 2 ) / Gamma1_kappa ! CFL factor はここでは0.8と0.2にしているが、 ! これは精密な議論に基づいて決めたものではなく、 ! 半経験的に決めた値である。 ! 最後の2つ、粘性拡散と熱拡散によるCFL条件のための ! CFL factor の値 (0.2) というのは少々安全側に設定 ! しすぎているかもしれない。つまりもう少し大きくしても ! 問題ないかもしれない。 dt = min ( dt_vel , dt_sound , dt_viscous , dt_kappa ) ! 最終的な時間刻み幅は上記の4種類のdtの最小値できまる。 if ( params__get_logical ( 'Debug' ) ) then ! デバッグモードがonであるとき、以下のデータを標準出力 ! に書き出す。出力が長くなるが、流体の状態を推測するのに ! 便利なデータである。 call ut__message ( '<solver__time_step> vmax = ' , vmax ) call ut__message ( '                  dt_vel = ' , dt_vel ) call ut__message ( '                dt_sound = ' , dt_sound ) call ut__message ( '                dt_kappa = ' , dt_kappa ) call ut__message ( '              dt_viscous = ' , dt_viscous ) call ut__message ( '               -->    dt = ' , dt ) end if if ( mod ( nloop , SKIP * 50 ) == 0 ) call ut__message ( \"> dt = \" , dt ) ! dtの値を（デバッグモードがoffであっても）書き出す ! SKIPをさら50倍しているのは、それほど頻繁に出力する ! 必要は通常ないからである。 end if call ut__assert ( dt /= ABNORMAL_VALUE , \"<solver__time_step> dt init failed?\" ) ! SKIPに一度dtを計算し直すが、それ以外は下の行を見れば分かる通り ! 前回のdtの値を流用する。 その際、一度もdtを計算したことがなかったら ! まずいのでその検出をABNORMAL_VALUEを使って検出している。 solver__set_time_step = dt ! dt of the prev calc is saved. ! 新たに更新（または前回計算した）dtを返す。 end function solver__set_time_step end module solver_m","tags":"","loc":"sourcefile/solver.f90.html"},{"title":"field.f90 – Smoke Ring","text":"This file depends on sourcefile~~field.f90~~EfferentGraph sourcefile~field.f90 field.f90 sourcefile~constants.f90 constants.f90 sourcefile~field.f90->sourcefile~constants.f90 sourcefile~grid.f90 grid.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~ut.f90 ut.f90 sourcefile~grid.f90->sourcefile~ut.f90 sourcefile~ut.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~field.f90~~AfferentGraph sourcefile~field.f90 field.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90->sourcefile~slicedata.f90 sourcefile~slicedata.f90->sourcefile~field.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules field_m Source Code field.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  license: MIT !  date: 2020.01.22 ! !  流体場データ構造体 ! !  @note コードを簡潔にするため.curl.や.div.などの !        ベクトル解析演算子をいったんは定義したが、いまは !        それらの演算子を使う部分はコメントアウトしている。 !        一部のFortranコンパイラでこの部分の挙動が !        怪しかったからである。 !        演習室のFortranコンパイラでは大丈夫かもしれないが未確認。 ! !  @note このバージョンでは古典的な関数呼び出しで !        curlやdivなどを実行しているが、コメントを付け替える !        だけで演算子（.curl.等）が使えるはず。 ! !  @note 配列演算を多用している。つまり一行で書かれている部分も !        実際は3重do loopで書かれような大量の演算をしているところが !        多い。このコードをOpenMP化する時には、そのような部分を !        3重do loopに展開して書き直す必要がある。 ! module field_m use constants_m ! 定数定義 use grid_m ! 格子点 implicit none ! 暗黙の型宣言無効化。必須 public ! 通常はデフォルトを非公開（private）とするが、 ! このモジュール内の変数・ルーチン等はデフォルトで公開。 private :: & ![assignments] assignment_real_to_fluid , & assignment_real_to_vector public :: & ![operators] operator_cross_product , & operator_curl , & operator_div , & operator_dot_product , & operator_energyintegral , & operator_fluid_add , & operator_fluid_times_real , & operator_laplacian_scalar , & operator_laplacian_vector , & operator_real_times_fluid , & operator_real_times_vector , & operator_scalar_times_vector , & operator_scalarintegral , & operator_vector_add , & operator_vector_divby_scalar , & operator_vector_times_real , & operator_vector_times_scalar private :: & ![routines] boundary_condition_fluid , & boundary_condition_scalar , & boundary_condition_vector interface field__boundary_condition !! 境界条件呼び出しルーチンの多重定義 !! 境界条件を設定する変数の種類によって !! 実際に使用するルーチンが違うが、 !! 呼び出し側では統一した名前でcallする。 !! コンパイラは引数の型で使用するルーチンを !! 判断する。 module procedure boundary_condition_fluid , & boundary_condition_scalar , & boundary_condition_vector end interface !--- << Types >> ---! type field__vector3d_t !! 3次元ベクトル場構造体 !! ここでは配列のサイズを決めているが、 !! 実行時に不定にしたい場合はallocatable !! は配列を使えば良い。しミュレーション !! コード全体にサイズ（行数）がそれほど !! 多くない今のような場合は、配列サイズ !! （=シミュレーションの格子点数）を !! 変更する度にコンパイルしてもたいした !! 時間はかからないのでこのように !! 決め打ちにしても問題ない。 real ( DR ), dimension ( NX , NY , NZ ) :: x !! x成分 ! 倍精度浮動小数点数（double real, DR）の ! 3次元配列、という意味。念の為。 real ( DR ), dimension ( NX , NY , NZ ) :: y !! y成分 real ( DR ), dimension ( NX , NY , NZ ) :: z !! z成分 end type field__vector3d_t type field__fluid_t !! このシミュレーションコードで最も大事な !! 変数（構造体）。流体の状態を保持する。 real ( DR ), dimension ( NX , NY , NZ ) :: pressure !! 圧力場 real ( DR ), dimension ( NX , NY , NZ ) :: density !! 質量密度場 type ( field__vector3d_t ) :: flux !! 質量フラックス ! 質量フラックス (flux) と速度場 (velocity_vector) !    flux = density * velocity_vector ! という関係がある。速度場を基本変数にしても問題ない。 ! 単にこのシミュレーションで解く基本方程式 ! ナビエ・ストークス方程式）の基本変数をどちらで ! 表現するか、の違いである。 end type field__fluid_t !--- << Operators >> ---! ! interface operator(.curl.) !    !! ベクトル解析のcurl演算子 !    module procedure operator_curl ! end interface ! ! interface operator(.div.) !    !! ベクトル解析のdivergence演算子 !    module procedure operator_div ! end interface ! ! interface operator(.energyintegral.) !    !! 全エネルギーを計算（体積積分）する演算子 !    module procedure operator_energyintegral ! end interface ! ! interface operator(.scalarintegral.) !    !! 任意のスカラー場の体積積分をする演算子 !    module procedure operator_scalarintegral ! end interface ! ! interface operator(.laplacian.) !    !! ラプラシアン演算子 !    !! スカラー場とベクトル場用の2つの多重定義 !    module procedure operator_laplacian_scalar !    module procedure operator_laplacian_vector ! end interface ! ! interface operator(.x.) !    !! ベクトル解析の外積演算子 !    module procedure operator_cross_product ! end interface ! ! interface operator(.dot.) !    !! ベクトル解析の内積演算子 !    module procedure operator_dot_product ! end interface ! ! interface operator(+) !    !! 構造体全要素の足し算を+記号で書けるように定義 !    module procedure operator_fluid_add !    module procedure operator_vector_add ! end interface ! ! interface operator(/) !    !! ベクトル場の3成分をあるスカラー場て割り算する !    !! 操作は何度か出てくる（例えば質量フラックスfluxから !    !! 速度場velocity_vectorを求めるときに !    !! velocity_vector = flux / mass_density !    !! という割り算が必要である）この計算を !    !! スラッシュ記号一つで書けるように定義 !    module procedure operator_vector_divby_scalar ! end interface ! ! interface operator(*) !    !! 各種構造体に掛け算記号が使えるように定義 !    module procedure operator_integer_times_fluid !    module procedure operator_fluid_times_integer !    module procedure operator_fluid_times_real !    module procedure operator_real_times_fluid !    module procedure operator_real_times_vector !    module procedure operator_scalar_times_vector !    module procedure operator_vector_times_real !    module procedure operator_vector_times_scalar ! end interface ! ! interface assignment(=) !    !! 各種構造体に代入記号が使えるように定義 !    module procedure assignment_real_to_fluid !    module procedure assignment_real_to_vector ! end interface contains subroutine assignment_real_to_fluid ( fluid , real ) !! 流体構造体に実数を代入。 !! 初期条件ですべての要素を0にセットするときに使う。 type ( field__fluid_t ), intent ( out ) :: fluid !! 流体場 real ( DR ), intent ( in ) :: real !! 代入する実数 fluid % pressure (:,:,:) = real fluid % density (:,:,:) = real fluid % flux % x (:,:,:) = real fluid % flux % y (:,:,:) = real fluid % flux % z (:,:,:) = real end subroutine assignment_real_to_fluid subroutine assignment_real_to_vector ( vector , real ) !! ベクトル場に実数を代入。 !! 初期条件で0にセットするときに使う。 type ( field__vector3d_t ), intent ( out ) :: vector !! ベクトル場 real ( DR ), intent ( in ) :: real !! 代入する実数 vector % x (:,:,:) = real vector % y (:,:,:) = real vector % z (:,:,:) = real end subroutine assignment_real_to_vector subroutine boundary_condition_fluid ( fluid ) !! 流体構造体の境界条件設定 type ( field__fluid_t ), intent ( inout ) :: fluid !! 流体場 call boundary_condition_scalar ( fluid % pressure ) call boundary_condition_scalar ( fluid % density ) call boundary_condition_vector ( fluid % flux ) end subroutine boundary_condition_fluid subroutine boundary_condition_scalar ( scalar ) !! スカラー場の境界条件設定 real ( DR ), dimension ( NX , NY , NZ ), intent ( inout ) :: scalar !! スカラー場 scalar ( 1 ,:,:) = scalar ( NX - 1 ,:,:) scalar ( NX ,:,:) = scalar ( 2 ,:,:) scalar (:, 1 ,:) = scalar (:, NY - 1 ,:) scalar (:, NY ,:) = scalar (:, 2 ,:) scalar (:,:, 1 ) = scalar (:,:, NZ - 1 ) scalar (:,:, NZ ) = scalar (:,:, 2 ) end subroutine boundary_condition_scalar subroutine boundary_condition_vector ( vec ) !! ベクトル場の境界条件設定 type ( field__vector3d_t ), intent ( inout ) :: vec !! ベクトル場 vec % x ( 1 ,:,:) = vec % x ( NX - 1 ,:,:) !-- yz-plane --! vec % y ( 1 ,:,:) = vec % y ( NX - 1 ,:,:) vec % z ( 1 ,:,:) = vec % z ( NX - 1 ,:,:) vec % x ( NX ,:,:) = vec % x ( 2 ,:,:) vec % y ( NX ,:,:) = vec % y ( 2 ,:,:) vec % z ( NX ,:,:) = vec % z ( 2 ,:,:) vec % x (:, 1 ,:) = vec % x (:, NY - 1 ,:) !-- zx-plane --! vec % y (:, 1 ,:) = vec % y (:, NY - 1 ,:) vec % z (:, 1 ,:) = vec % z (:, NY - 1 ,:) vec % x (:, NY ,:) = vec % x (:, 2 ,:) vec % y (:, NY ,:) = vec % y (:, 2 ,:) vec % z (:, NY ,:) = vec % z (:, 2 ,:) vec % x (:,:, 1 ) = vec % x (:,:, NZ - 1 ) !-- xy-plane --! vec % y (:,:, 1 ) = vec % y (:,:, NZ - 1 ) vec % z (:,:, 1 ) = vec % z (:,:, NZ - 1 ) vec % x (:,:, NZ ) = vec % x (:,:, 2 ) vec % y (:,:, NZ ) = vec % y (:,:, 2 ) vec % z (:,:, NZ ) = vec % z (:,:, 2 ) end subroutine boundary_condition_vector function operator_cross_product ( a , b ) !! ベクトル場の外積 type ( field__vector3d_t ), intent ( in ) :: a , b !! 掛けるベクトル場 type ( field__vector3d_t ) :: operator_cross_product !! 外積 operator_cross_product % x = ( a % y ) * ( b % z ) - ( a % z ) * ( b % y ) operator_cross_product % y = ( a % z ) * ( b % x ) - ( a % x ) * ( b % z ) operator_cross_product % z = ( a % x ) * ( b % y ) - ( a % y ) * ( b % x ) end function operator_cross_product function operator_curl ( a ) !! ベクトル場のcurl type ( field__vector3d_t ), intent ( in ) :: a !! これのcurlをとる type ( field__vector3d_t ) :: operator_curl !! curlした結果 integer ( SI ) :: i , j , k real ( DR ) :: dx1 , dy1 , dz1 dx1 = grid % d1 % x ! x方向の偏微分演算用定数 dy1 = grid % d1 % y ! y方向の偏微分演算用定数 dz1 = grid % d1 % z ! z方向の偏微分演算用定数 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法によりcurlを計算する do j = 2 , NY - 1 do i = 2 , NX - 1 operator_curl % x ( i , j , k ) = dy1 * ( a % z ( i , j + 1 , k ) - a % z ( i , j - 1 , k )) & - dz1 * ( a % y ( i , j , k + 1 ) - a % y ( i , j , k - 1 )) operator_curl % y ( i , j , k ) = dz1 * ( a % x ( i , j , k + 1 ) - a % x ( i , j , k - 1 )) & - dx1 * ( a % z ( i + 1 , j , k ) - a % z ( i - 1 , j , k )) operator_curl % z ( i , j , k ) = dx1 * ( a % y ( i + 1 , j , k ) - a % y ( i - 1 , j , k )) & - dy1 * ( a % x ( i , j + 1 , k ) - a % x ( i , j - 1 , k )) end do end do end do call boundary_condition_vector ( operator_curl ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_curl function operator_div ( a ) !! ベクトル場のdivergence type ( field__vector3d_t ), intent ( in ) :: a !! これのdivをとる real ( DR ), dimension ( NX , NY , NZ ) :: operator_div !! 結果 integer ( SI ) :: i , j , k real ( DR ) :: dx1 , dy1 , dz1 dx1 = grid % d1 % x ! x方向の偏微分演算用定数 dy1 = grid % d1 % y ! y方向の偏微分演算用定数 dz1 = grid % d1 % z ! z方向の偏微分演算用定数 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法によりdivergenceを計算する do j = 2 , NY - 1 do i = 2 , NX - 1 operator_div ( i , j , k ) = dx1 * ( a % x ( i + 1 , j , k ) - a % x ( i - 1 , j , k )) & + dy1 * ( a % y ( i , j + 1 , k ) - a % y ( i , j - 1 , k )) & + dz1 * ( a % z ( i , j , k + 1 ) - a % z ( i , j , k - 1 )) end do end do end do call boundary_condition_scalar ( operator_div ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_div function operator_dot_product ( a , b ) !! ベクトル場の内積 type ( field__vector3d_t ), intent ( in ) :: a , b !! 内積をとるベクトル場 real ( DR ), dimension ( NX , NY , NZ ) :: operator_dot_product !! 計算結果 operator_dot_product = a % x * b % x + a % y * b % y + a % z * b % z ! 配列演算 ! ! 実際にはここで3重do_loopが回っている ! OpenMP化するときにはこの簡潔な ! 書き方をやめて3重do_loopに書き直す必要がある。 end function operator_dot_product function operator_energyintegral ( a ) !! 流体の運動エネルギーの体積積分 type ( field__fluid_t ), intent ( in ) :: a !! 流体場 real ( DR ) :: operator_energyintegral !! 全エネルギー ! 以下のエネルギー密度の式を全空間で体積積分する ! flow_energy = (1/2) * rho * vel&#94;2 = (1/2) * (massflux)&#94;2 / rho real ( DR ) :: dvol real ( DR ), dimension ( NX , NY , NZ ) :: flux_sq ! sq は2乗(squared)を意味する dvol = ( grid % delta % x ) * ( grid % delta % y ) * ( grid % delta % z ) ! 現在のシュミレーションでは格子間隔はx, y, z それぞれに ! 一様であることを仮定している。つまりdx, dy, dzは空間位置に ! 依存せず一定である。 !   flux_sq = (a%flux).dot.(a%flux) flux_sq = operator_dot_product ( a % flux , a % flux ) ! 質量フラックスの2乗を一時的な配列にセットする ! ユーザ定義演算子が使えるコンパイラならば.dot.を ! 使った表記のほうが読みやすいであろう。 operator_energyintegral & = 0.5_DR * sum ( flux_sq ( 2 : NX - 1 , 2 : NY - 1 , 2 : NZ - 1 ) & / a % density ( 2 : NX - 1 , 2 : NY - 1 , 2 : NZ - 1 ) & ) * dvol ! ここで配列演算の添字が1からNXではなく2からNX-1などに ! 限定されていることに注意。これは体積積分の範囲を計算領域の ! 内部に限定していること、つまり境界上の格子点を除いて ! 積分していることを意味する。境界上の格子点まで ! 入れると重複してカウントしてしまうからである end function operator_energyintegral function operator_fluid_add ( a , b ) !! 流体構造体の足し算演算子 type ( field__fluid_t ), intent ( in ) :: a , b !! 足し算する2つの流体場 type ( field__fluid_t ) :: operator_fluid_add !! 計算結果 operator_fluid_add % flux % x = a % flux % x + b % flux % x operator_fluid_add % flux % y = a % flux % y + b % flux % y operator_fluid_add % flux % z = a % flux % z + b % flux % z operator_fluid_add % density = a % density + b % density operator_fluid_add % pressure = a % pressure + b % pressure end function operator_fluid_add function operator_fluid_times_integer ( fluid , integer ) !! 流体構造体を整数倍するための演算子 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体場 integer ( SI ), intent ( in ) :: integer !! かける整数 type ( field__fluid_t ) :: operator_fluid_times_integer operator_fluid_times_integer % pressure = integer * ( fluid % pressure ) operator_fluid_times_integer % density = integer * ( fluid % density ) operator_fluid_times_integer % flux % x = integer * ( fluid % flux % x ) operator_fluid_times_integer % flux % y = integer * ( fluid % flux % y ) operator_fluid_times_integer % flux % z = integer * ( fluid % flux % z ) end function operator_fluid_times_integer function operator_fluid_times_real ( fluid , real ) !! 流体構造体を実数倍するための演算子 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体場 real ( DR ), intent ( in ) :: real !! かける実数 type ( field__fluid_t ) :: operator_fluid_times_real !! 計算結果 operator_fluid_times_real % pressure = real * ( fluid % pressure ) operator_fluid_times_real % density = real * ( fluid % density ) operator_fluid_times_real % flux % x = real * ( fluid % flux % x ) operator_fluid_times_real % flux % y = real * ( fluid % flux % y ) operator_fluid_times_real % flux % z = real * ( fluid % flux % z ) end function operator_fluid_times_real function operator_integer_times_fluid ( integer , fluid ) !! 整数に流体構造体を掛け算するための演算子 integer ( SI ), intent ( in ) :: integer !! かける整数 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体場 type ( field__fluid_t ) :: operator_integer_times_fluid !! 計算結果 operator_integer_times_fluid % pressure = integer * ( fluid % pressure ) operator_integer_times_fluid % density = integer * ( fluid % density ) operator_integer_times_fluid % flux % x = integer * ( fluid % flux % x ) operator_integer_times_fluid % flux % y = integer * ( fluid % flux % y ) operator_integer_times_fluid % flux % z = integer * ( fluid % flux % z ) end function operator_integer_times_fluid function operator_laplacian_scalar ( a ) !! スカラー場のラプラシアン real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: a !! 入力スカラー場 real ( DR ), dimension ( NX , NY , NZ ) :: operator_laplacian_scalar !! 計算結果 integer ( SI ) :: i , j , k real ( DR ) :: dx2 , dy2 , dz2 dx2 = grid % d2 % x ! x方向の2階偏微分演算用定数 dy2 = grid % d2 % y ! y方向の2階偏微分演算用定数 dz2 = grid % d2 % z ! z方向の2階偏微分演算用定数 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法により計算する do j = 2 , NY - 1 do i = 2 , NX - 1 operator_laplacian_scalar ( i , j , k ) & = dx2 * ( a ( i + 1 , j , k ) - 2 * a ( i , j , k ) + a ( i - 1 , j , k )) & + dy2 * ( a ( i , j + 1 , k ) - 2 * a ( i , j , k ) + a ( i , j - 1 , k )) & + dz2 * ( a ( i , j , k + 1 ) - 2 * a ( i , j , k ) + a ( i , j , k - 1 )) end do end do end do call boundary_condition_scalar ( operator_laplacian_scalar ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_laplacian_scalar function operator_laplacian_vector ( a ) !! ベクトル場のラプラシアン type ( field__vector3d_t ), intent ( in ) :: a !! 入力ベクトル場 type ( field__vector3d_t ) :: operator_laplacian_vector !! 計算結果 integer ( SI ) :: i , j , k real ( DR ) :: dx2 , dy2 , dz2 dx2 = grid % d2 % x ! x方向の2階偏微分演算用定数 dy2 = grid % d2 % y ! y方向の2階偏微分演算用定数 dz2 = grid % d2 % z ! z方向の2階偏微分演算用定数 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法により計算する do j = 2 , NY - 1 do i = 2 , NX - 1 operator_laplacian_vector % x ( i , j , k ) & = dx2 * ( a % x ( i + 1 , j , k ) - 2 * a % x ( i , j , k ) + a % x ( i - 1 , j , k )) & + dy2 * ( a % x ( i , j + 1 , k ) - 2 * a % x ( i , j , k ) + a % x ( i , j - 1 , k )) & + dz2 * ( a % x ( i , j , k + 1 ) - 2 * a % x ( i , j , k ) + a % x ( i , j , k - 1 )) operator_laplacian_vector % y ( i , j , k ) & = dx2 * ( a % y ( i + 1 , j , k ) - 2 * a % y ( i , j , k ) + a % y ( i - 1 , j , k )) & + dy2 * ( a % y ( i , j + 1 , k ) - 2 * a % y ( i , j , k ) + a % y ( i , j - 1 , k )) & + dz2 * ( a % y ( i , j , k + 1 ) - 2 * a % y ( i , j , k ) + a % y ( i , j , k - 1 )) operator_laplacian_vector % z ( i , j , k ) & = dx2 * ( a % z ( i + 1 , j , k ) - 2 * a % z ( i , j , k ) + a % z ( i - 1 , j , k )) & + dy2 * ( a % z ( i , j + 1 , k ) - 2 * a % z ( i , j , k ) + a % z ( i , j - 1 , k )) & + dz2 * ( a % z ( i , j , k + 1 ) - 2 * a % z ( i , j , k ) + a % z ( i , j , k - 1 )) end do end do end do call boundary_condition_vector ( operator_laplacian_vector ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_laplacian_vector function operator_real_times_fluid ( real , fluid ) !! 実数に流体場を掛ける演算子 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体場 type ( field__fluid_t ) :: operator_real_times_fluid !! 計算結果 operator_real_times_fluid % pressure = real * ( fluid % pressure ) operator_real_times_fluid % density = real * ( fluid % density ) operator_real_times_fluid % flux % x = real * ( fluid % flux % x ) operator_real_times_fluid % flux % y = real * ( fluid % flux % y ) operator_real_times_fluid % flux % z = real * ( fluid % flux % z ) end function operator_real_times_fluid function operator_real_times_vector ( real , vec ) !! 実数にベクトル場を掛ける演算子 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__vector3d_t ), intent ( in ) :: vec !! 流体場 type ( field__vector3d_t ) :: operator_real_times_vector !! 計算結果 operator_real_times_vector % x = real * ( vec % x ) operator_real_times_vector % y = real * ( vec % y ) operator_real_times_vector % z = real * ( vec % z ) end function operator_real_times_vector function operator_scalar_times_vector ( scalar , vec ) !! スカラー場にベクトル場を掛ける演算子 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: scalar !! スカラー場 type ( field__vector3d_t ), intent ( in ) :: vec !! ベクトル場 type ( field__vector3d_t ) :: operator_scalar_times_vector !! 計算結果 operator_scalar_times_vector % x = scalar * ( vec % x ) operator_scalar_times_vector % y = scalar * ( vec % y ) operator_scalar_times_vector % z = scalar * ( vec % z ) end function operator_scalar_times_vector function operator_scalarintegral ( a ) !! スカラー場の体積積分演算子 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: a !! スカラー場 real ( DR ) :: operator_scalarintegral !! 体積積分結果 real ( DR ) :: dvol dvol = ( grid % delta % x ) * ( grid % delta % y ) * ( grid % delta % z ) ! 現在のシュミレーションでは格子間隔はx, y, z それぞれに ! 一様であることを仮定している。つまりdx, dy, dzは空間位置に ! 依存せず一定である。 operator_scalarintegral = sum ( a ( 2 : NX - 1 , 2 : NY - 1 , 2 : NZ - 1 ) ) * dvol ! ここで配列演算の添字が1からNXではなく2からNX-1などに ! 限定されていることに注意。これは体積積分の範囲を計算領域の ! 内部に限定していること、つまり境界上の格子点を除いて ! 積分していることを意味する。境界上の格子点まで ! 入れると重複してカウントしてしまうからである end function operator_scalarintegral function operator_vector_add ( a , b ) !! ベクトル場の和の演算子 type ( field__vector3d_t ), intent ( in ) :: a , b !! 和をとるベクトル場 type ( field__vector3d_t ) :: operator_vector_add !! 計算結果 operator_vector_add % x = a % x + b % x operator_vector_add % y = a % y + b % y operator_vector_add % z = a % z + b % z end function operator_vector_add function operator_vector_divby_scalar ( vec , scalar ) !! ベクトル場の各成分をスカラー場で割る type ( field__vector3d_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: scalar !! スカラー場 type ( field__vector3d_t ) :: operator_vector_divby_scalar !! 計算結果 operator_vector_divby_scalar % x = ( vec % x ) / scalar operator_vector_divby_scalar % y = ( vec % y ) / scalar operator_vector_divby_scalar % z = ( vec % z ) / scalar end function operator_vector_divby_scalar function operator_vector_times_real ( vec , real ) !! ベクトル場の実数倍の演算子 type ( field__vector3d_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__vector3d_t ) :: operator_vector_times_real !! 計算結果 operator_vector_times_real % x = real * ( vec % x ) operator_vector_times_real % y = real * ( vec % y ) operator_vector_times_real % z = real * ( vec % z ) end function operator_vector_times_real function operator_vector_times_scalar ( vec , scalar ) !! ベクトル場にスカラー場を掛ける type ( field__vector3d_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: scalar !! スカラー場 type ( field__vector3d_t ) :: operator_vector_times_scalar !! 計算結果 operator_vector_times_scalar % x = scalar * ( vec % x ) operator_vector_times_scalar % y = scalar * ( vec % y ) operator_vector_times_scalar % z = scalar * ( vec % z ) end function operator_vector_times_scalar end module field_m","tags":"","loc":"sourcefile/field.f90.html"},{"title":"debug.f90 – Smoke Ring","text":"This file depends on sourcefile~~debug.f90~~EfferentGraph sourcefile~debug.f90 debug.f90 sourcefile~constants.f90 constants.f90 sourcefile~debug.f90->sourcefile~constants.f90 sourcefile~params.f90 params.f90 sourcefile~debug.f90->sourcefile~params.f90 sourcefile~ut.f90 ut.f90 sourcefile~debug.f90->sourcefile~ut.f90 sourcefile~params.f90->sourcefile~constants.f90 sourcefile~params.f90->sourcefile~ut.f90 sourcefile~ut.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~debug.f90~~AfferentGraph sourcefile~debug.f90 debug.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~debug.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~debug.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90->sourcefile~slicedata.f90 sourcefile~slicedata.f90->sourcefile~debug.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules debug_m Source Code debug.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  license: MIT !  date: 2020.01.22 ! !  デバッグ用の標準出力ルーチン ! !  @note !    parameterのDebugがtrueのときだけ処理する ! module debug_m use constants_m ! 定数定義 use ut_m ! ユーティリティ use params_m ! パラメータ implicit none ! 暗黙の型宣言無効化。必須 private ! このモジュール内の変数・ルーチン等はデフォルトで非公開 public :: debug__print interface debug__print !! 各種デバッグ出力の多重定義 module procedure print_str , & print_str_dint , & print_str_dint_double , & print_str_double , & print_str_sint , & print_str_sint_double end interface contains subroutine print_str ( string ) !! Debugパラメータがtrueのとき文字列を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // string ) end if end subroutine print_str subroutine print_str_double ( string , double ) !! Debugパラメータがtrueのとき文字列と実数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 real ( DR ), intent ( in ) :: double !! 出力実数 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // string , double ) end if end subroutine print_str_double subroutine print_str_dint ( string , int ) !! Debugパラメータがtrueのとき文字列と整数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 integer ( DI ), intent ( in ) :: int !! 出力整数 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // trim ( string ), int ) end if end subroutine print_str_dint subroutine print_str_sint ( string , int ) !! Debugパラメータがtrueのとき文字列と整数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 integer ( SI ), intent ( in ) :: int !! 出力整数 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // trim ( string ), int ) end if end subroutine print_str_sint subroutine print_str_dint_double ( string , i1 , d1 ) !! Debugパラメータがtrueのとき文字列と整数と実数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 integer ( DI ), intent ( in ) :: i1 !! 出力整数 real ( DR ), intent ( in ) :: d1 !! 出力実数 if ( params__get_logical ( 'Debug' )) then call ut__message ( 'debug: ' // trim ( string ), i1 , d1 ) end if end subroutine print_str_dint_double subroutine print_str_sint_double ( string , i1 , d1 ) !! Debugパラメータがtrueのとき文字列と整数と実数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 integer ( SI ), intent ( in ) :: i1 !! 出力整数 real ( DR ), intent ( in ) :: d1 !! 出力実数 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // trim ( string ), i1 , d1 ) end if end subroutine print_str_sint_double end module debug_m","tags":"","loc":"sourcefile/debug.f90.html"},{"title":"grid.f90 – Smoke Ring","text":"This file depends on sourcefile~~grid.f90~~EfferentGraph sourcefile~grid.f90 grid.f90 sourcefile~constants.f90 constants.f90 sourcefile~grid.f90->sourcefile~constants.f90 sourcefile~ut.f90 ut.f90 sourcefile~grid.f90->sourcefile~ut.f90 sourcefile~ut.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~grid.f90~~AfferentGraph sourcefile~grid.f90 grid.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~field.f90 field.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~grid.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~main.f90->sourcefile~field.f90 sourcefile~slicedata.f90 slicedata.f90 sourcefile~main.f90->sourcefile~slicedata.f90 sourcefile~field.f90->sourcefile~grid.f90 sourcefile~slicedata.f90->sourcefile~solver.f90 sourcefile~slicedata.f90->sourcefile~field.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules grid_m Source Code grid.f90 Source Code !******************************************************************* !> author: Akira Kageyama !  license: MIT !  date: 2020.01.22 ! !  格子点関連情報 ! !  @note !     モジュール名と同じgridというpublicな変数（構造体）を !     定義し、その実体をこのモジュール内に保持している。 ! module grid_m use constants_m ! 定数定義 use ut_m ! ユーティリティ implicit none ! 暗黙の型宣言無効化。必須 private ! このモジュール内の変数・ルーチン等はデフォルトで非公開 ! public :: & ![type] !           grid__pos_t,  & !           grid__delta_t,  & !           grid__derivative_operator_1st_t,  & !           grid__derivative_operator_2nd_t ! public :: & ![variable] !           grid__pos,  & !           grid__delta,  & !           grid__d1,  & !           grid__d2,  & !           grid__delta_min ! public :: & ![routine] !           grid__initialize public :: grid ! このモジュールの中心変数。これを介して外部と ! やり取りする。このグリッド変数の定義 (下記のgrid__t） ! と実体（このgrid）が同じ場所（このgrid_mモジュール内） ! にあるのは少々変則的かもしれないが、このように規模の ! 小さいシミュレーションプログラムではこの方が ! むしろわかりやすいかもしれない。 type grid__pos_t !! 格子点位置を収める構造体 !! posはpositionの意味 real ( DR ), dimension ( NX ) :: x !! x座標 real ( DR ), dimension ( NY ) :: y !! y座標 real ( DR ), dimension ( NZ ) :: z !! z座標 end type grid__pos_t type grid__delta_t !! 格子間隔構造体 real ( DR ) :: x !! x方向の格子間隔 real ( DR ) :: y !! y方向の格子間隔 real ( DR ) :: z !! z方向の格子間隔 end type grid__delta_t type grid__derivative_operator_1st_t !! 1階微分（差分）をとる時の演算子（定数） !! 演算回数の節約のため real ( DR ) :: x !! x偏微分 real ( DR ) :: y !! y偏微分 real ( DR ) :: z !! z偏微分 end type grid__derivative_operator_1st_t type grid__derivative_operator_2nd_t !! 2階微分（差分）をとる時の演算子（定数） !! 演算回数の節約のため real ( DR ) :: x !! x偏微分 real ( DR ) :: y !! y偏微分 real ( DR ) :: z !! z偏微分 end type grid__derivative_operator_2nd_t type , public :: grid__t !! 格子点関係のデータを全て収める構造体 type ( grid__pos_t ) :: pos !! 格子点位置 real ( DR ) :: delta_min !! 最小の格子間隔 type ( grid__delta_t ) :: delta !! 格子間隔 type ( grid__derivative_operator_1st_t ) :: d1 !! 1階微分演算子定数 type ( grid__derivative_operator_2nd_t ) :: d2 !! 2階微分演算子定数 contains procedure :: initialize => grid__initialize !! 初期化関数 !! 初期化のためのメンバー関数 !! こうするとgrid%initializeという形でcallできる end type grid__t type ( grid__t ) :: grid ! 実体 contains subroutine grid__initialize ( self ) !! gridの初期化 !! !! ここでは周期境界条件を仮定している。 !! !! 構造体のメンバー関数としてcallするときその !! 構造体変数そのものがselfとして自動的に引数にはいる。 !! たとえば、 !!     call sampl_grid%initialize !! は !!     call grid__initialize(sample_grid) !! と解釈される。selfという名前でなくても構わない。 class ( grid__t ), intent ( out ) :: self !! 格子構造体 integer ( SI ) :: i , j , k real ( DR ) :: dx , dy , dz ! 格子間隔 real ( DR ), parameter :: NEARLY_ZERO = 1.e-10_DR ! 十分小さい数 ! ! 周期境界条件 ! !    --+-----+-----|                             |-----+-----+--- !      6     7     8                             1     2     3 !            |-----+-----+-----+-----+-----+-----+-----| !            1     2     3     4     5     6     7     8 !               |===================================| !              XMIN                                XMAX ! dx = ( XMAX - XMIN ) / ( NX - 2 ) ! from (1.5) to (NX-0.5), see above figure. dy = ( YMAX - YMIN ) / ( NY - 2 ) ! ここではxminがi=1とi=2の2つの格子点の dz = ( ZMAX - ZMIN ) / ( NZ - 2 ) ! ちょうど中間に位置すると仮定している。 ! burgers_equationのサンプルコードでは ! i=2にXMINが位置していた。両者に実質的な ! 違いはない。 self % delta % x = dx ! x方向の格子間隔 self % delta % y = dy ! y方向の格子間隔 self % delta % z = dz ! z方向の格子間隔 self % delta_min = min ( self % delta % x , self % delta % y , self % delta % z ) ! 3つの格子間隔の最小値。 ! CFL条件はこの最小値で決まる。 self % d1 % x = 1.0_DR / ( 2 * dx ) ! 1階差分演算用定数 self % d1 % y = 1.0_DR / ( 2 * dy ) ! dはderivativeを表す self % d1 % z = 1.0_DR / ( 2 * dz ) ! d1は1階差分の意味 self % d2 % x = 1.0_DR / ( dx ** 2 ) ! 2階差分演算用定数 self % d2 % y = 1.0_DR / ( dy ** 2 ) ! dはderivativeを表す self % d2 % z = 1.0_DR / ( dz ** 2 ) ! d2は2階差分の意味 do i = 1 , NX ! x方向の格子点位置の設定 ! XMINはi=1とi=2の中間にある self % pos % x ( i ) = XMIN + dx * ( real ( i , DR ) - 1.5_DR ) end do do j = 1 , NY ! y方向の格子点位置の設定 self % pos % y ( j ) = YMIN + dy * ( real ( j , DR ) - 1.5_DR ) end do do k = 1 , NZ ! z方向の格子点位置の設定 self % pos % z ( k ) = ZMIN + dz * ( real ( k , DR ) - 1.5_DR ) end do call ut__assert ( abs ( self % pos % x ( 1 ) - XMIN + dx / 2 ) + & abs ( self % pos % x ( NX ) - XMAX - dx / 2 ) + & abs ( self % pos % y ( 1 ) - YMIN + dy / 2 ) + & abs ( self % pos % y ( NY ) - YMAX - dy / 2 ) + & abs ( self % pos % z ( 1 ) - ZMIN + dz / 2 ) + & abs ( self % pos % z ( NZ ) - ZMAX - dz / 2 ) < NEARLY_ZERO , & \"<grid__initialize> grid min/max inconsistent?\" ) ! シミュレーション領域の範囲を決めるxmin, xmax, ..., zmaxZ ! の6個の頂点位置が上で定義した格子点位置と矛盾していない ! ことを確認する。万が一この前提が崩れている時はすぐに ! シミュレーションを停止する end subroutine grid__initialize end module grid_m","tags":"","loc":"sourcefile/grid.f90.html"},{"title":"job__karte_t – Smoke Ring ","text":"type, public :: job__karte_t Contents Variables state Type-Bound Procedures set Source Code job__karte_t Components Type Visibility Attributes Name Initial character(len=20), public :: state = \"fine\" Type-Bound Procedures procedure, public :: set => job__karte_set private subroutine job__karte_set (self, state_) ジョブカルテの設定終了時の後始末。実際には健康状態カルテに応じた Read more… Arguments Type Intent Optional Attributes Name class( job__karte_t ), intent(out) :: self ジョブカルテ character(len=*), intent(in) :: state_ 設定する状態 Source Code type , public :: job__karte_t ! ジョブの「健康状態」を記したカルテ用構造体 character ( len = 20 ) :: state = \"fine\" ! 初期は「健康」 contains procedure :: set => job__karte_set ! カルテの設定関数 end type job__karte_t","tags":"","loc":"type/job__karte_t.html"},{"title":"field__fluid_t – Smoke Ring ","text":"type, public :: field__fluid_t このシミュレーションコードで最も大事な\n 変数（構造体）。流体の状態を保持する。 Inherits type~~field__fluid_t~~InheritsGraph type~field__fluid_t field__fluid_t type~field__vector3d_t field__vector3d_t type~field__fluid_t->type~field__vector3d_t flux Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables density flux pressure Source Code field__fluid_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(NX,NY,NZ) :: density 質量密度場 type( field__vector3d_t ), public :: flux 質量フラックス real(kind=DR), public, dimension(NX,NY,NZ) :: pressure 圧力場 Source Code type field__fluid_t !! このシミュレーションコードで最も大事な !! 変数（構造体）。流体の状態を保持する。 real ( DR ), dimension ( NX , NY , NZ ) :: pressure !! 圧力場 real ( DR ), dimension ( NX , NY , NZ ) :: density !! 質量密度場 type ( field__vector3d_t ) :: flux !! 質量フラックス ! 質量フラックス (flux) と速度場 (velocity_vector) !    flux = density * velocity_vector ! という関係がある。速度場を基本変数にしても問題ない。 ! 単にこのシミュレーションで解く基本方程式 ! ナビエ・ストークス方程式）の基本変数をどちらで ! 表現するか、の違いである。 end type field__fluid_t","tags":"","loc":"type/field__fluid_t.html"},{"title":"field__vector3d_t – Smoke Ring ","text":"type, public :: field__vector3d_t 3次元ベクトル場構造体\n ここでは配列のサイズを決めているが、\n 実行時に不定にしたい場合はallocatable\n は配列を使えば良い。しミュレーション\n コード全体にサイズ（行数）がそれほど\n 多くない今のような場合は、配列サイズ\n （=シミュレーションの格子点数）を\n 変更する度にコンパイルしてもたいした\n 時間はかからないのでこのように\n 決め打ちにしても問題ない。 Inherited by type~~field__vector3d_t~~InheritedByGraph type~field__vector3d_t field__vector3d_t type~field__fluid_t field__fluid_t type~field__fluid_t->type~field__vector3d_t flux Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x y z Source Code field__vector3d_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(NX,NY,NZ) :: x x成分 real(kind=DR), public, dimension(NX,NY,NZ) :: y y成分 real(kind=DR), public, dimension(NX,NY,NZ) :: z z成分 Source Code type field__vector3d_t !! 3次元ベクトル場構造体 !! ここでは配列のサイズを決めているが、 !! 実行時に不定にしたい場合はallocatable !! は配列を使えば良い。しミュレーション !! コード全体にサイズ（行数）がそれほど !! 多くない今のような場合は、配列サイズ !! （=シミュレーションの格子点数）を !! 変更する度にコンパイルしてもたいした !! 時間はかからないのでこのように !! 決め打ちにしても問題ない。 real ( DR ), dimension ( NX , NY , NZ ) :: x !! x成分 ! 倍精度浮動小数点数（double real, DR）の ! 3次元配列、という意味。念の為。 real ( DR ), dimension ( NX , NY , NZ ) :: y !! y成分 real ( DR ), dimension ( NX , NY , NZ ) :: z !! z成分 end type field__vector3d_t","tags":"","loc":"type/field__vector3d_t.html"},{"title":"grid__delta_t – Smoke Ring ","text":"type, private :: grid__delta_t 格子間隔構造体 Inherited by type~~grid__delta_t~~InheritedByGraph type~grid__delta_t grid__delta_t type~grid__t grid__t type~grid__t->type~grid__delta_t delta Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x y z Source Code grid__delta_t Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x方向の格子間隔 real(kind=DR), public :: y y方向の格子間隔 real(kind=DR), public :: z z方向の格子間隔 Source Code type grid__delta_t !! 格子間隔構造体 real ( DR ) :: x !! x方向の格子間隔 real ( DR ) :: y !! y方向の格子間隔 real ( DR ) :: z !! z方向の格子間隔 end type grid__delta_t","tags":"","loc":"type/grid__delta_t.html"},{"title":"grid__derivative_operator_1st_t – Smoke Ring ","text":"type, private :: grid__derivative_operator_1st_t 1階微分（差分）をとる時の演算子（定数）\n 演算回数の節約のため Inherited by type~~grid__derivative_operator_1st_t~~InheritedByGraph type~grid__derivative_operator_1st_t grid__derivative_operator_1st_t type~grid__t grid__t type~grid__t->type~grid__derivative_operator_1st_t d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x y z Source Code grid__derivative_operator_1st_t Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x偏微分 real(kind=DR), public :: y y偏微分 real(kind=DR), public :: z z偏微分 Source Code type grid__derivative_operator_1st_t !! 1階微分（差分）をとる時の演算子（定数） !! 演算回数の節約のため real ( DR ) :: x !! x偏微分 real ( DR ) :: y !! y偏微分 real ( DR ) :: z !! z偏微分 end type grid__derivative_operator_1st_t","tags":"","loc":"type/grid__derivative_operator_1st_t.html"},{"title":"grid__derivative_operator_2nd_t – Smoke Ring ","text":"type, private :: grid__derivative_operator_2nd_t 2階微分（差分）をとる時の演算子（定数）\n 演算回数の節約のため Inherited by type~~grid__derivative_operator_2nd_t~~InheritedByGraph type~grid__derivative_operator_2nd_t grid__derivative_operator_2nd_t type~grid__t grid__t type~grid__t->type~grid__derivative_operator_2nd_t d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x y z Source Code grid__derivative_operator_2nd_t Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x偏微分 real(kind=DR), public :: y y偏微分 real(kind=DR), public :: z z偏微分 Source Code type grid__derivative_operator_2nd_t !! 2階微分（差分）をとる時の演算子（定数） !! 演算回数の節約のため real ( DR ) :: x !! x偏微分 real ( DR ) :: y !! y偏微分 real ( DR ) :: z !! z偏微分 end type grid__derivative_operator_2nd_t","tags":"","loc":"type/grid__derivative_operator_2nd_t.html"},{"title":"grid__pos_t – Smoke Ring ","text":"type, private :: grid__pos_t 格子点位置を収める構造体\n posはpositionの意味 Inherited by type~~grid__pos_t~~InheritedByGraph type~grid__pos_t grid__pos_t type~grid__t grid__t type~grid__t->type~grid__pos_t pos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x y z Source Code grid__pos_t Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(NX) :: x x座標 real(kind=DR), public, dimension(NY) :: y y座標 real(kind=DR), public, dimension(NZ) :: z z座標 Source Code type grid__pos_t !! 格子点位置を収める構造体 !! posはpositionの意味 real ( DR ), dimension ( NX ) :: x !! x座標 real ( DR ), dimension ( NY ) :: y !! y座標 real ( DR ), dimension ( NZ ) :: z !! z座標 end type grid__pos_t","tags":"","loc":"type/grid__pos_t.html"},{"title":"grid__t – Smoke Ring ","text":"type, public :: grid__t 格子点関係のデータを全て収める構造体 Inherits type~~grid__t~~InheritsGraph type~grid__t grid__t type~grid__delta_t grid__delta_t type~grid__t->type~grid__delta_t delta type~grid__pos_t grid__pos_t type~grid__t->type~grid__pos_t pos type~grid__derivative_operator_2nd_t grid__derivative_operator_2nd_t type~grid__t->type~grid__derivative_operator_2nd_t d2 type~grid__derivative_operator_1st_t grid__derivative_operator_1st_t type~grid__t->type~grid__derivative_operator_1st_t d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables d1 d2 delta delta_min pos Type-Bound Procedures initialize Source Code grid__t Components Type Visibility Attributes Name Initial type( grid__derivative_operator_1st_t ), public :: d1 1階微分演算子定数 type( grid__derivative_operator_2nd_t ), public :: d2 2階微分演算子定数 type( grid__delta_t ), public :: delta 格子間隔 real(kind=DR), public :: delta_min 最小の格子間隔 type( grid__pos_t ), public :: pos 格子点位置 Type-Bound Procedures procedure, public :: initialize => grid__initialize 初期化関数\n 初期化のためのメンバー関数\n こうするとgrid%initializeという形でcallできる private subroutine grid__initialize (self) gridの初期化 Read more… Arguments Type Intent Optional Attributes Name class( grid__t ), intent(out) :: self 格子構造体 Source Code type , public :: grid__t !! 格子点関係のデータを全て収める構造体 type ( grid__pos_t ) :: pos !! 格子点位置 real ( DR ) :: delta_min !! 最小の格子間隔 type ( grid__delta_t ) :: delta !! 格子間隔 type ( grid__derivative_operator_1st_t ) :: d1 !! 1階微分演算子定数 type ( grid__derivative_operator_2nd_t ) :: d2 !! 2階微分演算子定数 contains procedure :: initialize => grid__initialize !! 初期化関数 !! 初期化のためのメンバー関数 !! こうするとgrid%initializeという形でcallできる end type grid__t","tags":"","loc":"type/grid__t.html"},{"title":"job__finalize – Smoke Ring","text":"public subroutine job__finalize(nloop) ジョブ終了時の後始末。実際には健康状態カルテに応じた\n メッセージを標準出力に書くだけ MPI化した場合、MPI_Finalizeをおくのはここがいいだろう。 ut__messageの第一引数と第二引数はどちらも文字（列）\n 変数であるが、第一引数はシングルクォーテーションマーク、\n 第二引数はダブルクオーテーションマークで囲っている。これは\n コンパイラにとっては無意味。Fortranでは2つのクォーテーション\n マークは区別しない。 Arguments Type Intent Optional Attributes Name integer(kind=DI), intent(in) :: nloop ループカウンタ Calls proc~~job__finalize~~CallsGraph proc~job__finalize job__finalize interface~ut__message ut__message proc~job__finalize->interface~ut__message proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~job__finalize~~CalledByGraph proc~job__finalize job__finalize program~main_m main_m program~main_m->proc~job__finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code job__finalize Source Code subroutine job__finalize ( nloop ) !! ジョブ終了時の後始末。実際には健康状態カルテに応じた !! メッセージを標準出力に書くだけ !! !! MPI化した場合、MPI_Finalizeをおくのはここがいいだろう。 !! !! ut__messageの第一引数と第二引数はどちらも文字（列） !! 変数であるが、第一引数はシングルクォーテーションマーク、 !! 第二引数はダブルクオーテーションマークで囲っている。これは !! コンパイラにとっては無意味。Fortranでは2つのクォーテーション !! マークは区別しない。 integer ( DI ), intent ( in ) :: nloop !! ループカウンタ select case ( trim ( job__karte % state )) case ( \"fine\" , \"loop_max\" ) call ut__message ( '#' , \"Successfully finished.\" ) ! #で第2引数を囲む。 case ( \"time_out\" ) call ut__message ( '-' , \"Time out at nloop = \" , nloop ) case ( \"over_flow\" ) call ut__message ( '%' , \"Overflow at nloop = \" , nloop ) case ( \"negative_anormaly\" ) call ut__message ( '%' , \"Underflow at nloop = \" , nloop ) case default call ut__message ( '?' , \"Stopped at nloop = \" , nloop ) end select end subroutine job__finalize","tags":"","loc":"proc/job__finalize.html"},{"title":"job__karte_set – Smoke Ring","text":"private subroutine job__karte_set(self, state_) ジョブカルテの設定終了時の後始末。実際には健康状態カルテに応じた 構造体のメンバー関数としてcallするときその\n 構造体変数そのものがselfとして自動的に引数にはいる。\n ここでの変数名はselfという名前でなくても構わない。 Arguments Type Intent Optional Attributes Name class( job__karte_t ), intent(out) :: self ジョブカルテ character(len=*), intent(in) :: state_ 設定する状態 Calls proc~~job__karte_set~~CallsGraph proc~job__karte_set job__karte_set proc~ut__fatal ut__fatal proc~job__karte_set->proc~ut__fatal interface~ut__message ut__message proc~ut__fatal->interface~ut__message proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocjob__karte_setCallsGraph = svgPanZoom('#procjob__karte_setCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code job__karte_set Source Code subroutine job__karte_set ( self , state_ ) !! ジョブカルテの設定終了時の後始末。実際には健康状態カルテに応じた !! !! 構造体のメンバー関数としてcallするときその !! 構造体変数そのものがselfとして自動的に引数にはいる。 !! ここでの変数名はselfという名前でなくても構わない。 class ( job__karte_t ), intent ( out ) :: self !! ジョブカルテ character ( len =* ), intent ( in ) :: state_ !! 設定する状態 select case ( trim ( state_ )) case ( \"fine\" ) ! 問題なく計算が進行している self % state = \"fine\" case ( \"time_out\" ) ! ジョブの時間切れ self % state = \"time_out\" case ( \"loop_max\" ) ! 設定されたループカウンタの最大値に到達した self % state = \"loop_max\" case ( \"over_flow\" ) ! 計算途中にオーバーフローが発生した self % state = \"over_flow\" case ( \"negative_anormaly\" ) ! 密度など正でなければいけない量が負になった self % state = \"negative_anormaly\" case default ! そんなstateは想定していない call ut__fatal ( \"<job__karte_set> case error.\" ) end select end subroutine job__karte_set","tags":"","loc":"proc/job__karte_set.html"},{"title":"ut__int_to_str3 – Smoke Ring","text":"public function ut__int_to_str3(i) result(str3) 整数を文字列（3文字固定）に変換する e.g., i=1    --> str3=\"001\"\n               i=12   --> str3=\"012\"\n               i=123  --> str3=\"123\"\n               i=1234 --> str3=\"XXX\" Bug i<0の時におかしくなる Arguments Type Intent Optional Attributes Name integer(kind=SI), intent(in) :: i Return Value character(len=3) Contents Source Code ut__int_to_str3 Source Code function ut__int_to_str3 ( i ) result ( str3 ) !! 整数を文字列（3文字固定）に変換する !! !!             e.g., i=1    --> str3=\"001\" !!                   i=12   --> str3=\"012\" !!                   i=123  --> str3=\"123\" !!                   i=1234 --> str3=\"XXX\" !! @bug !!    i<0の時におかしくなる !! integer ( SI ), intent ( in ) :: i character ( len = 3 ) :: str3 if ( i > 999 ) then str3 = 'XXX' else write ( str3 , '(i3.3)' ) i end if end function ut__int_to_str3","tags":"","loc":"proc/ut__int_to_str3.html"},{"title":"ut__int_to_str7 – Smoke Ring","text":"public function ut__int_to_str7(i) result(str7) 整数を文字列（7文字固定）に変換する e.g., i=1        --> str7=\"0000001\"\n               i=12       --> str7=\"0000012\"\n               i=123      --> str7=\"0000123\"\n               i=12345678 --> str7=\"XXXXXXX\" Bug i<0の時におかしくなる Arguments Type Intent Optional Attributes Name integer(kind=SI), intent(in) :: i Return Value character(len=7) Contents Source Code ut__int_to_str7 Source Code function ut__int_to_str7 ( i ) result ( str7 ) !! 整数を文字列（7文字固定）に変換する !! !!             e.g., i=1        --> str7=\"0000001\" !!                   i=12       --> str7=\"0000012\" !!                   i=123      --> str7=\"0000123\" !!                   i=12345678 --> str7=\"XXXXXXX\" !! @bug !!    i<0の時におかしくなる !! integer ( SI ), intent ( in ) :: i character ( len = 7 ) :: str7 if ( i > 9999999 ) then str7 = 'XXXXXXX' else write ( str7 , '(i7.7)' ) i end if end function ut__int_to_str7","tags":"","loc":"proc/ut__int_to_str7.html"},{"title":"message_decorated_str – Smoke Ring","text":"private subroutine message_decorated_str(mark, string) 飾り文字でメーセージ文を囲む Usage: call message_decorated_str('#',\"This is a test.\") Output: ###################\n  # This is a test. #\n  ################### Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字でメーセージを囲む character(len=*), intent(in) :: string 出力メーセージ（文字列） Called by proc~~message_decorated_str~~CalledByGraph proc~message_decorated_str message_decorated_str interface~ut__message ut__message interface~ut__message->proc~message_decorated_str proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_decorated_strCalledByGraph = svgPanZoom('#procmessage_decorated_strCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_decorated_str Source Code subroutine message_decorated_str ( mark , string ) !! 飾り文字でメーセージ文を囲む !! !!   Usage: !! !!      call message_decorated_str('#',\"This is a test.\") !! !!   Output: !! !!      ################### !!      # This is a test. # !!      ################### !! character , intent ( in ) :: mark !! この文字でメーセージを囲む character ( len =* ), intent ( in ) :: string !! 出力メーセージ（文字列） integer ( SI ) :: len len = len_trim ( string ) + 4 write ( 6 , * ) repeat ( mark , len ) write ( 6 , * ) mark // ' ' // trim ( string ) // ' ' // mark write ( 6 , * ) repeat ( mark , len ) end subroutine message_decorated_str","tags":"","loc":"proc/message_decorated_str.html"},{"title":"message_decorated_str_dint – Smoke Ring","text":"private subroutine message_decorated_str_dint(mark, string, int) 飾り文字でメーセージ文と倍精度整数を囲む Usage: call mess...('#','This is message at nloop = ', nloop) Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字で全体を囲む character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: int 文字列の後に書く倍精度整数 Calls proc~~message_decorated_str_dint~~CallsGraph proc~message_decorated_str_dint message_decorated_str_dint proc~message_decorated_str message_decorated_str proc~message_decorated_str_dint->proc~message_decorated_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~message_decorated_str_dint~~CalledByGraph proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message ut__message interface~ut__message->proc~message_decorated_str_dint proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_decorated_str_dintCalledByGraph = svgPanZoom('#procmessage_decorated_str_dintCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_decorated_str_dint Source Code subroutine message_decorated_str_dint ( mark , string , int ) !!  飾り文字でメーセージ文と倍精度整数を囲む !! !!  Usage: !! !!     call mess...('#','This is message at nloop = ', nloop) !! character , intent ( in ) :: mark !! この文字で全体を囲む character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( DI ), intent ( in ) :: int !! 文字列の後に書く倍精度整数 character ( len = 200 ) :: string_int write ( string_int , '(a,i8)' ) string , int call message_decorated_str ( mark , string_int ) end subroutine message_decorated_str_dint","tags":"","loc":"proc/message_decorated_str_dint.html"},{"title":"message_decorated_str_sint – Smoke Ring","text":"private subroutine message_decorated_str_sint(mark, string, int) 飾り文字でメーセージ文と単精度整数を囲む Usage: call mess...('#','This is message at nloop = ', nloop) Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字で全体を囲む character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: int 文字列の後に書く単精度整数 Calls proc~~message_decorated_str_sint~~CallsGraph proc~message_decorated_str_sint message_decorated_str_sint proc~message_decorated_str message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~message_decorated_str_sint~~CalledByGraph proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message ut__message interface~ut__message->proc~message_decorated_str_sint proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_decorated_str_sintCalledByGraph = svgPanZoom('#procmessage_decorated_str_sintCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_decorated_str_sint Source Code subroutine message_decorated_str_sint ( mark , string , int ) !!  飾り文字でメーセージ文と単精度整数を囲む !! !!  Usage: !! !!     call mess...('#','This is message at nloop = ', nloop) character , intent ( in ) :: mark !! この文字で全体を囲む character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( SI ), intent ( in ) :: int !! 文字列の後に書く単精度整数 character ( len = 200 ) :: string_int write ( string_int , '(a,i8)' ) string , int call message_decorated_str ( mark , string_int ) end subroutine message_decorated_str_sint","tags":"","loc":"proc/message_decorated_str_sint.html"},{"title":"message_str – Smoke Ring","text":"private subroutine message_str(string) 普通のprint文 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 Called by proc~~message_str~~CalledByGraph proc~message_str message_str interface~ut__message ut__message interface~ut__message->proc~message_str proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_strCalledByGraph = svgPanZoom('#procmessage_strCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_str Source Code subroutine message_str ( string ) !! 普通のprint文 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 write ( 6 , * ) string end subroutine message_str","tags":"","loc":"proc/message_str.html"},{"title":"message_str_dint – Smoke Ring","text":"private subroutine message_str_dint(string, int) 文字列 + 倍精度整数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: int 書き出される整数 Called by proc~~message_str_dint~~CalledByGraph proc~message_str_dint message_str_dint interface~ut__message ut__message interface~ut__message->proc~message_str_dint proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_str_dintCalledByGraph = svgPanZoom('#procmessage_str_dintCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_str_dint Source Code subroutine message_str_dint ( string , int ) !! 文字列 + 倍精度整数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( DI ), intent ( in ) :: int !! 書き出される整数 write ( 6 , * ) string , int end subroutine message_str_dint","tags":"","loc":"proc/message_str_dint.html"},{"title":"message_str_dint_double – Smoke Ring","text":"private subroutine message_str_dint_double(string, i1, d1) 文字列 + 倍精度整数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 Called by proc~~message_str_dint_double~~CalledByGraph proc~message_str_dint_double message_str_dint_double interface~ut__message ut__message interface~ut__message->proc~message_str_dint_double proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_str_dint_doubleCalledByGraph = svgPanZoom('#procmessage_str_dint_doubleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_str_dint_double Source Code subroutine message_str_dint_double ( string , i1 , d1 ) !! 文字列 + 倍精度整数 + 倍精度実数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( DI ), intent ( in ) :: i1 !! 書き出される整数 real ( DR ), intent ( in ) :: d1 !! 書き出される実数 write ( 6 , * ) string , i1 , d1 end subroutine message_str_Dint_double","tags":"","loc":"proc/message_str_dint_double.html"},{"title":"message_str_dint_double_double – Smoke Ring","text":"private subroutine message_str_dint_double_double(string, i1, d1, d2) 文字列 + 倍精度整数 + 倍精度実数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 real(kind=DR), intent(in) :: d2 書き出される実数 Called by proc~~message_str_dint_double_double~~CalledByGraph proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message ut__message interface~ut__message->proc~message_str_dint_double_double proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_str_dint_double_doubleCalledByGraph = svgPanZoom('#procmessage_str_dint_double_doubleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_str_dint_double_double Source Code subroutine message_str_dint_double_double ( string , i1 , d1 , d2 ) !! 文字列 + 倍精度整数 + 倍精度実数 + 倍精度実数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( DI ), intent ( in ) :: i1 !! 書き出される整数 real ( DR ), intent ( in ) :: d1 , d2 !! 書き出される実数 write ( 6 , * ) string , i1 , d1 , d2 end subroutine message_str_Dint_double_double","tags":"","loc":"proc/message_str_dint_double_double.html"},{"title":"message_str_double – Smoke Ring","text":"private subroutine message_str_double(string, double) 文字列 + 倍精度実数2つの出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 real(kind=DR), intent(in) :: double 書き出される実数 Called by proc~~message_str_double~~CalledByGraph proc~message_str_double message_str_double interface~ut__message ut__message interface~ut__message->proc~message_str_double proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_str_doubleCalledByGraph = svgPanZoom('#procmessage_str_doubleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_str_double Source Code subroutine message_str_double ( string , double ) !! 文字列 + 倍精度実数2つの出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 real ( DR ), intent ( in ) :: double !! 書き出される実数 write ( 6 , * ) string , double end subroutine message_str_double","tags":"","loc":"proc/message_str_double.html"},{"title":"message_str_float – Smoke Ring","text":"private subroutine message_str_float(string, float) 文字列 + 単精度実数2つの出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 real(kind=SR), intent(in) :: float 書き出される実数 Called by proc~~message_str_float~~CalledByGraph proc~message_str_float message_str_float interface~ut__message ut__message interface~ut__message->proc~message_str_float proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_str_floatCalledByGraph = svgPanZoom('#procmessage_str_floatCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_str_float Source Code subroutine message_str_float ( string , float ) !! 文字列 + 単精度実数2つの出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 real ( SR ), intent ( in ) :: float !! 書き出される実数 write ( 6 , * ) string , float end subroutine message_str_float","tags":"","loc":"proc/message_str_float.html"},{"title":"message_str_sint – Smoke Ring","text":"private subroutine message_str_sint(string, int) 文字列 + 単精度整数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: int 書き出される整数 Called by proc~~message_str_sint~~CalledByGraph proc~message_str_sint message_str_sint interface~ut__message ut__message interface~ut__message->proc~message_str_sint proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_str_sintCalledByGraph = svgPanZoom('#procmessage_str_sintCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_str_sint Source Code subroutine message_str_sint ( string , int ) !! 文字列 + 単精度整数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( SI ), intent ( in ) :: int !! 書き出される整数 write ( 6 , * ) string , int end subroutine message_str_sint","tags":"","loc":"proc/message_str_sint.html"},{"title":"message_str_sint_double – Smoke Ring","text":"private subroutine message_str_sint_double(string, i1, d1) 文字列 + 単精度整数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 Called by proc~~message_str_sint_double~~CalledByGraph proc~message_str_sint_double message_str_sint_double interface~ut__message ut__message interface~ut__message->proc~message_str_sint_double proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_str_sint_doubleCalledByGraph = svgPanZoom('#procmessage_str_sint_doubleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_str_sint_double Source Code subroutine message_str_sint_double ( string , i1 , d1 ) !! 文字列 + 単精度整数 + 倍精度実数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( SI ), intent ( in ) :: i1 !! 書き出される整数 real ( DR ), intent ( in ) :: d1 !! 書き出される実数 write ( 6 , * ) string , i1 , d1 end subroutine message_str_sint_double","tags":"","loc":"proc/message_str_sint_double.html"},{"title":"message_str_sint_double_double – Smoke Ring","text":"private subroutine message_str_sint_double_double(string, i1, d1, d2) 文字列 + 単精度整数 + 倍精度実数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 real(kind=DR), intent(in) :: d2 書き出される実数 Called by proc~~message_str_sint_double_double~~CalledByGraph proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message ut__message interface~ut__message->proc~message_str_sint_double_double proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocmessage_str_sint_double_doubleCalledByGraph = svgPanZoom('#procmessage_str_sint_double_doubleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code message_str_sint_double_double Source Code subroutine message_str_sint_double_double ( string , i1 , d1 , d2 ) !! 文字列 + 単精度整数 + 倍精度実数 + 倍精度実数の出力 character ( len =* ), intent ( in ) :: string !! メーセージ文字列 integer ( SI ), intent ( in ) :: i1 !! 書き出される整数 real ( DR ), intent ( in ) :: d1 , d2 !! 書き出される実数 write ( 6 , * ) string , i1 , d1 , d2 end subroutine message_str_sint_double_double","tags":"","loc":"proc/message_str_sint_double_double.html"},{"title":"ut__assert – Smoke Ring","text":"public subroutine ut__assert(condition, last_will) アサーション Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition 必須条件 character(len=*), intent(in) :: last_will 遺言 Calls proc~~ut__assert~~CallsGraph proc~ut__assert ut__assert proc~ut__fatal ut__fatal proc~ut__assert->proc~ut__fatal interface~ut__message ut__message proc~ut__fatal->interface~ut__message proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ut__assert~~CalledByGraph proc~ut__assert ut__assert proc~params__get_string params__get_string proc~params__get_string->proc~ut__assert proc~the_equation the_equation proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor interface~debug__print debug__print proc~the_equation->interface~debug__print proc~slicedata__write slicedata__write proc~slicedata__write->proc~ut__assert proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~params__get_logical params__get_logical proc~params__get_logical->proc~ut__assert proc~params__get_double params__get_double proc~params__get_double->proc~ut__assert proc~drive_force_factor->proc~ut__assert proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->proc~ut__assert proc~solver__set_time_step->proc~params__get_logical proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print proc~print_str_sint print_str_sint proc~print_str_sint->proc~params__get_logical proc~print_str_dint print_str_dint proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~print_str_sint_double print_str_sint_double proc~print_str_sint_double->proc~params__get_logical proc~print_str_double print_str_double proc~print_str_double->proc~params__get_logical proc~print_str print_str proc~print_str->proc~params__get_logical proc~print_str_dint_double print_str_dint_double proc~print_str_dint_double->proc~params__get_logical proc~solver__advance solver__advance proc~solver__advance->proc~the_equation proc~solver__advance->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~solver__advance->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~solver__set_time_step program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->proc~solver__initialize program~main_m->proc~solver__advance program~main_m->interface~debug__print proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis interface~debug__print->proc~print_str_sint interface~debug__print->proc~print_str_dint interface~debug__print->proc~print_str_sint_double interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str interface~debug__print->proc~print_str_dint_double proc~subfield_vel_tm->interface~debug__print proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~subfield_vel_tm_divv->interface~debug__print proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocut__assertCalledByGraph = svgPanZoom('#procut__assertCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ut__assert Source Code subroutine ut__assert ( condition , last_will ) !! アサーション logical , intent ( in ) :: condition !! 必須条件 character ( len =* ), intent ( in ) :: last_will !! 遺言 if (. not . condition ) then call ut__fatal ( last_will ) end if end subroutine ut__assert","tags":"","loc":"proc/ut__assert.html"},{"title":"ut__fatal – Smoke Ring","text":"public subroutine ut__fatal(last_will) 致命的エラー 遺言を書き出してプログラムを停止する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: last_will Calls proc~~ut__fatal~~CallsGraph proc~ut__fatal ut__fatal interface~ut__message ut__message proc~ut__fatal->interface~ut__message proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ut__fatal~~CalledByGraph proc~ut__fatal ut__fatal proc~params__get_string params__get_string proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~ut__assert->proc~ut__fatal proc~params__get_logical params__get_logical proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~params__get_double params__get_double proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~params__get_integer params__get_integer proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string interface~debug__print debug__print proc~slicedata__initialize->interface~debug__print proc~the_equation the_equation proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~the_equation->interface~debug__print proc~slicedata__write slicedata__write proc~slicedata__write->proc~ut__assert proc~slicedata__write->proc~params__get_integer proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~print_str_sint print_str_sint proc~print_str_sint->proc~params__get_logical proc~print_str_dint print_str_dint proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~print_str_double print_str_double proc~print_str_double->proc~params__get_logical proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->proc~ut__assert proc~solver__set_time_step->proc~params__get_logical proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~print_str print_str proc~print_str->proc~params__get_logical proc~print_str_dint_double print_str_dint_double proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double print_str_sint_double proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->proc~slicedata__write program~main_m->proc~solver__initialize program~main_m->proc~solver__set_time_step proc~solver__advance solver__advance program~main_m->proc~solver__advance program~main_m->interface~debug__print proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis proc~drive_force_factor->proc~ut__assert proc~solver__advance->proc~the_equation proc~solver__advance->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~solver__advance->proc~subfield_vel_tm_divv interface~debug__print->proc~print_str_sint interface~debug__print->proc~print_str_dint interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str interface~debug__print->proc~print_str_dint_double interface~debug__print->proc~print_str_sint_double proc~subfield_vel_tm->interface~debug__print proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~subfield_vel_tm_divv->interface~debug__print proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocut__fatalCalledByGraph = svgPanZoom('#procut__fatalCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ut__fatal Source Code subroutine ut__fatal ( last_will ) !! 致命的エラー !! !!   遺言を書き出してプログラムを停止する !! character ( len =* ), intent ( in ) :: last_will call ut__message ( '!' , last_will ) stop 'Program stopped by ut__fatal.' end subroutine ut__fatal","tags":"","loc":"proc/ut__fatal.html"},{"title":"ut__message – Smoke Ring","text":"public interface ut__message 文字列（+ 数値）を標準出力に書き出すルーチンの多重定義 message_decorated_なんとか は飾り文字で囲む message_型名[_型名] は文字列の後のその型の数値を同じ行に書く Calls interface~~ut__message~~CallsGraph interface~ut__message ut__message proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~ut__message~~CalledByGraph interface~ut__message ut__message proc~params__get_string params__get_string proc~params__get_string->interface~ut__message proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~slicedata__write slicedata__write proc~slicedata__write->interface~ut__message proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer interface~debug__print debug__print proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~ut__fatal->interface~ut__message proc~print_str_double print_str_double proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~params__get_logical->proc~ut__assert proc~print_str print_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~params__get_double params__get_double proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__fatal proc~params__get_double->proc~ut__assert proc~job__finalize job__finalize proc~job__finalize->interface~ut__message proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->interface~ut__message proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->interface~ut__message proc~solver__diagnosis->interface~debug__print proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__fatal proc~params__get_integer->proc~ut__assert proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string proc~slicedata__initialize->interface~debug__print interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~ut__assert->proc~ut__fatal proc~print_str_dint_double->proc~params__get_logical proc~job__karte_set job__karte_set proc~job__karte_set->proc~ut__fatal proc~print_str_sint_double->proc~params__get_logical program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~job__finalize program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis program~main_m->proc~params__get_integer program~main_m->proc~slicedata__initialize program~main_m->interface~debug__print program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~the_equation the_equation proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm->interface~debug__print proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~drive_force_factor->proc~ut__assert interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var paninterfaceut__messageCalledByGraph = svgPanZoom('#interfaceut__messageCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures message_decorated_str message_decorated_str_dint message_decorated_str_sint message_str message_str_double message_str_float message_str_dint message_str_dint_double message_str_dint_double_double message_str_sint message_str_sint_double message_str_sint_double_double Module Procedures private subroutine message_decorated_str (mark, string) 飾り文字でメーセージ文を囲む Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字でメーセージを囲む character(len=*), intent(in) :: string 出力メーセージ（文字列） private subroutine message_decorated_str_dint (mark, string, int) 飾り文字でメーセージ文と倍精度整数を囲む Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字で全体を囲む character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: int 文字列の後に書く倍精度整数 private subroutine message_decorated_str_sint (mark, string, int) 飾り文字でメーセージ文と単精度整数を囲む Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字で全体を囲む character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: int 文字列の後に書く単精度整数 private subroutine message_str (string) 普通のprint文 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 private subroutine message_str_double (string, double) 文字列 + 倍精度実数2つの出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 real(kind=DR), intent(in) :: double 書き出される実数 private subroutine message_str_float (string, float) 文字列 + 単精度実数2つの出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 real(kind=SR), intent(in) :: float 書き出される実数 private subroutine message_str_dint (string, int) 文字列 + 倍精度整数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: int 書き出される整数 private subroutine message_str_dint_double (string, i1, d1) 文字列 + 倍精度整数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 private subroutine message_str_dint_double_double (string, i1, d1, d2) 文字列 + 倍精度整数 + 倍精度実数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 real(kind=DR), intent(in) :: d2 書き出される実数 private subroutine message_str_sint (string, int) 文字列 + 単精度整数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: int 書き出される整数 private subroutine message_str_sint_double (string, i1, d1) 文字列 + 単精度整数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 private subroutine message_str_sint_double_double (string, i1, d1, d2) 文字列 + 単精度整数 + 倍精度実数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 real(kind=DR), intent(in) :: d2 書き出される実数","tags":"","loc":"interface/ut__message.html"},{"title":"make_single_precision_field – Smoke Ring","text":"private subroutine make_single_precision_field(vel, ps) シミュレーションで計算した速度場と圧力場\n のx-z平面での断面データを求める。\n その際、倍精度実数から単精度実数に型変換する。 ここではx-z平面で書き出しているが、\n x-y平面での断面データなど、同様にとることが可能である。 サブルーチンmake_single_precision_fieldでは\n x-z面に平行な断面をとっている。その際、\n その断面位置は\n     j = slice_j = NY / 2\n としている。NYが偶数の時、\n この断面は厳密に言えばy=0にはなっていない。\n なぜならgridモジュールできめたy方向の格子点の\n 定義によればy=0の面はj=NY/2とj=NY/2+1の2つの面\n の中間にあるからである。正確にy=0面上での可視化\n をしたいのであればこの2つの面上でのデータ\n の平均値をディスクに書き出すべきである。 [バグ]\n   NYが奇数のときにちょうどy=0面に対応するのは\n     j = slice_j = NY / 2 + 1 \n   である。偶数のときにもこれでよい。\n        vor = .curl.vel\n  enstrophy = vor.dot.vor Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: vel 速度場（3D） real(kind=DR), intent(in), dimension(NX,NY,NZ) :: ps 圧力場（3D） Calls proc~~make_single_precision_field~~CallsGraph proc~make_single_precision_field make_single_precision_field proc~operator_curl operator_curl proc~make_single_precision_field->proc~operator_curl interface~debug__print debug__print proc~make_single_precision_field->interface~debug__print proc~operator_dot_product operator_dot_product proc~make_single_precision_field->proc~operator_dot_product proc~boundary_condition_vector boundary_condition_vector proc~operator_curl->proc~boundary_condition_vector proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message var panprocmake_single_precision_fieldCallsGraph = svgPanZoom('#procmake_single_precision_fieldCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~make_single_precision_field~~CalledByGraph proc~make_single_precision_field make_single_precision_field proc~slicedata__write slicedata__write proc~slicedata__write->proc~make_single_precision_field program~main_m main_m program~main_m->proc~slicedata__write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code make_single_precision_field Source Code subroutine make_single_precision_field ( vel , ps ) !! シミュレーションで計算した速度場と圧力場 !! のx-z平面での断面データを求める。 !! その際、倍精度実数から単精度実数に型変換する。 !! !! ここではx-z平面で書き出しているが、 !! x-y平面での断面データなど、同様にとることが可能である。 !! !! サブルーチンmake_single_precision_fieldでは !! x-z面に平行な断面をとっている。その際、 !! その断面位置は !!     j = slice_j = NY / 2 !! としている。NYが偶数の時、 !! この断面は厳密に言えばy=0にはなっていない。 !! なぜならgridモジュールできめたy方向の格子点の !! 定義によればy=0の面はj=NY/2とj=NY/2+1の2つの面 !! の中間にあるからである。正確にy=0面上での可視化 !! をしたいのであればこの2つの面上でのデータ !! の平均値をディスクに書き出すべきである。 !! !! [バグ] !!   NYが奇数のときにちょうどy=0面に対応するのは !!     j = slice_j = NY / 2 + 1 !!   である。偶数のときにもこれでよい。 type ( field__vector3d_t ), intent ( in ) :: vel !! 速度場（3D） real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: ps !! 圧力場（3D） integer ( SI ) :: slice_j = NY / 2 ! 断面をとるy座標の格子点位置 type ( field__vector3d_t ) :: vor ! vorticity、渦度 real ( DR ), dimension ( NX , NY , NZ ) :: enstrophy ! 渦度の2乗 !>        vor = .curl.vel !>  enstrophy = vor.dot.vor vor = operator_curl ( vel ) enstrophy = operator_dot_product ( vor , vor ) Slice_vx = real ( vel % x (:, slice_j ,:), SR ) Slice_vy = real ( vel % y (:, slice_j ,:), SR ) Slice_vz = real ( vel % z (:, slice_j ,:), SR ) Slice_ps = real ( ps (:, slice_j ,:), SR ) Slice_en = real ( enstrophy (:, slice_j ,:), SR ) call debug__print ( 'called slicedata/make_single_precision_field.' ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine make_single_precision_field","tags":"","loc":"proc/make_single_precision_field.html"},{"title":"slicedata__initialize – Smoke Ring","text":"public subroutine slicedata__initialize() このモジュールの初期化 流体の場（fluid）の配列は決め打ち（つまりallocatableにしない）で\n 最初から3次元配列を確保している一方、ここではSlice_??配列を\n アロケータブルにしているのは、このslicedataモジュールは\n シミュレーションには必須ではないためである。\n 場合によってはこのslicedataモジュールを使わずに\n シュミレーションすることも考えられる。\n 例えば断面ではなく三次元の可視化をする時など。\n そのような場合は、このslicedataモジュールは実際には\n 呼びたさないであろう。そのような時に備えて以下のように\n allocatableにしておけばメモリーを無駄遣いしない。 Arguments None Calls proc~~slicedata__initialize~~CallsGraph proc~slicedata__initialize slicedata__initialize interface~debug__print debug__print proc~slicedata__initialize->interface~debug__print proc~params__get_string params__get_string proc~slicedata__initialize->proc~params__get_string proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double interface~ut__message ut__message proc~params__get_string->interface~ut__message proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__assert proc~params__get_logical->proc~ut__fatal proc~message_decorated_str_sint->proc~message_decorated_str var panprocslicedata__initializeCallsGraph = svgPanZoom('#procslicedata__initializeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~slicedata__initialize~~CalledByGraph proc~slicedata__initialize slicedata__initialize program~main_m main_m program~main_m->proc~slicedata__initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code slicedata__initialize Source Code subroutine slicedata__initialize !! このモジュールの初期化 !! !! 流体の場（fluid）の配列は決め打ち（つまりallocatableにしない）で !! 最初から3次元配列を確保している一方、ここではSlice_??配列を !! アロケータブルにしているのは、このslicedataモジュールは !! シミュレーションには必須ではないためである。 !! 場合によってはこのslicedataモジュールを使わずに !! シュミレーションすることも考えられる。 !! 例えば断面ではなく三次元の可視化をする時など。 !! そのような場合は、このslicedataモジュールは実際には !! 呼びたさないであろう。そのような時に備えて以下のように !! allocatableにしておけばメモリーを無駄遣いしない。 allocate ( Slice_vx ( NX , NZ ), & Slice_vy ( NX , NZ ), & Slice_vz ( NX , NZ ), & Slice_ps ( NX , NZ ), & Slice_en ( NX , NZ )) call debug__print ( 'Slice data allocated.' ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 open ( FILE_SLICEDATA , & file = trim ( params__get_string ( 'Slicedata_tag' )), & form = 'unformatted' ) ! 断面データを書き出すファイルをオープン Initialize_done = . true . ! 初期化終了のフラグをonにする call debug__print ( 'called slicedata__initlilize' ) end subroutine slicedata__initialize","tags":"","loc":"proc/slicedata__initialize.html"},{"title":"slicedata__write – Smoke Ring","text":"public subroutine slicedata__write(nloop, time, fluid) 断面データのディスクへの書き出し Arguments Type Intent Optional Attributes Name integer(kind=DI), intent(in) :: nloop 現在のループカウンタ real(kind=DR), intent(in) :: time 現在の時刻 type( field__fluid_t ), intent(in) :: fluid 現在の流体データ Calls proc~~slicedata__write~~CallsGraph proc~slicedata__write slicedata__write interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield interface~debug__print debug__print proc~slicedata__write->interface~debug__print interface~ut__message ut__message proc~slicedata__write->interface~ut__message proc~ut__assert ut__assert proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field proc~params__get_integer params__get_integer proc~slicedata__write->proc~params__get_integer proc~subfield_vel subfield_vel interface~solver__get_subfield->proc~subfield_vel proc~subfield_vel_tm_divv subfield_vel_tm_divv interface~solver__get_subfield->proc~subfield_vel_tm_divv proc~subfield_vel_tm subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel_tm proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~ut__fatal ut__fatal proc~ut__assert->proc~ut__fatal proc~make_single_precision_field->interface~debug__print proc~operator_curl operator_curl proc~make_single_precision_field->proc~operator_curl proc~operator_dot_product operator_dot_product proc~make_single_precision_field->proc~operator_dot_product proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__assert proc~params__get_integer->proc~ut__fatal proc~params__get_logical params__get_logical proc~print_str_dint->proc~params__get_logical proc~subfield_vel->interface~debug__print proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel->proc~operator_vector_divby_scalar proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~message_decorated_str_dint->proc~message_decorated_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~subfield_vel_tm_divv->interface~debug__print proc~subfield_vel_tm_divv->proc~operator_vector_divby_scalar proc~operator_div operator_div proc~subfield_vel_tm_divv->proc~operator_div proc~boundary_condition_vector boundary_condition_vector proc~operator_curl->proc~boundary_condition_vector proc~print_str_sint->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message proc~subfield_vel_tm->interface~debug__print proc~subfield_vel_tm->proc~operator_vector_divby_scalar proc~boundary_condition_scalar boundary_condition_scalar proc~operator_div->proc~boundary_condition_scalar proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__assert proc~params__get_logical->proc~ut__fatal var panprocslicedata__writeCallsGraph = svgPanZoom('#procslicedata__writeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~slicedata__write~~CalledByGraph proc~slicedata__write slicedata__write program~main_m main_m program~main_m->proc~slicedata__write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code slicedata__write Source Code subroutine slicedata__write ( nloop , time , fluid ) !! 断面データのディスクへの書き出し integer ( DI ), intent ( in ) :: nloop !! 現在のループカウンタ real ( DR ), intent ( in ) :: time !! 現在の時刻 type ( field__fluid_t ), intent ( in ) :: fluid !! 現在の流体データ type ( field__vector3d_t ) :: vel ! 流れ速度ベクトル場。いまはナビエ・ストークス方程式の ! 基本変数を質量フラックスにしているのでこの流れ速度 ! ベクトル場は基本変数ではなく、基本変数から計算される ! 二次的な量である。 if ( params__get_integer ( 'Slicedata_nskip' ) <= 0 ) return ! 何らかの理由で断面データの ! 出力をしないときには ! parameter中のSlicedata_nskip ! の値を負にする。 if ( mod ( nloop , params__get_integer ( 'Slicedata_nskip' )) /= 0 ) return ! parameter中のSlicedata_nskip ! の値が例えば10の時には ! 10ステップおきに断面データを計算し、 ! ディスクに書き出す。 call ut__assert ( Initialize_done , \"<slicedata__write> Forgot init?\" ) ! モジュールの初期化終了確認 call solver__get_subfield ( fluid , vel ) ! 流体の基本変数から速度場を求める call make_single_precision_field ( vel , fluid % pressure ) ! 断面データを作成 write ( FILE_SLICEDATA ) nloop , real ( time , SR ), & Slice_vx , Slice_vy , Slice_vz , & Slice_ps , Slice_en ! ディスクへの書き出し ! 時刻も単精度に変換している call ut__message ( '#slice data saved at ' , nloop , time ) ! ここはデバッグモードがoffでも ! 書き出すようにしている。 ! 断面データはそれほど頻繁に ! 書き出さない（この行まで到達しない） ! のでこの出力がたくさんあって ! 邪魔になることはあまりないと ! 予想できるためである。 call debug__print ( 'called slicedata__write.' ) end subroutine slicedata__write","tags":"","loc":"proc/slicedata__write.html"},{"title":"params__get_double – Smoke Ring","text":"public function params__get_double(variable) このモジュールの外からの問い合わせに応じてnamelistデータを返す。\n この関数は問い合わせ変数が倍精度浮動小数点数の場合。\n この関数の前にnamelist__readが呼ばれている必要がある。\n この点はassertで確認している。 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value real(kind=DR) その値 Calls proc~~params__get_double~~CallsGraph proc~params__get_double params__get_double interface~ut__message ut__message proc~params__get_double->interface~ut__message proc~ut__assert ut__assert proc~params__get_double->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_double->proc~ut__fatal proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocparams__get_doubleCallsGraph = svgPanZoom('#procparams__get_doubleCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~params__get_double~~CalledByGraph proc~params__get_double params__get_double proc~solver__initialize solver__initialize proc~solver__initialize->proc~params__get_double program~main_m main_m program~main_m->proc~solver__initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code params__get_double Source Code function params__get_double ( variable ) !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が倍精度浮動小数点数の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 real ( DR ) :: params__get_double !! その値 call ut__assert ( Read_done , & '<params__get_double> Read params file first.' ) select case ( variable ) case ( 'Kappa' ) ! 熱拡散率 params__get_double = Kappa case ( 'Viscosity' ) ! 粘性率 params__get_double = Viscosity case default ! そんなnamelist変数は想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( '<params__get_double> not in the params?' ) end select end function params__get_double","tags":"","loc":"proc/params__get_double.html"},{"title":"params__get_integer – Smoke Ring","text":"public function params__get_integer(variable) このモジュールの外からの問い合わせに応じてnamelistデータを返す。\n この関数は問い合わせ変数が整数の場合。\n この関数の前にnamelist__readが呼ばれている必要がある。\n この点はassertで確認している。 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value integer(kind=SI) その値 Calls proc~~params__get_integer~~CallsGraph proc~params__get_integer params__get_integer interface~ut__message ut__message proc~params__get_integer->interface~ut__message proc~ut__assert ut__assert proc~params__get_integer->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_integer->proc~ut__fatal proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocparams__get_integerCallsGraph = svgPanZoom('#procparams__get_integerCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~params__get_integer~~CalledByGraph proc~params__get_integer params__get_integer program~main_m main_m program~main_m->proc~params__get_integer proc~slicedata__write slicedata__write program~main_m->proc~slicedata__write proc~slicedata__write->proc~params__get_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code params__get_integer Source Code function params__get_integer ( variable ) !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が整数の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 integer ( SI ) :: params__get_integer !! その値 call ut__assert ( Read_done , & '<params__get_integer> Read params file first.' ) select case ( variable ) case ( 'Slicedata_nskip' ) ! 何ステップごとに params__get_integer = Slicedata_nskip ! 断面をディスクに書き出すか case ( 'Total_nloop' ) ! シミュレーションジョブ params__get_integer = Total_nloop ! の実行最大ループ数 case default ! 想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( '<params__get_integer> not in the params?' ) end select end function params__get_integer","tags":"","loc":"proc/params__get_integer.html"},{"title":"params__get_logical – Smoke Ring","text":"public function params__get_logical(variable) このモジュールの外からの問い合わせに応じてnamelistデータを返す。\n この関数は問い合わせ変数が論理値の場合。\n この関数の前にnamelist__readが呼ばれている必要がある。\n この点はassertで確認している。 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value logical その値 Calls proc~~params__get_logical~~CallsGraph proc~params__get_logical params__get_logical interface~ut__message ut__message proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocparams__get_logicalCallsGraph = svgPanZoom('#procparams__get_logicalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~params__get_logical~~CalledByGraph proc~params__get_logical params__get_logical proc~print_str_sint print_str_sint proc~print_str_sint->proc~params__get_logical proc~print_str_dint print_str_dint proc~print_str_dint->proc~params__get_logical proc~print_str_double print_str_double proc~print_str_double->proc~params__get_logical proc~print_str print_str proc~print_str->proc~params__get_logical proc~print_str_dint_double print_str_dint_double proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double print_str_sint_double proc~print_str_sint_double->proc~params__get_logical proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->proc~params__get_logical proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm program~main_m main_m program~main_m->proc~solver__set_time_step interface~debug__print debug__print program~main_m->interface~debug__print proc~slicedata__initialize slicedata__initialize program~main_m->proc~slicedata__initialize proc~slicedata__write slicedata__write program~main_m->proc~slicedata__write proc~solver__initialize solver__initialize program~main_m->proc~solver__initialize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis interface~debug__print->proc~print_str_sint interface~debug__print->proc~print_str_dint interface~debug__print->proc~print_str_double interface~debug__print->proc~print_str interface~debug__print->proc~print_str_dint_double interface~debug__print->proc~print_str_sint_double proc~slicedata__initialize->interface~debug__print proc~the_equation the_equation proc~the_equation->interface~debug__print proc~subfield_vel_tm->interface~debug__print proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv var panprocparams__get_logicalCalledByGraph = svgPanZoom('#procparams__get_logicalCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code params__get_logical Source Code function params__get_logical ( variable ) !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が論理値の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 logical :: params__get_logical !! その値 call ut__assert ( Read_done , & '<params__get_logical> Read params file first.' ) select case ( variable ) case ( 'Debug' ) ! デバッグモードか否か params__get_logical = Debug case default ! 想定外 call ut__message ( '? arg = ' , variable ) call ut__fatal ( '<params__get_logical> not in the params?' ) end select end function params__get_logical","tags":"","loc":"proc/params__get_logical.html"},{"title":"params__get_string – Smoke Ring","text":"public function params__get_string(variable) このモジュールの外からの問い合わせに応じてnamelistデータを返す。\n この関数は問い合わせ変数が文字列の場合。\n この関数の前にnamelist__readが呼ばれている必要がある。\n この点はassertで確認している。 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value character(len=STRING_LENGTH_MAX) その値 Calls proc~~params__get_string~~CallsGraph proc~params__get_string params__get_string interface~ut__message ut__message proc~params__get_string->interface~ut__message proc~ut__assert ut__assert proc~params__get_string->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_string->proc~ut__fatal proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocparams__get_stringCallsGraph = svgPanZoom('#procparams__get_stringCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~params__get_string~~CalledByGraph proc~params__get_string params__get_string proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->proc~params__get_string program~main_m main_m program~main_m->proc~slicedata__initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code params__get_string Source Code function params__get_string ( variable ) !! このモジュールの外からの問い合わせに応じてnamelistデータを返す。 !! この関数は問い合わせ変数が文字列の場合。 !! この関数の前にnamelist__readが呼ばれている必要がある。 !! この点はassertで確認している。 character ( len =* ), intent ( in ) :: variable !! 問い合わせ変数の名前 character ( len = STRING_LENGTH_MAX ) :: params__get_string !! その値 call ut__assert ( Read_done , & '<params__get_string> Read params file first.' ) select case ( variable ) case ( 'Slicedata_tag' ) ! 断面ファイル名に使う params__get_string = Slicedata_tag case default call ut__message ( '? arg = ' , variable ) ! 想定外 call ut__fatal ( '<params__get_string> not in the params?' ) end select end function params__get_string","tags":"","loc":"proc/params__get_string.html"},{"title":"params__read – Smoke Ring","text":"public subroutine params__read() namelistファイルをディスクから読み込む。\n ファイル名はコマンド第一引数。 ファイル番号10番をここで使っている。他の場所で\n 10番を使う（開きっぱなしにする）場合は問題だが、\n その場所でもここのようにopenした後、closeしていれば\n 特に問題ではない。 namelistデータファイルの内容を変更する場合は\n 以下のread文も適宜変更すること。 * * * &simulation      Total_nloop = 2000 /\n &visualization   Slicedata_nskip  = 100, Slicedata_tag = '_data_slice' /\n &fluid_property  Viscosity = 3.0e-2, Kappa = 3.e-2 /\n &flags           Debug = .false. / * * * Arguments None Called by proc~~params__read~~CalledByGraph proc~params__read params__read program~main_m main_m program~main_m->proc~params__read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code params__read Source Code subroutine params__read !! namelistファイルをディスクから読み込む。 !! ファイル名はコマンド第一引数。 !! !! ファイル番号10番をここで使っている。他の場所で !! 10番を使う（開きっぱなしにする）場合は問題だが、 !! その場所でもここのようにopenした後、closeしていれば !! 特に問題ではない。 !! !! namelistデータファイルの内容を変更する場合は !! 以下のread文も適宜変更すること。 !! character ( len = STRING_LENGTH_MAX ) :: params_file call ut__assert ( command_argument_count () == 1 , & \"Usage: smoke_ring param_file\" ) call get_command_argument ( 1 , params_file ) !*******<params_file のサンプル>********* ! &simulation      Total_nloop = 2000 / ! &visualization   Slicedata_nskip  = 100, Slicedata_tag = '_data_slice' / ! &fluid_property  Viscosity = 3.0e-2, Kappa = 3.e-2 / ! &flags           Debug = .false. / !*******</params_file のサンプル>********* open ( 10 , file = trim ( params_file )) read ( 10 , nml = simulation ) read ( 10 , nml = visualization ) read ( 10 , nml = fluid_property ) read ( 10 , nml = flags ) close ( 10 ) write ( 6 , nml = simulation ) write ( 6 , nml = visualization ) write ( 6 , nml = fluid_property ) write ( 6 , nml = flags ) Read_done = . true . end subroutine params__read","tags":"","loc":"proc/params__read.html"},{"title":"drive_force_factor – Smoke Ring","text":"private function drive_force_factor(time) 渦輪を駆動する力の時間変化の調整のための係数設定 Note この係数は0以上1以下。これはassertで確認している。 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: time シミュレーション時刻 Return Value real(kind=DR) 力の強さ係数 0から1 Calls proc~~drive_force_factor~~CallsGraph proc~drive_force_factor drive_force_factor proc~ut__assert ut__assert proc~drive_force_factor->proc~ut__assert proc~ut__fatal ut__fatal proc~ut__assert->proc~ut__fatal interface~ut__message ut__message proc~ut__fatal->interface~ut__message proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocdrive_force_factorCallsGraph = svgPanZoom('#procdrive_force_factorCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~drive_force_factor~~CalledByGraph proc~drive_force_factor drive_force_factor proc~the_equation the_equation proc~the_equation->proc~drive_force_factor proc~solver__advance solver__advance proc~solver__advance->proc~the_equation program~main_m main_m program~main_m->proc~solver__advance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code drive_force_factor Source Code function drive_force_factor ( time ) !! 渦輪を駆動する力の時間変化の調整のための係数設定 !! !! @note この係数は0以上1以下。これはassertで確認している。 !! real ( DR ), intent ( in ) :: time !! シミュレーション時刻 real ( DR ) :: drive_force_factor !! 力の強さ係数 0から1 ! !                                      factor !              ___________               | !             /|         |\\              | !      ______/ |         | \\______       +--------> time !            | |         |  | !            | |         |  | !            | t0        t1 | !          t_start         t_end ! real ( DR ), parameter :: T_START = 0.0_DR ! 力をかけ始める時刻 real ( DR ), parameter :: T_END = 0.01_DR ! 力をかけ終わる時刻 ! 試行錯誤で調整せよ real ( DR ), parameter :: T0 = T_START + ( T_END - T_START ) / 4 real ( DR ), parameter :: T1 = T_END - ( T_END - T_START ) / 4 ! 上のコメント図をみよ ! これも試行錯誤で調整せよ real ( DR ), parameter :: ONE = 1.0_DR ! コードの読みやすさのため定義 real ( DR ), parameter :: ZERO = 0.0_DR ! コードの読みやすさのため定義 call ut__assert ( T_START < T0 . and . T0 < T1 . and . T1 < T_END , & \"<solver/drive_force_factor> Time inconsistent.\" ) ! この関係は以下の前提なのでアサートで確認しておく ! 上のコメント図の時間依存係数 if ( time <= T_START ) then drive_force_factor = ZERO else if ( time <= T0 ) then drive_force_factor = ( time - T_START ) / ( T0 - T_START ) else if ( time <= T1 ) then drive_force_factor = ONE else if ( time <= T_END ) then drive_force_factor = ONE - ( time - T1 ) / ( T_END - T1 ) else drive_force_factor = ZERO end if call ut__assert ( drive_force_factor >= 0.0_DR & . and . & drive_force_factor <= 1.0_DR , & \"<solver/drive_force_factor> strange value.\" ) end function drive_force_factor","tags":"","loc":"proc/drive_force_factor.html"},{"title":"solver__set_time_step – Smoke Ring","text":"public function solver__set_time_step(nloop, fluid) CFL条件に基づいて時間刻み幅dtを設定する Arguments Type Intent Optional Attributes Name integer(kind=DI), intent(in) :: nloop ループカウンタ type( field__fluid_t ), intent(in) :: fluid 流体データ Return Value real(kind=DR) 時間刻み幅 dt Calls proc~~solver__set_time_step~~CallsGraph proc~solver__set_time_step solver__set_time_step interface~ut__message ut__message proc~solver__set_time_step->interface~ut__message proc~ut__assert ut__assert proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~params__get_logical params__get_logical proc~solver__set_time_step->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__fatal ut__fatal proc~ut__assert->proc~ut__fatal interface~debug__print debug__print proc~subfield_vel_tm->interface~debug__print proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel_tm->proc~operator_vector_divby_scalar proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__assert proc~params__get_logical->proc~ut__fatal proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical var panprocsolver__set_time_stepCallsGraph = svgPanZoom('#procsolver__set_time_stepCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solver__set_time_step~~CalledByGraph proc~solver__set_time_step solver__set_time_step program~main_m main_m program~main_m->proc~solver__set_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solver__set_time_step Source Code function solver__set_time_step ( nloop , fluid ) !! CFL条件に基づいて時間刻み幅dtを設定する integer ( DI ), intent ( in ) :: nloop !! ループカウンタ type ( field__fluid_t ), intent ( in ) :: fluid !! 流体データ real ( DR ) :: solver__set_time_step !! 時間刻み幅 dt type ( field__vector3d_t ) :: vel ! 速度場 real ( DR ), dimension ( NX , NY , NZ ) :: tm ! 温度場 real ( DR ) :: vmax , sound_v ! 流れ速度の最大値と音速 real ( DR ) :: dt_vel , dt_sound , dt_viscous , dt_kappa ! 流れ速度、音波、粘性拡散、熱拡散、それぞれで決まる時間刻み幅 ! 実際のdtはこれらのなかで最も厳しい（小さい）値できまる。 real ( DR ), parameter :: ALMOST_ZERO = 1.e-20_DR ! ゼロ割り演算回避のためにつかう小さい値 real ( DR ), parameter :: ABNORMAL_VALUE = - 99 9.999_DR ! dtとしてありそうにない値（すぐ下で使う） real ( DR ), save :: dt = ABNORMAL_VALUE ! 時間刻み幅そのもの。初期設定でなんらかの失敗した場合 ! を検出するため最初はありそうない値を設定しておくが、 ! CFL条件に基づいて正しい値を一度設定したらその後は ! この宣言文にはsave属性がついているので、 ! この関数を抜けたあともその値を覚えている。 integer ( SI ), parameter :: SKIP = 20 ! dtを毎ステップ計算するのは大変（かなりの時間がかかる） ! のでこのSKIPステップに一度だけ計算する。毎ステップ計算する ! してもdtは1ステップでそれほど大きく変化しないからである。 ! ただし、計算が破綻（発散）するような場合は例外である。 call ut__assert ( Initialize_done , \"<solver__set_tim_step> Forgot init?\" ) ! 初期化忘れ確認 if ( mod ( nloop , SKIP ) == 0 ) then ! ほとんどの場合は、前回計算したdtを使う。 call subfield_vel_tm ( fluid , vel , tm ) ! 基本流体データから速度場と温度場を計算 vmax = maxval ( sqrt ( vel % x ** 2 + vel % y ** 2 + vel % z ** 2 )) ! 速度の最大値（ベクトルの長さの最大値）をもとめる ! ここでは配列演算を駆使して1行で書いているが ! 実際にはかなりの演算をしていることに注意。 ! これはバグではないが、maxvalとsqrtは交換すべき ! だろう。このままだと3次元配列の全要素にsqrt ! を掛けてからそのmaxvalをとっているが、これを ! 逆にした方が速いかもしれない。 vmax = max ( vmax , ALMOST_ZERO ) ! 初期条件では速度場がゼロなのでvmax=0となるが、あとで ! vmaxの割り算が出てくるので問題となる。それを回避するため ! ALMOST_ZEROが十分小さければよい。 sound_v = GAMMA * maxval ( sqrt ( GASS_CONST_FOR_AIR * tm )) ! 音速の最大値 ! これも上と同じ理屈で、maxvalとsqrtは交換すべき ! だろう。このままだと3次元配列の全要素にsqrt ! を掛けてからそのmaxvalをとっているが、これを ! 逆にした方が速いかもしれない。 call ut__assert ( sound_v > ALMOST_ZERO , \"<solver__time_step> sound_v=0?\" ) ! 音速（の最大値）がほとんどゼロになるのは ! 何かがおかしいのですぐに停止 ! 以下では、流れの速さ、音波、粘性拡散、熱拡散の4種類の ! CFL条件で決まる時間刻み幅をそれぞれこの順番に求めている。 dt_vel = 0.8_DR * grid % delta_min / vmax dt_sound = 0.8_DR * grid % delta_min / sound_v dt_viscous = 0.2_DR * ( grid % delta_min ** 2 ) / Viscosity dt_kappa = 0.2_DR * ( grid % delta_min ** 2 ) / Gamma1_kappa ! CFL factor はここでは0.8と0.2にしているが、 ! これは精密な議論に基づいて決めたものではなく、 ! 半経験的に決めた値である。 ! 最後の2つ、粘性拡散と熱拡散によるCFL条件のための ! CFL factor の値 (0.2) というのは少々安全側に設定 ! しすぎているかもしれない。つまりもう少し大きくしても ! 問題ないかもしれない。 dt = min ( dt_vel , dt_sound , dt_viscous , dt_kappa ) ! 最終的な時間刻み幅は上記の4種類のdtの最小値できまる。 if ( params__get_logical ( 'Debug' ) ) then ! デバッグモードがonであるとき、以下のデータを標準出力 ! に書き出す。出力が長くなるが、流体の状態を推測するのに ! 便利なデータである。 call ut__message ( '<solver__time_step> vmax = ' , vmax ) call ut__message ( '                  dt_vel = ' , dt_vel ) call ut__message ( '                dt_sound = ' , dt_sound ) call ut__message ( '                dt_kappa = ' , dt_kappa ) call ut__message ( '              dt_viscous = ' , dt_viscous ) call ut__message ( '               -->    dt = ' , dt ) end if if ( mod ( nloop , SKIP * 50 ) == 0 ) call ut__message ( \"> dt = \" , dt ) ! dtの値を（デバッグモードがoffであっても）書き出す ! SKIPをさら50倍しているのは、それほど頻繁に出力する ! 必要は通常ないからである。 end if call ut__assert ( dt /= ABNORMAL_VALUE , \"<solver__time_step> dt init failed?\" ) ! SKIPに一度dtを計算し直すが、それ以外は下の行を見れば分かる通り ! 前回のdtの値を流用する。 その際、一度もdtを計算したことがなかったら ! まずいのでその検出をABNORMAL_VALUEを使って検出している。 solver__set_time_step = dt ! dt of the prev calc is saved. ! 新たに更新（または前回計算した）dtを返す。 end function solver__set_time_step","tags":"","loc":"proc/solver__set_time_step.html"},{"title":"the_equation – Smoke Ring","text":"private function the_equation(t, dt, vx, vy, vz, tm, divv, fx, fy, fz, ps) ナビエ・ストークス方程式の右辺（時間変化量）dtを掛けたものを計算 Note 粘性による加熱の効果は小さいので無視している。\n    この項を入れる場合は圧力の方程式\n    the_equation%pressure に追加すればよい。 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: t 時刻と時間刻み幅 real(kind=DR), intent(in) :: dt 時刻と時間刻み幅 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: vx 速度3成分 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: vy 速度3成分 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: vz 速度3成分 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: tm 温度と速度の発散 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: divv 温度と速度の発散 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: fx 質量フラックス real(kind=DR), intent(in), dimension(NX,NY,NZ) :: fy 質量フラックス real(kind=DR), intent(in), dimension(NX,NY,NZ) :: fz 質量フラックス real(kind=DR), intent(in), dimension(NX,NY,NZ) :: ps 圧力 Return Value type( field__fluid_t ) 時間刻みdtでの流体データの微小変化量 Calls proc~~the_equation~~CallsGraph proc~the_equation the_equation interface~field__boundary_condition field__boundary_condition proc~the_equation->interface~field__boundary_condition proc~ut__assert ut__assert proc~the_equation->proc~ut__assert proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor interface~debug__print debug__print proc~the_equation->interface~debug__print proc~boundary_condition_scalar boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector proc~boundary_condition_fluid boundary_condition_fluid interface~field__boundary_condition->proc~boundary_condition_fluid proc~ut__fatal ut__fatal proc~ut__assert->proc~ut__fatal proc~drive_force_factor->proc~ut__assert proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~boundary_condition_fluid->proc~boundary_condition_scalar proc~boundary_condition_fluid->proc~boundary_condition_vector proc~print_str_sint_double->proc~params__get_logical proc~ut__fatal->interface~ut__message proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->proc~ut__assert proc~params__get_logical->proc~ut__fatal proc~params__get_logical->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocthe_equationCallsGraph = svgPanZoom('#procthe_equationCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~the_equation~~CalledByGraph proc~the_equation the_equation proc~solver__advance solver__advance proc~solver__advance->proc~the_equation program~main_m main_m program~main_m->proc~solver__advance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code the_equation Source Code function the_equation ( t , dt , vx , vy , vz , tm , divv , fx , fy , fz , ps ) !! ナビエ・ストークス方程式の右辺（時間変化量）dtを掛けたものを計算 !! !! @note !!    粘性による加熱の効果は小さいので無視している。 !!    この項を入れる場合は圧力の方程式 !!    the_equation%pressure に追加すればよい。 real ( DR ), intent ( in ) :: t , dt !! 時刻と時間刻み幅 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: vx , vy , vz !! 速度3成分 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: tm , divv !! 温度と速度の発散 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: fx , fy , fz !! 質量フラックス real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: ps !! 圧力 type ( field__fluid_t ) :: the_equation !! 時間刻みdtでの流体データの微小変化量 integer ( SI ) :: i , j , k real ( DR ), parameter :: ONE_THIRD = 1.0_DR / 3.0_DR ! 演算回数節約のため real ( DR ) :: gradpx , gradpy , gradpz ! 圧力の勾配 (gradient p) real ( DR ) :: gdivvx , gdivvy , gdivvz ! 速度の発散の勾配 real ( DR ) :: divfvx , divfvy , divfvz ! 速度・密度フラックステンソルの発散 real ( DR ) :: lapvx , lapvy , lapvz , laptm ! 速度と温度のラプラシアン real ( DR ) :: divf ! 質量フラックスの発散 real ( DR ) :: factor ! 渦輪駆動力の係数（時間依存） call ut__assert ( Initialize_done , \"<solver/the_equation> Forgot init?\" ) ! 初期化忘れしていないか確認 factor = drive_force_factor ( t ) ! 渦輪の駆動力はシミュレーション開始直後だけかける。 ! その後は何も力をかけない（渦輪が自然に発生し、リング上の ! 構造が移動していく。）つまりこのfactorはシミュレーション ! 開始直後だけ非ゼロで、残りの殆どの時間はゼロが入っている。 ! 以下のdo loopがこのシミュレーションで最も時間のかかる ! 部分である。したがってここでは.div.などのユーザ定義 ! 演算子は（コンパイラがその使用を許したとしても）あえて ! 使わず、泥臭く書いている。これは将来、 ! 速度向上のためにコードの最適化をしたり、 ! OpenMP化することを見越してのことである。 do k = 2 , NZ - 1 do j = 2 , NY - 1 do i = 2 , NX - 1 ! 以下のコメントでは ! P 圧力 ! V 速度場ベクトル ! F 質量フラックスベクトル ! T 温度 ! grad P gradpx = ( ps ( i + 1 , j , k ) - ps ( i - 1 , j , k ) ) * grid % d1 % x gradpy = ( ps ( i , j + 1 , k ) - ps ( i , j - 1 , k ) ) * grid % d1 % y gradpz = ( ps ( i , j , k + 1 ) - ps ( i , j , k - 1 ) ) * grid % d1 % z ! grad (div V) の3成分 gdivvx = ( divv ( i + 1 , j , k ) - divv ( i - 1 , j , k ) ) * grid % d1 % x gdivvy = ( divv ( i , j + 1 , k ) - divv ( i , j - 1 , k ) ) * grid % d1 % y gdivvz = ( divv ( i , j , k + 1 ) - divv ( i , j , k - 1 ) ) * grid % d1 % z ! VFテンソルの発散 div(VF) の3成分 divfvx = ( fx ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fx ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fx ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fx ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fx ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fx ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z divfvy = ( fy ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fy ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fy ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fy ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fy ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fy ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z divfvz = ( fz ( i + 1 , j , k ) * vx ( i + 1 , j , k ) & - fz ( i - 1 , j , k ) * vx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fz ( i , j + 1 , k ) * vy ( i , j + 1 , k ) & - fz ( i , j - 1 , k ) * vy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fz ( i , j , k + 1 ) * vz ( i , j , k + 1 ) & - fz ( i , j , k - 1 ) * vz ( i , j , k - 1 ) ) * grid % d1 % z ! Laplacin V の3成分 lapvx = ( vx ( i + 1 , j , k ) - 2 * vx ( i , j , k ) + vx ( i - 1 , j , k ) ) * grid % d2 % x & + ( vx ( i , j + 1 , k ) - 2 * vx ( i , j , k ) + vx ( i , j - 1 , k ) ) * grid % d2 % y & + ( vx ( i , j , k + 1 ) - 2 * vx ( i , j , k ) + vx ( i , j , k - 1 ) ) * grid % d2 % z lapvy = ( vy ( i + 1 , j , k ) - 2 * vy ( i , j , k ) + vy ( i - 1 , j , k ) ) * grid % d2 % x & + ( vy ( i , j + 1 , k ) - 2 * vy ( i , j , k ) + vy ( i , j - 1 , k ) ) * grid % d2 % y & + ( vy ( i , j , k + 1 ) - 2 * vy ( i , j , k ) + vy ( i , j , k - 1 ) ) * grid % d2 % z lapvz = ( vz ( i + 1 , j , k ) - 2 * vz ( i , j , k ) + vz ( i - 1 , j , k ) ) * grid % d2 % x & + ( vz ( i , j + 1 , k ) - 2 * vz ( i , j , k ) + vz ( i , j - 1 , k ) ) * grid % d2 % y & + ( vz ( i , j , k + 1 ) - 2 * vz ( i , j , k ) + vz ( i , j , k - 1 ) ) * grid % d2 % z ! Laplacin T laptm = ( tm ( i + 1 , j , k ) - 2 * tm ( i , j , k ) + tm ( i - 1 , j , k ) ) * grid % d2 % x & + ( tm ( i , j + 1 , k ) - 2 * tm ( i , j , k ) + tm ( i , j - 1 , k ) ) * grid % d2 % y & + ( tm ( i , j , k + 1 ) - 2 * tm ( i , j , k ) + tm ( i , j , k - 1 ) ) * grid % d2 % z ! div F divf = ( fx ( i + 1 , j , k ) - fx ( i - 1 , j , k ) ) * grid % d1 % x & + ( fy ( i , j + 1 , k ) - fy ( i , j - 1 , k ) ) * grid % d1 % y & + ( fz ( i , j , k + 1 ) - fz ( i , j , k - 1 ) ) * grid % d1 % z ! 以下がナビエ・ストークス方程式 !  密度の時間発展 the_equation % density ( i , j , k ) = - divf * dt !  質量フラックスの時間発展（3成分） the_equation % flux % x ( i , j , k ) = & ( - divfvx & - gradpx & + Drive_force % x ( i , j , k ) * factor & + Viscosity * ( lapvx + ONE_THIRD * gdivvx ) & ) * dt the_equation % flux % y ( i , j , k ) = & ( - divfvy & - gradpy & + Drive_force % y ( i , j , k ) * factor & + Viscosity * ( lapvy + ONE_THIRD * gdivvy ) & ) * dt the_equation % flux % z ( i , j , k ) = & ( - divfvz & - gradpz & + Drive_force % z ( i , j , k ) * factor & + Viscosity * ( lapvz + ONE_THIRD * gdivvz ) & ) * dt !  圧力の時間発展 the_equation % pressure ( i , j , k ) = & ( - ( vx ( i , j , k ) * gradpx & + vy ( i , j , k ) * gradpy & + vz ( i , j , k ) * gradpz & ) & + Gamma1_kappa * laptm & - GAMMA * ps ( i , j , k ) * divv ( i , j , k ) & ) * dt end do end do end do call field__boundary_condition ( the_equation ) ! 境界条件の設定（周期境界条件） ! 上のdo loopは境界面上の格子点を除いた格子点（シミュレーション ! 領域の内部の格子点）上での値を計算するものであった。 ! ここで境界面上の格子点の値の（更新されたばかりの）内部の ! 格子点上のデータをコピーすることで設定する。 call debug__print ( \"called solver/the_equation.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end function the_equation","tags":"","loc":"proc/the_equation.html"},{"title":"set_drive_force_field – Smoke Ring","text":"private subroutine set_drive_force_field() 渦輪を駆動するための力の場を設定する\n その力はシミュレーション開始直後、短い時間だけかける。\n 空間的には局在した力を想定している。その形状は円筒形である。\n 円筒の軸はx軸上にある。 Arguments None Calls proc~~set_drive_force_field~~CallsGraph proc~set_drive_force_field set_drive_force_field interface~field__boundary_condition field__boundary_condition proc~set_drive_force_field->interface~field__boundary_condition interface~debug__print debug__print proc~set_drive_force_field->interface~debug__print proc~boundary_condition_scalar boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector proc~boundary_condition_fluid boundary_condition_fluid interface~field__boundary_condition->proc~boundary_condition_fluid proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~boundary_condition_fluid->proc~boundary_condition_scalar proc~boundary_condition_fluid->proc~boundary_condition_vector proc~print_str_sint_double->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message var panprocset_drive_force_fieldCallsGraph = svgPanZoom('#procset_drive_force_fieldCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_drive_force_field~~CalledByGraph proc~set_drive_force_field set_drive_force_field proc~solver__initialize solver__initialize proc~solver__initialize->proc~set_drive_force_field program~main_m main_m program~main_m->proc~solver__initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_drive_force_field Source Code subroutine set_drive_force_field !! 渦輪を駆動するための力の場を設定する !! その力はシミュレーション開始直後、短い時間だけかける。 !! 空間的には局在した力を想定している。その形状は円筒形である。 !! 円筒の軸はx軸上にある。 integer ( SI ) :: i , j , k real ( DR ) :: xx , yy , zz real ( DR ) :: force_region_x_min , force_region_x_max real ( DR ) :: force_center_y , force_center_z real ( DR ) :: force_cylinder_diameter , force_cylinder_radius_sq real ( DR ), parameter :: THE_FORCE = 3.e3_DR ! 瞬間的な力の最大値。 ! 試行錯誤で調整せよ。 ! !     +--------------------------------------+ ZMAX !     |                                      | !     |    +-------+                         | !     |    | Force |                         | !     |    +-------+                         | !     |                                      | !     +--------------------------------------+ ZMIN !    XMIN                                   XMAX ! force_region_x_min = XMIN + ( XMAX - XMIN ) / 5 ! 力をかける局所円筒領域のx方向の最小値 force_region_x_max = force_region_x_min + ( XMAX - XMIN ) / 10 ! 力をかける局所円筒領域のx方向の最大値 force_center_y = ( YMAX + YMIN ) / 2 ! 力をかける局所円筒領域の中心のy座標を中間にとる force_center_z = ( ZMAX + ZMIN ) / 2 ! 力をかける局所円筒領域の中心のz座標を中間にとる force_cylinder_diameter = min ( YMAX - YMIN , ZMAX - ZMIN ) / 4 ! 力をかける局所円筒領域の直径 force_cylinder_radius_sq = ( force_cylinder_diameter / 2 ) ** 2 ! 力をかける局所円筒領域の半径の2乗 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! を回る3重do loop。境界上の格子点で値は境界条件で設定する。 zz = grid % pos % z ( k ) - force_center_z ! 力の中心からのz方向の距離 do j = 2 , NY - 1 yy = grid % pos % y ( j ) - force_center_y ! 力の中心からのy方向の距離 do i = 2 , NX - 1 xx = grid % pos % x ( i ) ! これは格子点のx座標そのもの if ( ( yy ** 2 + zz ** 2 ) < force_cylinder_radius_sq & . and . & ( xx > force_region_x_min ) & . and . & ( xx < force_region_x_max ) ) then ! ここで半径そのもので比較するとsqrtの計算が必要になるが ! このように2乗同士で比較すれば不要。 Drive_force % x ( i , j , k ) = THE_FORCE ! いまはx方向だけに力がかかる Drive_force % y ( i , j , k ) = 0.0_DR ! としている。斜め方向に力を Drive_force % z ( i , j , k ) = 0.0_DR ! かけるにはこの部分を変更。 else Drive_force % x ( i , j , k ) = 0.0_DR Drive_force % y ( i , j , k ) = 0.0_DR Drive_force % z ( i , j , k ) = 0.0_DR end if end do end do end do call field__boundary_condition ( Drive_force ) ! 上の3重do loopで設定していない境界上の格子点に力の場を ! 設定する。周期境界条件。 call ut__assert ( maxval ( Drive_force % x ) == THE_FORCE , & \"<solver/set_drive_force_field> something is wrong.\" ) ! 最大値がTHE_FORCEと仮定しているのでそうでなければ何かがおかしい。 call debug__print ( \"called solver/set_drive_force_field.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine set_drive_force_field","tags":"","loc":"proc/set_drive_force_field.html"},{"title":"solver__advance – Smoke Ring","text":"public subroutine solver__advance(t, dt, fluid) 4段4次ルンゲ・クッタ積分法による時間積分の実行 Note ここでは教科書に書かれている古典的な4段4次の\n   ルンゲ・クッタ積分法をそのまま実装している。\n   作業用の構造体を5つ使用している（dfluid01からdfluid04とgluid）\n   これらの作業変数の数を減らし、メモリを節約にするためには\n   Runge-Kutta-Gill法などの方法がある。 Note 速度（vel）、温度（tm）, 速度の発散（divv）などの配列などは\n   このスキームでは基本変数から毎回計算すべき一種の作業配列である。\n   したがって、このモジュール内の他の場所（サブルーチン・関数）でも\n   これらの変数（3次元の大きな配列）を宣言・使用している。\n   使用メモリを節約するためにはこれらの作業配列は共通のものを\n   一つづつ用意するというのも可能である。しかし、そうするとコードが\n   読みにくくなるであろう。 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout) :: t 時刻 real(kind=DR), intent(in) :: dt 時間刻み幅 type( field__fluid_t ), intent(inout) :: fluid 流体データ Calls proc~~solver__advance~~CallsGraph proc~solver__advance solver__advance interface~debug__print debug__print proc~solver__advance->interface~debug__print proc~the_equation the_equation proc~solver__advance->proc~the_equation proc~operator_fluid_times_real operator_fluid_times_real proc~solver__advance->proc~operator_fluid_times_real proc~operator_fluid_add operator_fluid_add proc~solver__advance->proc~operator_fluid_add proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~solver__advance->proc~subfield_vel_tm_divv proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~the_equation->interface~debug__print proc~ut__assert ut__assert proc~the_equation->proc~ut__assert interface~field__boundary_condition field__boundary_condition proc~the_equation->interface~field__boundary_condition proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~subfield_vel_tm_divv->interface~debug__print proc~operator_div operator_div proc~subfield_vel_tm_divv->proc~operator_div proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel_tm_divv->proc~operator_vector_divby_scalar proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~boundary_condition_scalar boundary_condition_scalar proc~operator_div->proc~boundary_condition_scalar proc~print_str_dint->proc~params__get_logical proc~ut__fatal ut__fatal proc~ut__assert->proc~ut__fatal interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector proc~boundary_condition_fluid boundary_condition_fluid interface~field__boundary_condition->proc~boundary_condition_fluid proc~drive_force_factor->proc~ut__assert proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->proc~ut__assert proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__fatal proc~boundary_condition_fluid->proc~boundary_condition_scalar proc~boundary_condition_fluid->proc~boundary_condition_vector proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocsolver__advanceCallsGraph = svgPanZoom('#procsolver__advanceCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solver__advance~~CalledByGraph proc~solver__advance solver__advance program~main_m main_m program~main_m->proc~solver__advance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solver__advance Source Code subroutine solver__advance ( t , dt , fluid ) !! 4段4次ルンゲ・クッタ積分法による時間積分の実行 !! !! @note !!   ここでは教科書に書かれている古典的な4段4次の !!   ルンゲ・クッタ積分法をそのまま実装している。 !!   作業用の構造体を5つ使用している（dfluid01からdfluid04とgluid） !!   これらの作業変数の数を減らし、メモリを節約にするためには !!   Runge-Kutta-Gill法などの方法がある。 !! !! @note !!   速度（vel）、温度（tm）, 速度の発散（divv）などの配列などは !!   このスキームでは基本変数から毎回計算すべき一種の作業配列である。 !!   したがって、このモジュール内の他の場所（サブルーチン・関数）でも !!   これらの変数（3次元の大きな配列）を宣言・使用している。 !!   使用メモリを節約するためにはこれらの作業配列は共通のものを !!   一つづつ用意するというのも可能である。しかし、そうするとコードが !!   読みにくくなるであろう。 real ( DR ), intent ( inout ) :: t !! 時刻 real ( DR ), intent ( in ) :: dt !! 時間刻み幅 type ( field__fluid_t ), intent ( inout ) :: fluid !! 流体データ real ( DR ), parameter :: ONE_SIXTH = 1.0_DR / 6.0_DR ! 演算数節約の real ( DR ), parameter :: ONE_THIRD = 1.0_DR / 3.0_DR ! ために定義 type ( field__vector3d_t ) :: vel ! 速度場 real ( DR ), dimension ( NX , NY , NZ ) :: tm ! 温度場 real ( DR ), dimension ( NX , NY , NZ ) :: divv ! 速度場の発散 type ( field__fluid_t ) :: dfluid01 , dfluid02 , dfluid03 , dfluid04 ! 古典的な4段4次ルンゲ・クッタ積分法に必要な4つの作業配列 ! サイズが大きいことに注意。 type ( field__fluid_t ) :: gluid ! work variable ! さらにもう一つの作業配列 ! サイズが大きいことに注意。 !---ルンゲ・クッタの第1段---! call subfield_vel_tm_divv ( fluid , vel , tm , divv ) ! 基本変数から副次的変数である速度、温度、速度の発散を求める dfluid01 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & fluid % flux % x , fluid % flux % y , fluid % flux % z , & fluid % pressure ) t = t + dt / 2 ! 渦輪を駆動する力は時刻（t）の関数として設定しているので、 ! いま解いているナビエ・ストークス方程式は時間に陽に依存する。 !---ルンゲ・クッタの第2段---! ![  gluid = fluid + dfluid01*0.5_DR dfluid01 = operator_fluid_times_real ( dfluid01 , 0.5_DR ) gluid = operator_fluid_add ( fluid , dfluid01 ) ! Fortranコンパイラが自己定義演算子をきちんと処理できる ! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid02 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) !---ルンゲ・クッタの第3段---! ![  gluid = fluid + dfluid02*0.5_DR dfluid02 = operator_fluid_times_real ( dfluid02 , 0.5_DR ) gluid = operator_fluid_add ( fluid , dfluid02 ) ! Fortranコンパイラが自己定義演算子をきちんと処理できる ! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid03 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) t = t + dt / 2 ! 繰り返すが、渦輪を駆動する力は時刻（t）の関数として設定しているので、 ! いま解いているナビエ・ストークス方程式は時間に陽に依存する。 !---ルンゲ・クッタの第4段---! ![  gluid = fluid + dfluid03 gluid = operator_fluid_add ( fluid , dfluid03 ) ! Fortranコンパイラが自己定義演算子をきちんと処理できる ! 場合は上の簡潔な記述の方が（読みやすいので）好ましい。 call subfield_vel_tm_divv ( gluid , vel , tm , divv ) dfluid04 = the_equation ( t , dt , & vel % x , vel % y , vel % z , tm , divv , & gluid % flux % x , gluid % flux % y , gluid % flux % z , & gluid % pressure ) !--- 最終結果 ---! ![  fluid = fluid  & ![        + ONE_SIXTH*( dfluid01 + 2*dfluid02 + 2*dfluid03 + dfluid04 ) dfluid01 = operator_fluid_times_real ( dfluid01 , ONE_SIXTH ) dfluid02 = operator_fluid_times_real ( dfluid02 , ONE_THIRD ) dfluid03 = operator_fluid_times_real ( dfluid03 , ONE_THIRD ) dfluid04 = operator_fluid_times_real ( dfluid04 , ONE_SIXTH ) fluid = operator_fluid_add ( fluid , dfluid01 ) fluid = operator_fluid_add ( fluid , dfluid02 ) fluid = operator_fluid_add ( fluid , dfluid03 ) fluid = operator_fluid_add ( fluid , dfluid04 ) ! Fortranコンパイラが自己定義演算子をきちんと処理できる ! 場合は一番上の簡潔な記述の方が（読みやすいので）好ましい。 call debug__print ( \"called solver__advance.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine solver__advance","tags":"","loc":"proc/solver__advance.html"},{"title":"solver__diagnosis – Smoke Ring","text":"public subroutine solver__diagnosis(nloop, time, fluid) 流体の「健康状態」を診断する Arguments Type Intent Optional Attributes Name integer(kind=DI), intent(in) :: nloop ループカウンタ real(kind=DR), intent(in) :: time シミュレーション時刻 type( field__fluid_t ), intent(in) :: fluid 流体データ Calls proc~~solver__diagnosis~~CallsGraph proc~solver__diagnosis solver__diagnosis interface~debug__print debug__print proc~solver__diagnosis->interface~debug__print interface~ut__message ut__message proc~solver__diagnosis->interface~ut__message proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~operator_scalarintegral operator_scalarintegral proc~solver__diagnosis->proc~operator_scalarintegral proc~operator_energyintegral operator_energyintegral proc~solver__diagnosis->proc~operator_energyintegral proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~subfield_vel->interface~debug__print proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel->proc~operator_vector_divby_scalar proc~operator_dot_product operator_dot_product proc~operator_energyintegral->proc~operator_dot_product proc~params__get_logical params__get_logical proc~print_str_dint->proc~params__get_logical proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~message_decorated_str_dint->proc~message_decorated_str proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~message_decorated_str_sint->proc~message_decorated_str proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~ut__fatal->interface~ut__message var panprocsolver__diagnosisCallsGraph = svgPanZoom('#procsolver__diagnosisCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solver__diagnosis~~CalledByGraph proc~solver__diagnosis solver__diagnosis program~main_m main_m program~main_m->proc~solver__diagnosis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solver__diagnosis Source Code subroutine solver__diagnosis ( nloop , time , fluid ) !! 流体の「健康状態」を診断する integer ( DI ), intent ( in ) :: nloop !! ループカウンタ real ( DR ), intent ( in ) :: time !! シミュレーション時刻 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体データ integer ( SI ), parameter :: SKIP = 100 ! このルーチンは結構計算負荷が高いので、 ! 毎ステップではなく、SKIPステップごとに診断を実行する real ( DR ), parameter :: ABNORMALLY_LARGE = 1.e20_DR ! これよりも物理量が大きくなったら異常が生じたと判断する type ( field__vector3d_t ) :: vel ! 流れの速度場 if ( mod ( nloop , SKIP ) /= 0 ) return ! このルーチンは結構計算負荷が高いので、 ! 毎ステップではなく、SKIPステップごとに診断を実行する if ( job__karte % state /= \"fine\" ) return ! Already in error state. ! ジョブの健康状態がfine（つまり健康）以外の値に ! 設定する可能性があるのはここ以外にもある（例えばmain.f90の ! メインループでシミュレーションのループカウンタが最大値が達するなど） ! そのような場合、どうせこの後、ジョブの停止処理に入るので、 ! これ以上計算を進めなくてもよい。 if ( maxval ( fluid % flux % x ) > ABNORMALLY_LARGE ) then ! 質量フラックスのx成分の最大値が異常に大きい ! これはバグである。absを入れ忘れている。 call ut__message ( \"<solver__diagnosis> Massflux_x overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % flux % y ) > ABNORMALLY_LARGE ) then ! 質量フラックスのy成分の最大値が異常に大きい ! これもバグである。absを入れ忘れている。 call ut__message ( \"<solver__diagnosis> Massflux_y overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % flux % z ) > ABNORMALLY_LARGE ) then ! 質量フラックスのz成分の最大値が異常に大きい ! これもバグである。absを入れ忘れている。 call ut__message ( \"<solver__diagnosis> Massflux_z overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % density ) > ABNORMALLY_LARGE ) then ! 質量が異常に大きい call ut__message ( \"<solver__diagnosis> Density overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( maxval ( fluid % pressure ) > ABNORMALLY_LARGE ) then ! 圧力が異常に大きい call ut__message ( \"<solver__diagnosis> Pressure overflow.\" ) call job__karte % set ( \"over_flow\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( minval ( fluid % pressure ) < 0.0_DR ) then ! 圧力が負になってしまっている call ut__message ( \"<solver__diagnosis> Negative pressure.\" ) call job__karte % set ( \"negative_anormaly\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if if ( minval ( fluid % density ) < 0.0_DR ) then ! 密度が負になってしまっている call ut__message ( \"<solver__diagnosis> Negative density.\" ) call job__karte % set ( \"negative_anormaly\" ) return ! これ以上計算しても無駄（すぐに終了処理に入るべし） end if call subfield_vel ( fluid , vel ) ! 基本流れデータから副次的な速度場データを求める call ut__message ( '#max vel:' , nloop , time , & sqrt ( maxval ( vel % x ** 2 + vel % y ** 2 + vel % z ** 2 ))) ! 速度の最大値（ベクトルの長さ）を計算し標準出力に書き出す ! わずか1行で書いているが、実際にはここにかなりの計算が ! 含まれている。vel%x**2という配列演算は実際には3重do loop ! であり、maxval関数はその引数の3次元配列をとっている。 ! つまり全要素中の最大値をとっている。そして最後に ! sqrtをとって振幅（ベクトルの長さ）を計算している。 call ut__message ( '#flow energy: ' , nloop , time , & ![                                    .energyintegral.fluid) operator_energyintegral ( fluid )) ! ここでもFortranコンパイラが許せば.energyintegral.という ! 簡潔な演算子表現を使ったほうがよい。ここでもこの1行の ! 実行にはかなりの演算（速度ベクトル場のx,y,z3成分の2乗和に ! 資料密度を掛けたもの体積積分）が必要であることに注意。 call ut__message ( '#total mass: ' , nloop , time , & ![                                    .scalarintegral.(fluid%density)) operator_scalarintegral ( fluid % density )) ! 上と同様。こちらのほうは単なる密度場の体積積分なので ! 演算量は少ないが、シミュレーション領域全体に渡る体積積分 ! なので計算量は大きいことに間違いない。 call debug__print ( 'called solver__diagnosis.' ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine solver__diagnosis","tags":"","loc":"proc/solver__diagnosis.html"},{"title":"solver__initialize – Smoke Ring","text":"public subroutine solver__initialize(fluid) モジュールの初期化 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(out) :: fluid 流体データ Calls proc~~solver__initialize~~CallsGraph proc~solver__initialize solver__initialize interface~debug__print debug__print proc~solver__initialize->interface~debug__print proc~params__get_double params__get_double proc~solver__initialize->proc~params__get_double proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double interface~ut__message ut__message proc~params__get_double->interface~ut__message proc~ut__assert ut__assert proc~params__get_double->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_double->proc~ut__fatal proc~set_drive_force_field->interface~debug__print interface~field__boundary_condition field__boundary_condition proc~set_drive_force_field->interface~field__boundary_condition proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~boundary_condition_scalar boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector proc~boundary_condition_fluid boundary_condition_fluid interface~field__boundary_condition->proc~boundary_condition_fluid proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__assert proc~params__get_logical->proc~ut__fatal proc~boundary_condition_fluid->proc~boundary_condition_scalar proc~boundary_condition_fluid->proc~boundary_condition_vector proc~message_decorated_str_sint->proc~message_decorated_str var panprocsolver__initializeCallsGraph = svgPanZoom('#procsolver__initializeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solver__initialize~~CalledByGraph proc~solver__initialize solver__initialize program~main_m main_m program~main_m->proc~solver__initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solver__initialize Source Code subroutine solver__initialize ( fluid ) !! モジュールの初期化 type ( field__fluid_t ), intent ( out ) :: fluid !! 流体データ real ( DR ) :: kappa ! 空気の熱拡散率 ! 物理パラメータの設定 Viscosity = params__get_double ( 'Viscosity' ) ! 空気の粘性率 kappa = params__get_double ( 'Kappa' ) ! 空気の熱拡散率 ! Viscosityと違ってkappaの頭文字が大文字になっていない、つまり ! このモジュールのグローバルスコープを持つ変数としていない ! のはナビエ・ストークス方程式には下で定義するGamma1_kappa ! という量のみを通じてkappaが出てくるからである。 Gamma1_kappa = ( Gamma - 1 ) * kappa ! gammaは比熱比、つまり定積比熱と定圧比熱の比である。 ! 統計力学で習うように、この値は流体（気体）を構成する ! 分子の構造（自由度）で決まる。 ! 流体の初期条件の設定 fluid % pressure = 1.013e5_DR ! 1013 hPa (一気圧) fluid % density = 1.293_DR ! kg/m&#94;3 (空気の密度) ![  fluid%flux     = 0.0_DR      ! 初期速度なし（流れなし） fluid % flux % x = 0.0_DR ! 初期速度なし（流れなし） fluid % flux % y = 0.0_DR fluid % flux % z = 0.0_DR ! コンパイラが許す場合は上の簡潔な代入表現の方が望ましい ! 渦輪を駆動するための力の場の設定 call set_drive_force_field Initialize_done = . true . ! モジュール初期化終了フラグ call debug__print ( \"called solver__initialize.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine solver__initialize","tags":"","loc":"proc/solver__initialize.html"},{"title":"subfield_vel – Smoke Ring","text":"private subroutine subfield_vel(fluid, vel) fluidの基本変数から二次的な場vel（流れの速度ベクトル場）\n をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れの速度ベクトル Calls proc~~subfield_vel~~CallsGraph proc~subfield_vel subfield_vel interface~debug__print debug__print proc~subfield_vel->interface~debug__print proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel->proc~operator_vector_divby_scalar proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message var panprocsubfield_velCallsGraph = svgPanZoom('#procsubfield_velCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subfield_vel~~CalledByGraph proc~subfield_vel subfield_vel interface~solver__get_subfield solver__get_subfield interface~solver__get_subfield->proc~subfield_vel proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->proc~subfield_vel program~main_m main_m program~main_m->proc~solver__diagnosis proc~slicedata__write slicedata__write program~main_m->proc~slicedata__write proc~slicedata__write->interface~solver__get_subfield Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code subfield_vel Source Code subroutine subfield_vel ( fluid , vel ) !! fluidの基本変数から二次的な場vel（流れの速度ベクトル場） !! をもとめる。 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体基本場 type ( field__vector3d_t ), intent ( out ) :: vel !! 流れの速度ベクトル ![  vel = fluid%flux / fluid%density     ! operator defined in field. vel = operator_vector_divby_scalar ( fluid % flux , fluid % density ) ! Fortranコンパイラが自己定義演算子（field.f90で定義） ! を許せば上の簡潔な記述を使うべし。 call debug__print ( \"called solver/subfield_vel.\" ) ! デバッグモードがonの時には毎回メッセージを標準出力に ! 書き出す。コードが完成し、product runの段階に入ったら ! デバッグモードをoffにすれば、書き出しは抑制される。 ! この行をコメントアウトする必要はない。 end subroutine subfield_vel","tags":"","loc":"proc/subfield_vel.html"},{"title":"subfield_vel_tm – Smoke Ring","text":"private subroutine subfield_vel_tm(fluid, vel, tm) fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm）\n をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: tm 温度場 Calls proc~~subfield_vel_tm~~CallsGraph proc~subfield_vel_tm subfield_vel_tm interface~debug__print debug__print proc~subfield_vel_tm->interface~debug__print proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel_tm->proc~operator_vector_divby_scalar proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message var panprocsubfield_vel_tmCallsGraph = svgPanZoom('#procsubfield_vel_tmCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subfield_vel_tm~~CalledByGraph proc~subfield_vel_tm subfield_vel_tm interface~solver__get_subfield solver__get_subfield interface~solver__get_subfield->proc~subfield_vel_tm proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->proc~subfield_vel_tm program~main_m main_m program~main_m->proc~solver__set_time_step proc~slicedata__write slicedata__write program~main_m->proc~slicedata__write proc~slicedata__write->interface~solver__get_subfield Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code subfield_vel_tm Source Code subroutine subfield_vel_tm ( fluid , vel , tm ) !! fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm） !! をもとめる。 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体基本場 type ( field__vector3d_t ), intent ( out ) :: vel !! 流れ場 real ( DR ), dimension ( NX , NY , NZ ), intent ( out ) :: tm !! 温度場 ![   vel = fluid%flux / fluid%density ! operator defined in field.f90. vel = operator_vector_divby_scalar ( fluid % flux , fluid % density ) tm = fluid % pressure / ( GASS_CONST_FOR_AIR * fluid % density ) ! Fortranコンパイラが自己定義演算子（field.f90で定義） ! を許せば上の簡潔な記述を使うべし。 call debug__print ( \"called solver/subfield_vel_tm.\" ) end subroutine subfield_vel_tm","tags":"","loc":"proc/subfield_vel_tm.html"},{"title":"subfield_vel_tm_divv – Smoke Ring","text":"private subroutine subfield_vel_tm_divv(fluid, vel, tm, divv) fluidの基本変数から二次的な場（速度ベクトル場velと\n 温度場tmと速度の発散divv）をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: tm 温度場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: divv 流れの発散 Calls proc~~subfield_vel_tm_divv~~CallsGraph proc~subfield_vel_tm_divv subfield_vel_tm_divv interface~debug__print debug__print proc~subfield_vel_tm_divv->interface~debug__print proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel_tm_divv->proc~operator_vector_divby_scalar proc~operator_div operator_div proc~subfield_vel_tm_divv->proc~operator_div proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~boundary_condition_scalar boundary_condition_scalar proc~operator_div->proc~boundary_condition_scalar proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message var panprocsubfield_vel_tm_divvCallsGraph = svgPanZoom('#procsubfield_vel_tm_divvCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subfield_vel_tm_divv~~CalledByGraph proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~solver__advance solver__advance proc~solver__advance->proc~subfield_vel_tm_divv interface~solver__get_subfield solver__get_subfield interface~solver__get_subfield->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->proc~solver__advance proc~slicedata__write slicedata__write program~main_m->proc~slicedata__write proc~slicedata__write->interface~solver__get_subfield Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code subfield_vel_tm_divv Source Code subroutine subfield_vel_tm_divv ( fluid , vel , tm , divv ) !! fluidの基本変数から二次的な場（速度ベクトル場velと !! 温度場tmと速度の発散divv）をもとめる。 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体基本場 type ( field__vector3d_t ), intent ( out ) :: vel !! 流れ場 real ( DR ), dimension ( NX , NY , NZ ), intent ( out ) :: tm !! 温度場 real ( DR ), dimension ( NX , NY , NZ ), intent ( out ) :: divv !! 流れの発散 ![   vel = fluid%flux     / fluid%density ! operator defined in field.f90. vel = operator_vector_divby_scalar ( fluid % flux , fluid % density ) tm = fluid % pressure / fluid % density ![  divv = .div.vel divv = operator_div ( vel ) ! Fortranコンパイラが自己定義演算子（field.f90で定義） ! を許せば上の簡潔な記述を使うべし。 call debug__print ( \"called solver/subfield_vel_tm_divv.\" ) end subroutine subfield_vel_tm_divv","tags":"","loc":"proc/subfield_vel_tm_divv.html"},{"title":"solver__get_subfield – Smoke Ring","text":"public interface solver__get_subfield 流体の基本変数（質量フラックス、質量密度、圧力）\n から二次的な量（流れ場、温度場、速度の発散）\n を計算するためのルーチン群の多重定義 Calls interface~~solver__get_subfield~~CallsGraph interface~solver__get_subfield solver__get_subfield proc~subfield_vel subfield_vel interface~solver__get_subfield->proc~subfield_vel proc~subfield_vel_tm_divv subfield_vel_tm_divv interface~solver__get_subfield->proc~subfield_vel_tm_divv proc~subfield_vel_tm subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel_tm interface~debug__print debug__print proc~subfield_vel->interface~debug__print proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel->proc~operator_vector_divby_scalar proc~subfield_vel_tm_divv->interface~debug__print proc~subfield_vel_tm_divv->proc~operator_vector_divby_scalar proc~operator_div operator_div proc~subfield_vel_tm_divv->proc~operator_div proc~subfield_vel_tm->interface~debug__print proc~subfield_vel_tm->proc~operator_vector_divby_scalar proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~boundary_condition_scalar boundary_condition_scalar proc~operator_div->proc~boundary_condition_scalar proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message var paninterfacesolver__get_subfieldCallsGraph = svgPanZoom('#interfacesolver__get_subfieldCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~solver__get_subfield~~CalledByGraph interface~solver__get_subfield solver__get_subfield proc~slicedata__write slicedata__write proc~slicedata__write->interface~solver__get_subfield program~main_m main_m program~main_m->proc~slicedata__write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures subfield_vel subfield_vel_tm subfield_vel_tm_divv Module Procedures private subroutine subfield_vel (fluid, vel) fluidの基本変数から二次的な場vel（流れの速度ベクトル場）\n をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れの速度ベクトル private subroutine subfield_vel_tm (fluid, vel, tm) fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm）\n をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: tm 温度場 private subroutine subfield_vel_tm_divv (fluid, vel, tm, divv) fluidの基本変数から二次的な場（速度ベクトル場velと\n 温度場tmと速度の発散divv）をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: tm 温度場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: divv 流れの発散","tags":"","loc":"interface/solver__get_subfield.html"},{"title":"operator_cross_product – Smoke Ring","text":"public function operator_cross_product(a, b) ベクトル場の外積 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a 掛けるベクトル場 type( field__vector3d_t ), intent(in) :: b 掛けるベクトル場 Return Value type( field__vector3d_t ) 外積 Contents Source Code operator_cross_product Source Code function operator_cross_product ( a , b ) !! ベクトル場の外積 type ( field__vector3d_t ), intent ( in ) :: a , b !! 掛けるベクトル場 type ( field__vector3d_t ) :: operator_cross_product !! 外積 operator_cross_product % x = ( a % y ) * ( b % z ) - ( a % z ) * ( b % y ) operator_cross_product % y = ( a % z ) * ( b % x ) - ( a % x ) * ( b % z ) operator_cross_product % z = ( a % x ) * ( b % y ) - ( a % y ) * ( b % x ) end function operator_cross_product","tags":"","loc":"proc/operator_cross_product.html"},{"title":"operator_curl – Smoke Ring","text":"public function operator_curl(a) ベクトル場のcurl Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a これのcurlをとる Return Value type( field__vector3d_t ) curlした結果 Calls proc~~operator_curl~~CallsGraph proc~operator_curl operator_curl proc~boundary_condition_vector boundary_condition_vector proc~operator_curl->proc~boundary_condition_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~operator_curl~~CalledByGraph proc~operator_curl operator_curl proc~make_single_precision_field make_single_precision_field proc~make_single_precision_field->proc~operator_curl proc~slicedata__write slicedata__write proc~slicedata__write->proc~make_single_precision_field program~main_m main_m program~main_m->proc~slicedata__write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_curl Source Code function operator_curl ( a ) !! ベクトル場のcurl type ( field__vector3d_t ), intent ( in ) :: a !! これのcurlをとる type ( field__vector3d_t ) :: operator_curl !! curlした結果 integer ( SI ) :: i , j , k real ( DR ) :: dx1 , dy1 , dz1 dx1 = grid % d1 % x ! x方向の偏微分演算用定数 dy1 = grid % d1 % y ! y方向の偏微分演算用定数 dz1 = grid % d1 % z ! z方向の偏微分演算用定数 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法によりcurlを計算する do j = 2 , NY - 1 do i = 2 , NX - 1 operator_curl % x ( i , j , k ) = dy1 * ( a % z ( i , j + 1 , k ) - a % z ( i , j - 1 , k )) & - dz1 * ( a % y ( i , j , k + 1 ) - a % y ( i , j , k - 1 )) operator_curl % y ( i , j , k ) = dz1 * ( a % x ( i , j , k + 1 ) - a % x ( i , j , k - 1 )) & - dx1 * ( a % z ( i + 1 , j , k ) - a % z ( i - 1 , j , k )) operator_curl % z ( i , j , k ) = dx1 * ( a % y ( i + 1 , j , k ) - a % y ( i - 1 , j , k )) & - dy1 * ( a % x ( i , j + 1 , k ) - a % x ( i , j - 1 , k )) end do end do end do call boundary_condition_vector ( operator_curl ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_curl","tags":"","loc":"proc/operator_curl.html"},{"title":"operator_div – Smoke Ring","text":"public function operator_div(a) ベクトル場のdivergence Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a これのdivをとる Return Value real(kind=DR),\n  dimension(NX,NY,NZ) 結果 Calls proc~~operator_div~~CallsGraph proc~operator_div operator_div proc~boundary_condition_scalar boundary_condition_scalar proc~operator_div->proc~boundary_condition_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~operator_div~~CalledByGraph proc~operator_div operator_div proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->proc~operator_div proc~solver__advance solver__advance proc~solver__advance->proc~subfield_vel_tm_divv interface~solver__get_subfield solver__get_subfield interface~solver__get_subfield->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->proc~solver__advance proc~slicedata__write slicedata__write program~main_m->proc~slicedata__write proc~slicedata__write->interface~solver__get_subfield Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_div Source Code function operator_div ( a ) !! ベクトル場のdivergence type ( field__vector3d_t ), intent ( in ) :: a !! これのdivをとる real ( DR ), dimension ( NX , NY , NZ ) :: operator_div !! 結果 integer ( SI ) :: i , j , k real ( DR ) :: dx1 , dy1 , dz1 dx1 = grid % d1 % x ! x方向の偏微分演算用定数 dy1 = grid % d1 % y ! y方向の偏微分演算用定数 dz1 = grid % d1 % z ! z方向の偏微分演算用定数 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法によりdivergenceを計算する do j = 2 , NY - 1 do i = 2 , NX - 1 operator_div ( i , j , k ) = dx1 * ( a % x ( i + 1 , j , k ) - a % x ( i - 1 , j , k )) & + dy1 * ( a % y ( i , j + 1 , k ) - a % y ( i , j - 1 , k )) & + dz1 * ( a % z ( i , j , k + 1 ) - a % z ( i , j , k - 1 )) end do end do end do call boundary_condition_scalar ( operator_div ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_div","tags":"","loc":"proc/operator_div.html"},{"title":"operator_dot_product – Smoke Ring","text":"public function operator_dot_product(a, b) ベクトル場の内積 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a 内積をとるベクトル場 type( field__vector3d_t ), intent(in) :: b 内積をとるベクトル場 Return Value real(kind=DR),\n  dimension(NX,NY,NZ) 計算結果 Called by proc~~operator_dot_product~~CalledByGraph proc~operator_dot_product operator_dot_product proc~make_single_precision_field make_single_precision_field proc~make_single_precision_field->proc~operator_dot_product proc~operator_energyintegral operator_energyintegral proc~operator_energyintegral->proc~operator_dot_product proc~slicedata__write slicedata__write proc~slicedata__write->proc~make_single_precision_field proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->proc~operator_energyintegral program~main_m main_m program~main_m->proc~slicedata__write program~main_m->proc~solver__diagnosis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_dot_product Source Code function operator_dot_product ( a , b ) !! ベクトル場の内積 type ( field__vector3d_t ), intent ( in ) :: a , b !! 内積をとるベクトル場 real ( DR ), dimension ( NX , NY , NZ ) :: operator_dot_product !! 計算結果 operator_dot_product = a % x * b % x + a % y * b % y + a % z * b % z ! 配列演算 ! ! 実際にはここで3重do_loopが回っている ! OpenMP化するときにはこの簡潔な ! 書き方をやめて3重do_loopに書き直す必要がある。 end function operator_dot_product","tags":"","loc":"proc/operator_dot_product.html"},{"title":"operator_energyintegral – Smoke Ring","text":"public function operator_energyintegral(a) 流体の運動エネルギーの体積積分 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: a 流体場 Return Value real(kind=DR) 全エネルギー Calls proc~~operator_energyintegral~~CallsGraph proc~operator_energyintegral operator_energyintegral proc~operator_dot_product operator_dot_product proc~operator_energyintegral->proc~operator_dot_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~operator_energyintegral~~CalledByGraph proc~operator_energyintegral operator_energyintegral proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->proc~operator_energyintegral program~main_m main_m program~main_m->proc~solver__diagnosis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_energyintegral Source Code function operator_energyintegral ( a ) !! 流体の運動エネルギーの体積積分 type ( field__fluid_t ), intent ( in ) :: a !! 流体場 real ( DR ) :: operator_energyintegral !! 全エネルギー ! 以下のエネルギー密度の式を全空間で体積積分する ! flow_energy = (1/2) * rho * vel&#94;2 = (1/2) * (massflux)&#94;2 / rho real ( DR ) :: dvol real ( DR ), dimension ( NX , NY , NZ ) :: flux_sq ! sq は2乗(squared)を意味する dvol = ( grid % delta % x ) * ( grid % delta % y ) * ( grid % delta % z ) ! 現在のシュミレーションでは格子間隔はx, y, z それぞれに ! 一様であることを仮定している。つまりdx, dy, dzは空間位置に ! 依存せず一定である。 !   flux_sq = (a%flux).dot.(a%flux) flux_sq = operator_dot_product ( a % flux , a % flux ) ! 質量フラックスの2乗を一時的な配列にセットする ! ユーザ定義演算子が使えるコンパイラならば.dot.を ! 使った表記のほうが読みやすいであろう。 operator_energyintegral & = 0.5_DR * sum ( flux_sq ( 2 : NX - 1 , 2 : NY - 1 , 2 : NZ - 1 ) & / a % density ( 2 : NX - 1 , 2 : NY - 1 , 2 : NZ - 1 ) & ) * dvol ! ここで配列演算の添字が1からNXではなく2からNX-1などに ! 限定されていることに注意。これは体積積分の範囲を計算領域の ! 内部に限定していること、つまり境界上の格子点を除いて ! 積分していることを意味する。境界上の格子点まで ! 入れると重複してカウントしてしまうからである end function operator_energyintegral","tags":"","loc":"proc/operator_energyintegral.html"},{"title":"operator_fluid_add – Smoke Ring","text":"public function operator_fluid_add(a, b) 流体構造体の足し算演算子 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: a 足し算する2つの流体場 type( field__fluid_t ), intent(in) :: b 足し算する2つの流体場 Return Value type( field__fluid_t ) 計算結果 Called by proc~~operator_fluid_add~~CalledByGraph proc~operator_fluid_add operator_fluid_add proc~solver__advance solver__advance proc~solver__advance->proc~operator_fluid_add program~main_m main_m program~main_m->proc~solver__advance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_fluid_add Source Code function operator_fluid_add ( a , b ) !! 流体構造体の足し算演算子 type ( field__fluid_t ), intent ( in ) :: a , b !! 足し算する2つの流体場 type ( field__fluid_t ) :: operator_fluid_add !! 計算結果 operator_fluid_add % flux % x = a % flux % x + b % flux % x operator_fluid_add % flux % y = a % flux % y + b % flux % y operator_fluid_add % flux % z = a % flux % z + b % flux % z operator_fluid_add % density = a % density + b % density operator_fluid_add % pressure = a % pressure + b % pressure end function operator_fluid_add","tags":"","loc":"proc/operator_fluid_add.html"},{"title":"operator_fluid_times_integer – Smoke Ring","text":"public function operator_fluid_times_integer(fluid, integer) 流体構造体を整数倍するための演算子 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体場 integer(kind=SI), intent(in) :: integer かける整数 Return Value type( field__fluid_t ) Contents Source Code operator_fluid_times_integer Source Code function operator_fluid_times_integer ( fluid , integer ) !! 流体構造体を整数倍するための演算子 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体場 integer ( SI ), intent ( in ) :: integer !! かける整数 type ( field__fluid_t ) :: operator_fluid_times_integer operator_fluid_times_integer % pressure = integer * ( fluid % pressure ) operator_fluid_times_integer % density = integer * ( fluid % density ) operator_fluid_times_integer % flux % x = integer * ( fluid % flux % x ) operator_fluid_times_integer % flux % y = integer * ( fluid % flux % y ) operator_fluid_times_integer % flux % z = integer * ( fluid % flux % z ) end function operator_fluid_times_integer","tags":"","loc":"proc/operator_fluid_times_integer.html"},{"title":"operator_fluid_times_real – Smoke Ring","text":"public function operator_fluid_times_real(fluid, real) 流体構造体を実数倍するための演算子 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体場 real(kind=DR), intent(in) :: real かける実数 Return Value type( field__fluid_t ) 計算結果 Called by proc~~operator_fluid_times_real~~CalledByGraph proc~operator_fluid_times_real operator_fluid_times_real proc~solver__advance solver__advance proc~solver__advance->proc~operator_fluid_times_real program~main_m main_m program~main_m->proc~solver__advance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_fluid_times_real Source Code function operator_fluid_times_real ( fluid , real ) !! 流体構造体を実数倍するための演算子 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体場 real ( DR ), intent ( in ) :: real !! かける実数 type ( field__fluid_t ) :: operator_fluid_times_real !! 計算結果 operator_fluid_times_real % pressure = real * ( fluid % pressure ) operator_fluid_times_real % density = real * ( fluid % density ) operator_fluid_times_real % flux % x = real * ( fluid % flux % x ) operator_fluid_times_real % flux % y = real * ( fluid % flux % y ) operator_fluid_times_real % flux % z = real * ( fluid % flux % z ) end function operator_fluid_times_real","tags":"","loc":"proc/operator_fluid_times_real.html"},{"title":"operator_integer_times_fluid – Smoke Ring","text":"public function operator_integer_times_fluid(integer, fluid) 整数に流体構造体を掛け算するための演算子 Arguments Type Intent Optional Attributes Name integer(kind=SI), intent(in) :: integer かける整数 type( field__fluid_t ), intent(in) :: fluid 流体場 Return Value type( field__fluid_t ) 計算結果 Contents Source Code operator_integer_times_fluid Source Code function operator_integer_times_fluid ( integer , fluid ) !! 整数に流体構造体を掛け算するための演算子 integer ( SI ), intent ( in ) :: integer !! かける整数 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体場 type ( field__fluid_t ) :: operator_integer_times_fluid !! 計算結果 operator_integer_times_fluid % pressure = integer * ( fluid % pressure ) operator_integer_times_fluid % density = integer * ( fluid % density ) operator_integer_times_fluid % flux % x = integer * ( fluid % flux % x ) operator_integer_times_fluid % flux % y = integer * ( fluid % flux % y ) operator_integer_times_fluid % flux % z = integer * ( fluid % flux % z ) end function operator_integer_times_fluid","tags":"","loc":"proc/operator_integer_times_fluid.html"},{"title":"operator_laplacian_scalar – Smoke Ring","text":"public function operator_laplacian_scalar(a) スカラー場のラプラシアン Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(NX,NY,NZ) :: a 入力スカラー場 Return Value real(kind=DR),\n  dimension(NX,NY,NZ) 計算結果 Calls proc~~operator_laplacian_scalar~~CallsGraph proc~operator_laplacian_scalar operator_laplacian_scalar proc~boundary_condition_scalar boundary_condition_scalar proc~operator_laplacian_scalar->proc~boundary_condition_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_laplacian_scalar Source Code function operator_laplacian_scalar ( a ) !! スカラー場のラプラシアン real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: a !! 入力スカラー場 real ( DR ), dimension ( NX , NY , NZ ) :: operator_laplacian_scalar !! 計算結果 integer ( SI ) :: i , j , k real ( DR ) :: dx2 , dy2 , dz2 dx2 = grid % d2 % x ! x方向の2階偏微分演算用定数 dy2 = grid % d2 % y ! y方向の2階偏微分演算用定数 dz2 = grid % d2 % z ! z方向の2階偏微分演算用定数 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法により計算する do j = 2 , NY - 1 do i = 2 , NX - 1 operator_laplacian_scalar ( i , j , k ) & = dx2 * ( a ( i + 1 , j , k ) - 2 * a ( i , j , k ) + a ( i - 1 , j , k )) & + dy2 * ( a ( i , j + 1 , k ) - 2 * a ( i , j , k ) + a ( i , j - 1 , k )) & + dz2 * ( a ( i , j , k + 1 ) - 2 * a ( i , j , k ) + a ( i , j , k - 1 )) end do end do end do call boundary_condition_scalar ( operator_laplacian_scalar ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_laplacian_scalar","tags":"","loc":"proc/operator_laplacian_scalar.html"},{"title":"operator_laplacian_vector – Smoke Ring","text":"public function operator_laplacian_vector(a) ベクトル場のラプラシアン Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a 入力ベクトル場 Return Value type( field__vector3d_t ) 計算結果 Calls proc~~operator_laplacian_vector~~CallsGraph proc~operator_laplacian_vector operator_laplacian_vector proc~boundary_condition_vector boundary_condition_vector proc~operator_laplacian_vector->proc~boundary_condition_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_laplacian_vector Source Code function operator_laplacian_vector ( a ) !! ベクトル場のラプラシアン type ( field__vector3d_t ), intent ( in ) :: a !! 入力ベクトル場 type ( field__vector3d_t ) :: operator_laplacian_vector !! 計算結果 integer ( SI ) :: i , j , k real ( DR ) :: dx2 , dy2 , dz2 dx2 = grid % d2 % x ! x方向の2階偏微分演算用定数 dy2 = grid % d2 % y ! y方向の2階偏微分演算用定数 dz2 = grid % d2 % z ! z方向の2階偏微分演算用定数 do k = 2 , NZ - 1 ! 境界上の格子点を飛ばして、シミュレーション領域内部 ! の格子点上で差分法により計算する do j = 2 , NY - 1 do i = 2 , NX - 1 operator_laplacian_vector % x ( i , j , k ) & = dx2 * ( a % x ( i + 1 , j , k ) - 2 * a % x ( i , j , k ) + a % x ( i - 1 , j , k )) & + dy2 * ( a % x ( i , j + 1 , k ) - 2 * a % x ( i , j , k ) + a % x ( i , j - 1 , k )) & + dz2 * ( a % x ( i , j , k + 1 ) - 2 * a % x ( i , j , k ) + a % x ( i , j , k - 1 )) operator_laplacian_vector % y ( i , j , k ) & = dx2 * ( a % y ( i + 1 , j , k ) - 2 * a % y ( i , j , k ) + a % y ( i - 1 , j , k )) & + dy2 * ( a % y ( i , j + 1 , k ) - 2 * a % y ( i , j , k ) + a % y ( i , j - 1 , k )) & + dz2 * ( a % y ( i , j , k + 1 ) - 2 * a % y ( i , j , k ) + a % y ( i , j , k - 1 )) operator_laplacian_vector % z ( i , j , k ) & = dx2 * ( a % z ( i + 1 , j , k ) - 2 * a % z ( i , j , k ) + a % z ( i - 1 , j , k )) & + dy2 * ( a % z ( i , j + 1 , k ) - 2 * a % z ( i , j , k ) + a % z ( i , j - 1 , k )) & + dz2 * ( a % z ( i , j , k + 1 ) - 2 * a % z ( i , j , k ) + a % z ( i , j , k - 1 )) end do end do end do call boundary_condition_vector ( operator_laplacian_vector ) ! 境界の格子点は境界条件ルーチンで設定する end function operator_laplacian_vector","tags":"","loc":"proc/operator_laplacian_vector.html"},{"title":"operator_real_times_fluid – Smoke Ring","text":"public function operator_real_times_fluid(real, fluid) 実数に流体場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( field__fluid_t ), intent(in) :: fluid 流体場 Return Value type( field__fluid_t ) 計算結果 Contents Source Code operator_real_times_fluid Source Code function operator_real_times_fluid ( real , fluid ) !! 実数に流体場を掛ける演算子 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__fluid_t ), intent ( in ) :: fluid !! 流体場 type ( field__fluid_t ) :: operator_real_times_fluid !! 計算結果 operator_real_times_fluid % pressure = real * ( fluid % pressure ) operator_real_times_fluid % density = real * ( fluid % density ) operator_real_times_fluid % flux % x = real * ( fluid % flux % x ) operator_real_times_fluid % flux % y = real * ( fluid % flux % y ) operator_real_times_fluid % flux % z = real * ( fluid % flux % z ) end function operator_real_times_fluid","tags":"","loc":"proc/operator_real_times_fluid.html"},{"title":"operator_real_times_vector – Smoke Ring","text":"public function operator_real_times_vector(real, vec) 実数にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( field__vector3d_t ), intent(in) :: vec 流体場 Return Value type( field__vector3d_t ) 計算結果 Contents Source Code operator_real_times_vector Source Code function operator_real_times_vector ( real , vec ) !! 実数にベクトル場を掛ける演算子 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__vector3d_t ), intent ( in ) :: vec !! 流体場 type ( field__vector3d_t ) :: operator_real_times_vector !! 計算結果 operator_real_times_vector % x = real * ( vec % x ) operator_real_times_vector % y = real * ( vec % y ) operator_real_times_vector % z = real * ( vec % z ) end function operator_real_times_vector","tags":"","loc":"proc/operator_real_times_vector.html"},{"title":"operator_scalar_times_vector – Smoke Ring","text":"public function operator_scalar_times_vector(scalar, vec) スカラー場にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(NX,NY,NZ) :: scalar スカラー場 type( field__vector3d_t ), intent(in) :: vec ベクトル場 Return Value type( field__vector3d_t ) 計算結果 Contents Source Code operator_scalar_times_vector Source Code function operator_scalar_times_vector ( scalar , vec ) !! スカラー場にベクトル場を掛ける演算子 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: scalar !! スカラー場 type ( field__vector3d_t ), intent ( in ) :: vec !! ベクトル場 type ( field__vector3d_t ) :: operator_scalar_times_vector !! 計算結果 operator_scalar_times_vector % x = scalar * ( vec % x ) operator_scalar_times_vector % y = scalar * ( vec % y ) operator_scalar_times_vector % z = scalar * ( vec % z ) end function operator_scalar_times_vector","tags":"","loc":"proc/operator_scalar_times_vector.html"},{"title":"operator_scalarintegral – Smoke Ring","text":"public function operator_scalarintegral(a) スカラー場の体積積分演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(NX,NY,NZ) :: a スカラー場 Return Value real(kind=DR) 体積積分結果 Called by proc~~operator_scalarintegral~~CalledByGraph proc~operator_scalarintegral operator_scalarintegral proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->proc~operator_scalarintegral program~main_m main_m program~main_m->proc~solver__diagnosis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_scalarintegral Source Code function operator_scalarintegral ( a ) !! スカラー場の体積積分演算子 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: a !! スカラー場 real ( DR ) :: operator_scalarintegral !! 体積積分結果 real ( DR ) :: dvol dvol = ( grid % delta % x ) * ( grid % delta % y ) * ( grid % delta % z ) ! 現在のシュミレーションでは格子間隔はx, y, z それぞれに ! 一様であることを仮定している。つまりdx, dy, dzは空間位置に ! 依存せず一定である。 operator_scalarintegral = sum ( a ( 2 : NX - 1 , 2 : NY - 1 , 2 : NZ - 1 ) ) * dvol ! ここで配列演算の添字が1からNXではなく2からNX-1などに ! 限定されていることに注意。これは体積積分の範囲を計算領域の ! 内部に限定していること、つまり境界上の格子点を除いて ! 積分していることを意味する。境界上の格子点まで ! 入れると重複してカウントしてしまうからである end function operator_scalarintegral","tags":"","loc":"proc/operator_scalarintegral.html"},{"title":"operator_vector_add – Smoke Ring","text":"public function operator_vector_add(a, b) ベクトル場の和の演算子 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a 和をとるベクトル場 type( field__vector3d_t ), intent(in) :: b 和をとるベクトル場 Return Value type( field__vector3d_t ) 計算結果 Contents Source Code operator_vector_add Source Code function operator_vector_add ( a , b ) !! ベクトル場の和の演算子 type ( field__vector3d_t ), intent ( in ) :: a , b !! 和をとるベクトル場 type ( field__vector3d_t ) :: operator_vector_add !! 計算結果 operator_vector_add % x = a % x + b % x operator_vector_add % y = a % y + b % y operator_vector_add % z = a % z + b % z end function operator_vector_add","tags":"","loc":"proc/operator_vector_add.html"},{"title":"operator_vector_divby_scalar – Smoke Ring","text":"public function operator_vector_divby_scalar(vec, scalar) ベクトル場の各成分をスカラー場で割る Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: scalar スカラー場 Return Value type( field__vector3d_t ) 計算結果 Called by proc~~operator_vector_divby_scalar~~CalledByGraph proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel subfield_vel proc~subfield_vel->proc~operator_vector_divby_scalar proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->proc~operator_vector_divby_scalar proc~subfield_vel_tm subfield_vel_tm proc~subfield_vel_tm->proc~operator_vector_divby_scalar proc~solver__advance solver__advance proc~solver__advance->proc~subfield_vel_tm_divv interface~solver__get_subfield solver__get_subfield interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv interface~solver__get_subfield->proc~subfield_vel_tm proc~solver__set_time_step solver__set_time_step proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis solver__diagnosis proc~solver__diagnosis->proc~subfield_vel program~main_m main_m program~main_m->proc~solver__advance program~main_m->proc~solver__set_time_step program~main_m->proc~solver__diagnosis proc~slicedata__write slicedata__write program~main_m->proc~slicedata__write proc~slicedata__write->interface~solver__get_subfield var panprocoperator_vector_divby_scalarCalledByGraph = svgPanZoom('#procoperator_vector_divby_scalarCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code operator_vector_divby_scalar Source Code function operator_vector_divby_scalar ( vec , scalar ) !! ベクトル場の各成分をスカラー場で割る type ( field__vector3d_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: scalar !! スカラー場 type ( field__vector3d_t ) :: operator_vector_divby_scalar !! 計算結果 operator_vector_divby_scalar % x = ( vec % x ) / scalar operator_vector_divby_scalar % y = ( vec % y ) / scalar operator_vector_divby_scalar % z = ( vec % z ) / scalar end function operator_vector_divby_scalar","tags":"","loc":"proc/operator_vector_divby_scalar.html"},{"title":"operator_vector_times_real – Smoke Ring","text":"public function operator_vector_times_real(vec, real) ベクトル場の実数倍の演算子 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in) :: real 掛ける実数 Return Value type( field__vector3d_t ) 計算結果 Contents Source Code operator_vector_times_real Source Code function operator_vector_times_real ( vec , real ) !! ベクトル場の実数倍の演算子 type ( field__vector3d_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), intent ( in ) :: real !! 掛ける実数 type ( field__vector3d_t ) :: operator_vector_times_real !! 計算結果 operator_vector_times_real % x = real * ( vec % x ) operator_vector_times_real % y = real * ( vec % y ) operator_vector_times_real % z = real * ( vec % z ) end function operator_vector_times_real","tags":"","loc":"proc/operator_vector_times_real.html"},{"title":"operator_vector_times_scalar – Smoke Ring","text":"public function operator_vector_times_scalar(vec, scalar) ベクトル場にスカラー場を掛ける Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: scalar スカラー場 Return Value type( field__vector3d_t ) 計算結果 Contents Source Code operator_vector_times_scalar Source Code function operator_vector_times_scalar ( vec , scalar ) !! ベクトル場にスカラー場を掛ける type ( field__vector3d_t ), intent ( in ) :: vec !! ベクトル場 real ( DR ), dimension ( NX , NY , NZ ), intent ( in ) :: scalar !! スカラー場 type ( field__vector3d_t ) :: operator_vector_times_scalar !! 計算結果 operator_vector_times_scalar % x = scalar * ( vec % x ) operator_vector_times_scalar % y = scalar * ( vec % y ) operator_vector_times_scalar % z = scalar * ( vec % z ) end function operator_vector_times_scalar","tags":"","loc":"proc/operator_vector_times_scalar.html"},{"title":"assignment_real_to_fluid – Smoke Ring","text":"private subroutine assignment_real_to_fluid(fluid, real) 流体構造体に実数を代入。\n 初期条件ですべての要素を0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(out) :: fluid 流体場 real(kind=DR), intent(in) :: real 代入する実数 Contents Source Code assignment_real_to_fluid Source Code subroutine assignment_real_to_fluid ( fluid , real ) !! 流体構造体に実数を代入。 !! 初期条件ですべての要素を0にセットするときに使う。 type ( field__fluid_t ), intent ( out ) :: fluid !! 流体場 real ( DR ), intent ( in ) :: real !! 代入する実数 fluid % pressure (:,:,:) = real fluid % density (:,:,:) = real fluid % flux % x (:,:,:) = real fluid % flux % y (:,:,:) = real fluid % flux % z (:,:,:) = real end subroutine assignment_real_to_fluid","tags":"","loc":"proc/assignment_real_to_fluid.html"},{"title":"assignment_real_to_vector – Smoke Ring","text":"private subroutine assignment_real_to_vector(vector, real) ベクトル場に実数を代入。\n 初期条件で0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(out) :: vector ベクトル場 real(kind=DR), intent(in) :: real 代入する実数 Contents Source Code assignment_real_to_vector Source Code subroutine assignment_real_to_vector ( vector , real ) !! ベクトル場に実数を代入。 !! 初期条件で0にセットするときに使う。 type ( field__vector3d_t ), intent ( out ) :: vector !! ベクトル場 real ( DR ), intent ( in ) :: real !! 代入する実数 vector % x (:,:,:) = real vector % y (:,:,:) = real vector % z (:,:,:) = real end subroutine assignment_real_to_vector","tags":"","loc":"proc/assignment_real_to_vector.html"},{"title":"boundary_condition_fluid – Smoke Ring","text":"private subroutine boundary_condition_fluid(fluid) 流体構造体の境界条件設定 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(inout) :: fluid 流体場 Calls proc~~boundary_condition_fluid~~CallsGraph proc~boundary_condition_fluid boundary_condition_fluid proc~boundary_condition_scalar boundary_condition_scalar proc~boundary_condition_fluid->proc~boundary_condition_scalar proc~boundary_condition_vector boundary_condition_vector proc~boundary_condition_fluid->proc~boundary_condition_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~boundary_condition_fluid~~CalledByGraph proc~boundary_condition_fluid boundary_condition_fluid interface~field__boundary_condition field__boundary_condition interface~field__boundary_condition->proc~boundary_condition_fluid proc~the_equation the_equation proc~the_equation->interface~field__boundary_condition proc~set_drive_force_field set_drive_force_field proc~set_drive_force_field->interface~field__boundary_condition proc~solver__advance solver__advance proc~solver__advance->proc~the_equation proc~solver__initialize solver__initialize proc~solver__initialize->proc~set_drive_force_field program~main_m main_m program~main_m->proc~solver__advance program~main_m->proc~solver__initialize var panprocboundary_condition_fluidCalledByGraph = svgPanZoom('#procboundary_condition_fluidCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code boundary_condition_fluid Source Code subroutine boundary_condition_fluid ( fluid ) !! 流体構造体の境界条件設定 type ( field__fluid_t ), intent ( inout ) :: fluid !! 流体場 call boundary_condition_scalar ( fluid % pressure ) call boundary_condition_scalar ( fluid % density ) call boundary_condition_vector ( fluid % flux ) end subroutine boundary_condition_fluid","tags":"","loc":"proc/boundary_condition_fluid.html"},{"title":"boundary_condition_scalar – Smoke Ring","text":"private subroutine boundary_condition_scalar(scalar) スカラー場の境界条件設定 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout), dimension(NX,NY,NZ) :: scalar スカラー場 Called by proc~~boundary_condition_scalar~~CalledByGraph proc~boundary_condition_scalar boundary_condition_scalar proc~operator_div operator_div proc~operator_div->proc~boundary_condition_scalar interface~field__boundary_condition field__boundary_condition interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_fluid boundary_condition_fluid interface~field__boundary_condition->proc~boundary_condition_fluid proc~operator_laplacian_scalar operator_laplacian_scalar proc~operator_laplacian_scalar->proc~boundary_condition_scalar proc~boundary_condition_fluid->proc~boundary_condition_scalar proc~the_equation the_equation proc~the_equation->interface~field__boundary_condition proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->proc~operator_div proc~set_drive_force_field set_drive_force_field proc~set_drive_force_field->interface~field__boundary_condition proc~solver__advance solver__advance proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv proc~solver__initialize solver__initialize proc~solver__initialize->proc~set_drive_force_field interface~solver__get_subfield solver__get_subfield interface~solver__get_subfield->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->proc~solver__advance program~main_m->proc~solver__initialize proc~slicedata__write slicedata__write program~main_m->proc~slicedata__write proc~slicedata__write->interface~solver__get_subfield var panprocboundary_condition_scalarCalledByGraph = svgPanZoom('#procboundary_condition_scalarCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code boundary_condition_scalar Source Code subroutine boundary_condition_scalar ( scalar ) !! スカラー場の境界条件設定 real ( DR ), dimension ( NX , NY , NZ ), intent ( inout ) :: scalar !! スカラー場 scalar ( 1 ,:,:) = scalar ( NX - 1 ,:,:) scalar ( NX ,:,:) = scalar ( 2 ,:,:) scalar (:, 1 ,:) = scalar (:, NY - 1 ,:) scalar (:, NY ,:) = scalar (:, 2 ,:) scalar (:,:, 1 ) = scalar (:,:, NZ - 1 ) scalar (:,:, NZ ) = scalar (:,:, 2 ) end subroutine boundary_condition_scalar","tags":"","loc":"proc/boundary_condition_scalar.html"},{"title":"boundary_condition_vector – Smoke Ring","text":"private subroutine boundary_condition_vector(vec) ベクトル場の境界条件設定 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(inout) :: vec ベクトル場 Called by proc~~boundary_condition_vector~~CalledByGraph proc~boundary_condition_vector boundary_condition_vector proc~operator_curl operator_curl proc~operator_curl->proc~boundary_condition_vector proc~operator_laplacian_vector operator_laplacian_vector proc~operator_laplacian_vector->proc~boundary_condition_vector interface~field__boundary_condition field__boundary_condition interface~field__boundary_condition->proc~boundary_condition_vector proc~boundary_condition_fluid boundary_condition_fluid interface~field__boundary_condition->proc~boundary_condition_fluid proc~boundary_condition_fluid->proc~boundary_condition_vector proc~the_equation the_equation proc~the_equation->interface~field__boundary_condition proc~make_single_precision_field make_single_precision_field proc~make_single_precision_field->proc~operator_curl proc~set_drive_force_field set_drive_force_field proc~set_drive_force_field->interface~field__boundary_condition proc~solver__advance solver__advance proc~solver__advance->proc~the_equation proc~solver__initialize solver__initialize proc~solver__initialize->proc~set_drive_force_field proc~slicedata__write slicedata__write proc~slicedata__write->proc~make_single_precision_field program~main_m main_m program~main_m->proc~solver__advance program~main_m->proc~solver__initialize program~main_m->proc~slicedata__write var panprocboundary_condition_vectorCalledByGraph = svgPanZoom('#procboundary_condition_vectorCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code boundary_condition_vector Source Code subroutine boundary_condition_vector ( vec ) !! ベクトル場の境界条件設定 type ( field__vector3d_t ), intent ( inout ) :: vec !! ベクトル場 vec % x ( 1 ,:,:) = vec % x ( NX - 1 ,:,:) !-- yz-plane --! vec % y ( 1 ,:,:) = vec % y ( NX - 1 ,:,:) vec % z ( 1 ,:,:) = vec % z ( NX - 1 ,:,:) vec % x ( NX ,:,:) = vec % x ( 2 ,:,:) vec % y ( NX ,:,:) = vec % y ( 2 ,:,:) vec % z ( NX ,:,:) = vec % z ( 2 ,:,:) vec % x (:, 1 ,:) = vec % x (:, NY - 1 ,:) !-- zx-plane --! vec % y (:, 1 ,:) = vec % y (:, NY - 1 ,:) vec % z (:, 1 ,:) = vec % z (:, NY - 1 ,:) vec % x (:, NY ,:) = vec % x (:, 2 ,:) vec % y (:, NY ,:) = vec % y (:, 2 ,:) vec % z (:, NY ,:) = vec % z (:, 2 ,:) vec % x (:,:, 1 ) = vec % x (:,:, NZ - 1 ) !-- xy-plane --! vec % y (:,:, 1 ) = vec % y (:,:, NZ - 1 ) vec % z (:,:, 1 ) = vec % z (:,:, NZ - 1 ) vec % x (:,:, NZ ) = vec % x (:,:, 2 ) vec % y (:,:, NZ ) = vec % y (:,:, 2 ) vec % z (:,:, NZ ) = vec % z (:,:, 2 ) end subroutine boundary_condition_vector","tags":"","loc":"proc/boundary_condition_vector.html"},{"title":"field__boundary_condition – Smoke Ring","text":"public interface field__boundary_condition 境界条件呼び出しルーチンの多重定義\n 境界条件を設定する変数の種類によって\n 実際に使用するルーチンが違うが、\n 呼び出し側では統一した名前でcallする。\n コンパイラは引数の型で使用するルーチンを\n 判断する。 Calls interface~~field__boundary_condition~~CallsGraph interface~field__boundary_condition field__boundary_condition proc~boundary_condition_scalar boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar proc~boundary_condition_vector boundary_condition_vector interface~field__boundary_condition->proc~boundary_condition_vector proc~boundary_condition_fluid boundary_condition_fluid interface~field__boundary_condition->proc~boundary_condition_fluid proc~boundary_condition_fluid->proc~boundary_condition_scalar proc~boundary_condition_fluid->proc~boundary_condition_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~field__boundary_condition~~CalledByGraph interface~field__boundary_condition field__boundary_condition proc~the_equation the_equation proc~the_equation->interface~field__boundary_condition proc~set_drive_force_field set_drive_force_field proc~set_drive_force_field->interface~field__boundary_condition proc~solver__advance solver__advance proc~solver__advance->proc~the_equation proc~solver__initialize solver__initialize proc~solver__initialize->proc~set_drive_force_field program~main_m main_m program~main_m->proc~solver__advance program~main_m->proc~solver__initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures boundary_condition_fluid boundary_condition_scalar boundary_condition_vector Module Procedures private subroutine boundary_condition_fluid (fluid) 流体構造体の境界条件設定 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(inout) :: fluid 流体場 private subroutine boundary_condition_scalar (scalar) スカラー場の境界条件設定 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout), dimension(NX,NY,NZ) :: scalar スカラー場 private subroutine boundary_condition_vector (vec) ベクトル場の境界条件設定 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(inout) :: vec ベクトル場","tags":"","loc":"interface/field__boundary_condition.html"},{"title":"print_str – Smoke Ring","text":"private subroutine print_str(string) Debugパラメータがtrueのとき文字列を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 Calls proc~~print_str~~CallsGraph proc~print_str print_str interface~ut__message ut__message proc~print_str->interface~ut__message proc~params__get_logical params__get_logical proc~print_str->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message var panprocprint_strCallsGraph = svgPanZoom('#procprint_strCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_str~~CalledByGraph proc~print_str print_str interface~debug__print debug__print interface~debug__print->proc~print_str proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->interface~debug__print proc~the_equation the_equation proc~the_equation->interface~debug__print proc~subfield_vel_tm subfield_vel_tm proc~subfield_vel_tm->interface~debug__print proc~slicedata__write slicedata__write proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~solver__initialize solver__initialize proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance solver__advance proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->interface~debug__print program~main_m->proc~slicedata__initialize program~main_m->proc~slicedata__write program~main_m->proc~solver__initialize program~main_m->proc~solver__advance proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis proc~solver__set_time_step solver__set_time_step program~main_m->proc~solver__set_time_step proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv proc~solver__set_time_step->proc~subfield_vel_tm var panprocprint_strCalledByGraph = svgPanZoom('#procprint_strCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_str Source Code subroutine print_str ( string ) !! Debugパラメータがtrueのとき文字列を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // string ) end if end subroutine print_str","tags":"","loc":"proc/print_str.html"},{"title":"print_str_dint – Smoke Ring","text":"private subroutine print_str_dint(string, int) Debugパラメータがtrueのとき文字列と整数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=DI), intent(in) :: int 出力整数 Calls proc~~print_str_dint~~CallsGraph proc~print_str_dint print_str_dint proc~params__get_logical params__get_logical proc~print_str_dint->proc~params__get_logical interface~ut__message ut__message proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocprint_str_dintCallsGraph = svgPanZoom('#procprint_str_dintCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_str_dint~~CalledByGraph proc~print_str_dint print_str_dint interface~debug__print debug__print interface~debug__print->proc~print_str_dint proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->interface~debug__print proc~the_equation the_equation proc~the_equation->interface~debug__print proc~subfield_vel_tm subfield_vel_tm proc~subfield_vel_tm->interface~debug__print proc~slicedata__write slicedata__write proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~solver__initialize solver__initialize proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance solver__advance proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->interface~debug__print program~main_m->proc~slicedata__initialize program~main_m->proc~slicedata__write program~main_m->proc~solver__initialize program~main_m->proc~solver__advance proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis proc~solver__set_time_step solver__set_time_step program~main_m->proc~solver__set_time_step proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv proc~solver__set_time_step->proc~subfield_vel_tm var panprocprint_str_dintCalledByGraph = svgPanZoom('#procprint_str_dintCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_str_dint Source Code subroutine print_str_dint ( string , int ) !! Debugパラメータがtrueのとき文字列と整数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 integer ( DI ), intent ( in ) :: int !! 出力整数 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // trim ( string ), int ) end if end subroutine print_str_dint","tags":"","loc":"proc/print_str_dint.html"},{"title":"print_str_dint_double – Smoke Ring","text":"private subroutine print_str_dint_double(string, i1, d1) Debugパラメータがtrueのとき文字列と整数と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=DI), intent(in) :: i1 出力整数 real(kind=DR), intent(in) :: d1 出力実数 Calls proc~~print_str_dint_double~~CallsGraph proc~print_str_dint_double print_str_dint_double proc~params__get_logical params__get_logical proc~print_str_dint_double->proc~params__get_logical interface~ut__message ut__message proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocprint_str_dint_doubleCallsGraph = svgPanZoom('#procprint_str_dint_doubleCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_str_dint_double~~CalledByGraph proc~print_str_dint_double print_str_dint_double interface~debug__print debug__print interface~debug__print->proc~print_str_dint_double proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->interface~debug__print proc~the_equation the_equation proc~the_equation->interface~debug__print proc~subfield_vel_tm subfield_vel_tm proc~subfield_vel_tm->interface~debug__print proc~slicedata__write slicedata__write proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~solver__initialize solver__initialize proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance solver__advance proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->interface~debug__print program~main_m->proc~slicedata__initialize program~main_m->proc~slicedata__write program~main_m->proc~solver__initialize program~main_m->proc~solver__advance proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis proc~solver__set_time_step solver__set_time_step program~main_m->proc~solver__set_time_step proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv proc~solver__set_time_step->proc~subfield_vel_tm var panprocprint_str_dint_doubleCalledByGraph = svgPanZoom('#procprint_str_dint_doubleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_str_dint_double Source Code subroutine print_str_dint_double ( string , i1 , d1 ) !! Debugパラメータがtrueのとき文字列と整数と実数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 integer ( DI ), intent ( in ) :: i1 !! 出力整数 real ( DR ), intent ( in ) :: d1 !! 出力実数 if ( params__get_logical ( 'Debug' )) then call ut__message ( 'debug: ' // trim ( string ), i1 , d1 ) end if end subroutine print_str_dint_double","tags":"","loc":"proc/print_str_dint_double.html"},{"title":"print_str_double – Smoke Ring","text":"private subroutine print_str_double(string, double) Debugパラメータがtrueのとき文字列と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 real(kind=DR), intent(in) :: double 出力実数 Calls proc~~print_str_double~~CallsGraph proc~print_str_double print_str_double interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~params__get_logical params__get_logical proc~print_str_double->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message var panprocprint_str_doubleCallsGraph = svgPanZoom('#procprint_str_doubleCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_str_double~~CalledByGraph proc~print_str_double print_str_double interface~debug__print debug__print interface~debug__print->proc~print_str_double proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->interface~debug__print proc~the_equation the_equation proc~the_equation->interface~debug__print proc~subfield_vel_tm subfield_vel_tm proc~subfield_vel_tm->interface~debug__print proc~slicedata__write slicedata__write proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~solver__initialize solver__initialize proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance solver__advance proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->interface~debug__print program~main_m->proc~slicedata__initialize program~main_m->proc~slicedata__write program~main_m->proc~solver__initialize program~main_m->proc~solver__advance proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis proc~solver__set_time_step solver__set_time_step program~main_m->proc~solver__set_time_step proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv proc~solver__set_time_step->proc~subfield_vel_tm var panprocprint_str_doubleCalledByGraph = svgPanZoom('#procprint_str_doubleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_str_double Source Code subroutine print_str_double ( string , double ) !! Debugパラメータがtrueのとき文字列と実数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 real ( DR ), intent ( in ) :: double !! 出力実数 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // string , double ) end if end subroutine print_str_double","tags":"","loc":"proc/print_str_double.html"},{"title":"print_str_sint – Smoke Ring","text":"private subroutine print_str_sint(string, int) Debugパラメータがtrueのとき文字列と整数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=SI), intent(in) :: int 出力整数 Calls proc~~print_str_sint~~CallsGraph proc~print_str_sint print_str_sint proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical interface~ut__message ut__message proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocprint_str_sintCallsGraph = svgPanZoom('#procprint_str_sintCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_str_sint~~CalledByGraph proc~print_str_sint print_str_sint interface~debug__print debug__print interface~debug__print->proc~print_str_sint proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->interface~debug__print proc~the_equation the_equation proc~the_equation->interface~debug__print proc~subfield_vel_tm subfield_vel_tm proc~subfield_vel_tm->interface~debug__print proc~slicedata__write slicedata__write proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~solver__initialize solver__initialize proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance solver__advance proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->interface~debug__print program~main_m->proc~slicedata__initialize program~main_m->proc~slicedata__write program~main_m->proc~solver__initialize program~main_m->proc~solver__advance proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis proc~solver__set_time_step solver__set_time_step program~main_m->proc~solver__set_time_step proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv proc~solver__set_time_step->proc~subfield_vel_tm var panprocprint_str_sintCalledByGraph = svgPanZoom('#procprint_str_sintCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_str_sint Source Code subroutine print_str_sint ( string , int ) !! Debugパラメータがtrueのとき文字列と整数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 integer ( SI ), intent ( in ) :: int !! 出力整数 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // trim ( string ), int ) end if end subroutine print_str_sint","tags":"","loc":"proc/print_str_sint.html"},{"title":"print_str_sint_double – Smoke Ring","text":"private subroutine print_str_sint_double(string, i1, d1) Debugパラメータがtrueのとき文字列と整数と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=SI), intent(in) :: i1 出力整数 real(kind=DR), intent(in) :: d1 出力実数 Calls proc~~print_str_sint_double~~CallsGraph proc~print_str_sint_double print_str_sint_double proc~params__get_logical params__get_logical proc~print_str_sint_double->proc~params__get_logical interface~ut__message ut__message proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~ut__assert->proc~ut__fatal proc~ut__fatal->interface~ut__message proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str var panprocprint_str_sint_doubleCallsGraph = svgPanZoom('#procprint_str_sint_doubleCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_str_sint_double~~CalledByGraph proc~print_str_sint_double print_str_sint_double interface~debug__print debug__print interface~debug__print->proc~print_str_sint_double proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->interface~debug__print proc~the_equation the_equation proc~the_equation->interface~debug__print proc~subfield_vel_tm subfield_vel_tm proc~subfield_vel_tm->interface~debug__print proc~slicedata__write slicedata__write proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~solver__initialize solver__initialize proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance solver__advance proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->interface~debug__print program~main_m->proc~slicedata__initialize program~main_m->proc~slicedata__write program~main_m->proc~solver__initialize program~main_m->proc~solver__advance proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis proc~solver__set_time_step solver__set_time_step program~main_m->proc~solver__set_time_step proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv proc~solver__set_time_step->proc~subfield_vel_tm var panprocprint_str_sint_doubleCalledByGraph = svgPanZoom('#procprint_str_sint_doubleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_str_sint_double Source Code subroutine print_str_sint_double ( string , i1 , d1 ) !! Debugパラメータがtrueのとき文字列と整数と実数を出力する character ( len =* ), intent ( in ) :: string !! 出力文字列 integer ( SI ), intent ( in ) :: i1 !! 出力整数 real ( DR ), intent ( in ) :: d1 !! 出力実数 if ( params__get_logical ( 'Debug' )) then ! Debugをflaseに設定したときは何もしない call ut__message ( 'debug: ' // trim ( string ), i1 , d1 ) end if end subroutine print_str_sint_double","tags":"","loc":"proc/print_str_sint_double.html"},{"title":"debug__print – Smoke Ring","text":"public interface debug__print 各種デバッグ出力の多重定義 Calls interface~~debug__print~~CallsGraph interface~debug__print debug__print proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~params__get_logical params__get_logical proc~print_str_sint->proc~params__get_logical proc~print_str_dint->proc~params__get_logical interface~ut__message ut__message proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~print_str_sint_double->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~params__get_logical->interface~ut__message proc~ut__assert ut__assert proc~params__get_logical->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_logical->proc~ut__fatal proc~ut__assert->proc~ut__fatal proc~message_decorated_str_dint->proc~message_decorated_str proc~message_decorated_str_sint->proc~message_decorated_str proc~ut__fatal->interface~ut__message var paninterfacedebug__printCallsGraph = svgPanZoom('#interfacedebug__printCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~debug__print~~CalledByGraph interface~debug__print debug__print proc~slicedata__initialize slicedata__initialize proc~slicedata__initialize->interface~debug__print proc~the_equation the_equation proc~the_equation->interface~debug__print proc~subfield_vel_tm subfield_vel_tm proc~subfield_vel_tm->interface~debug__print proc~slicedata__write slicedata__write proc~slicedata__write->interface~debug__print proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield proc~solver__initialize solver__initialize proc~solver__initialize->interface~debug__print proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~subfield_vel subfield_vel proc~subfield_vel->interface~debug__print proc~set_drive_force_field->interface~debug__print proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~subfield_vel_tm_divv->interface~debug__print proc~make_single_precision_field->interface~debug__print proc~solver__advance solver__advance proc~solver__advance->interface~debug__print proc~solver__advance->proc~the_equation proc~solver__advance->proc~subfield_vel_tm_divv program~main_m main_m program~main_m->interface~debug__print program~main_m->proc~slicedata__initialize program~main_m->proc~slicedata__write program~main_m->proc~solver__initialize program~main_m->proc~solver__advance proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis proc~solver__set_time_step solver__set_time_step program~main_m->proc~solver__set_time_step proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv proc~solver__set_time_step->proc~subfield_vel_tm var paninterfacedebug__printCalledByGraph = svgPanZoom('#interfacedebug__printCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures print_str print_str_dint print_str_dint_double print_str_double print_str_sint print_str_sint_double Module Procedures private subroutine print_str (string) Debugパラメータがtrueのとき文字列を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 private subroutine print_str_dint (string, int) Debugパラメータがtrueのとき文字列と整数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=DI), intent(in) :: int 出力整数 private subroutine print_str_dint_double (string, i1, d1) Debugパラメータがtrueのとき文字列と整数と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=DI), intent(in) :: i1 出力整数 real(kind=DR), intent(in) :: d1 出力実数 private subroutine print_str_double (string, double) Debugパラメータがtrueのとき文字列と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 real(kind=DR), intent(in) :: double 出力実数 private subroutine print_str_sint (string, int) Debugパラメータがtrueのとき文字列と整数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=SI), intent(in) :: int 出力整数 private subroutine print_str_sint_double (string, i1, d1) Debugパラメータがtrueのとき文字列と整数と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=SI), intent(in) :: i1 出力整数 real(kind=DR), intent(in) :: d1 出力実数","tags":"","loc":"interface/debug__print.html"},{"title":"grid__initialize – Smoke Ring","text":"private subroutine grid__initialize(self) gridの初期化 ここでは周期境界条件を仮定している。 構造体のメンバー関数としてcallするときその\n 構造体変数そのものがselfとして自動的に引数にはいる。\n たとえば、\n     call sampl_grid%initialize\n は\n     call grid__initialize(sample_grid)\n と解釈される。selfという名前でなくても構わない。 Arguments Type Intent Optional Attributes Name class( grid__t ), intent(out) :: self 格子構造体 Contents Source Code grid__initialize Source Code subroutine grid__initialize ( self ) !! gridの初期化 !! !! ここでは周期境界条件を仮定している。 !! !! 構造体のメンバー関数としてcallするときその !! 構造体変数そのものがselfとして自動的に引数にはいる。 !! たとえば、 !!     call sampl_grid%initialize !! は !!     call grid__initialize(sample_grid) !! と解釈される。selfという名前でなくても構わない。 class ( grid__t ), intent ( out ) :: self !! 格子構造体 integer ( SI ) :: i , j , k real ( DR ) :: dx , dy , dz ! 格子間隔 real ( DR ), parameter :: NEARLY_ZERO = 1.e-10_DR ! 十分小さい数 ! ! 周期境界条件 ! !    --+-----+-----|                             |-----+-----+--- !      6     7     8                             1     2     3 !            |-----+-----+-----+-----+-----+-----+-----| !            1     2     3     4     5     6     7     8 !               |===================================| !              XMIN                                XMAX ! dx = ( XMAX - XMIN ) / ( NX - 2 ) ! from (1.5) to (NX-0.5), see above figure. dy = ( YMAX - YMIN ) / ( NY - 2 ) ! ここではxminがi=1とi=2の2つの格子点の dz = ( ZMAX - ZMIN ) / ( NZ - 2 ) ! ちょうど中間に位置すると仮定している。 ! burgers_equationのサンプルコードでは ! i=2にXMINが位置していた。両者に実質的な ! 違いはない。 self % delta % x = dx ! x方向の格子間隔 self % delta % y = dy ! y方向の格子間隔 self % delta % z = dz ! z方向の格子間隔 self % delta_min = min ( self % delta % x , self % delta % y , self % delta % z ) ! 3つの格子間隔の最小値。 ! CFL条件はこの最小値で決まる。 self % d1 % x = 1.0_DR / ( 2 * dx ) ! 1階差分演算用定数 self % d1 % y = 1.0_DR / ( 2 * dy ) ! dはderivativeを表す self % d1 % z = 1.0_DR / ( 2 * dz ) ! d1は1階差分の意味 self % d2 % x = 1.0_DR / ( dx ** 2 ) ! 2階差分演算用定数 self % d2 % y = 1.0_DR / ( dy ** 2 ) ! dはderivativeを表す self % d2 % z = 1.0_DR / ( dz ** 2 ) ! d2は2階差分の意味 do i = 1 , NX ! x方向の格子点位置の設定 ! XMINはi=1とi=2の中間にある self % pos % x ( i ) = XMIN + dx * ( real ( i , DR ) - 1.5_DR ) end do do j = 1 , NY ! y方向の格子点位置の設定 self % pos % y ( j ) = YMIN + dy * ( real ( j , DR ) - 1.5_DR ) end do do k = 1 , NZ ! z方向の格子点位置の設定 self % pos % z ( k ) = ZMIN + dz * ( real ( k , DR ) - 1.5_DR ) end do call ut__assert ( abs ( self % pos % x ( 1 ) - XMIN + dx / 2 ) + & abs ( self % pos % x ( NX ) - XMAX - dx / 2 ) + & abs ( self % pos % y ( 1 ) - YMIN + dy / 2 ) + & abs ( self % pos % y ( NY ) - YMAX - dy / 2 ) + & abs ( self % pos % z ( 1 ) - ZMIN + dz / 2 ) + & abs ( self % pos % z ( NZ ) - ZMAX - dz / 2 ) < NEARLY_ZERO , & \"<grid__initialize> grid min/max inconsistent?\" ) ! シミュレーション領域の範囲を決めるxmin, xmax, ..., zmaxZ ! の6個の頂点位置が上で定義した格子点位置と矛盾していない ! ことを確認する。万が一この前提が崩れている時はすぐに ! シミュレーションを停止する end subroutine grid__initialize","tags":"","loc":"proc/grid__initialize.html"},{"title":"constants_m – Smoke Ring","text":"Fortran定数と数学定数 Note 定数であることが目で見てわかりやすいように全ての文字を\n      大文字で書く。コンパイラには無意味であるので注意。 Note シミュレーション領域は直方体と仮定している。\n      x方向の長さXMAX-XMINである。座標系の原点を\n      シミュレーション領域の中心におくためには\n      XMAXとXMIN絶対値を等しくとる。 Note シミュレーションの（x方向の）空間解像度を上げる\n      ためには同じXMAX-XMINに対して格子点数NXを上げれば良い。 Note x,y,z それぞれの方向の空間解像度、\n      つまり格子間隔dx,dy,dzが異なっていても構わないが、\n      その差が極端に大きくしないほうがよい。 Used by module~~constants_m~~UsedByGraph module~constants_m constants_m module~job_m job_m module~job_m->module~constants_m module~ut_m ut_m module~job_m->module~ut_m module~solver_m solver_m module~solver_m->module~constants_m module~solver_m->module~job_m module~solver_m->module~ut_m module~params_m params_m module~solver_m->module~params_m module~debug_m debug_m module~solver_m->module~debug_m module~field_m field_m module~solver_m->module~field_m module~grid_m grid_m module~solver_m->module~grid_m module~ut_m->module~constants_m module~params_m->module~constants_m module~params_m->module~ut_m module~debug_m->module~constants_m module~debug_m->module~ut_m module~debug_m->module~params_m module~field_m->module~constants_m module~field_m->module~grid_m program~main_m main_m program~main_m->module~constants_m program~main_m->module~job_m program~main_m->module~solver_m program~main_m->module~ut_m program~main_m->module~params_m program~main_m->module~debug_m program~main_m->module~field_m program~main_m->module~grid_m module~slicedata_m slicedata_m program~main_m->module~slicedata_m module~grid_m->module~constants_m module~grid_m->module~ut_m module~slicedata_m->module~solver_m module~slicedata_m->module~ut_m module~slicedata_m->module~params_m module~slicedata_m->module~debug_m module~slicedata_m->module~field_m var panmoduleconstants_mUsedByGraph = svgPanZoom('#moduleconstants_mUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables DI DR NX NY NZ PI SI SR TWOPI XMAX XMIN YMAX YMIN ZMAX ZMIN Variables Type Visibility Attributes Name Initial integer, public, parameter :: DI = selected_int_kind(16) integer, public, parameter :: DR = selected_real_kind(12) integer(kind=SI), public, parameter :: NX = 60 integer(kind=SI), public, parameter :: NY = 20 integer(kind=SI), public, parameter :: NZ = 20 real(kind=DR), public, parameter :: PI = 3.1415926535897932_DR integer, public, parameter :: SI = selected_int_kind(8) integer, public, parameter :: SR = selected_real_kind(6) real(kind=DR), public, parameter :: TWOPI = PI*2 real(kind=DR), public, parameter :: XMAX = +1.5_DR real(kind=DR), public, parameter :: XMIN = -1.5_DR real(kind=DR), public, parameter :: YMAX = +0.5_DR real(kind=DR), public, parameter :: YMIN = -0.5_DR real(kind=DR), public, parameter :: ZMAX = +0.5_DR real(kind=DR), public, parameter :: ZMIN = -0.5_DR","tags":"","loc":"module/constants_m.html"},{"title":"job_m – Smoke Ring","text":"シミュレーションジョブの制御 Note 配列演算を多用している。つまり一行で書かれている部分も\n   実際は3重do loopで書かれような大量の演算をしているところが\n   多い。このコードをOpenMP化する時には、そのような部分を\n   3重do loopに展開して書き直す必要がある。 Uses constants_m ut_m module~~job_m~~UsesGraph module~job_m job_m module~ut_m ut_m module~job_m->module~ut_m module~constants_m constants_m module~job_m->module~constants_m module~ut_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~job_m~~UsedByGraph module~job_m job_m program~main_m main_m program~main_m->module~job_m module~solver_m solver_m program~main_m->module~solver_m module~slicedata_m slicedata_m program~main_m->module~slicedata_m module~solver_m->module~job_m module~slicedata_m->module~solver_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables job__karte Derived Types job__karte_t Subroutines job__finalize job__karte_set Variables Type Visibility Attributes Name Initial type( job__karte_t ), public :: job__karte Derived Types type, public :: job__karte_t Components Type Visibility Attributes Name Initial character(len=20), public :: state = \"fine\" Type-Bound Procedures procedure, public :: set => job__karte_set Subroutines public subroutine job__finalize (nloop) ジョブ終了時の後始末。実際には健康状態カルテに応じた\n メッセージを標準出力に書くだけ Read more… Arguments Type Intent Optional Attributes Name integer(kind=DI), intent(in) :: nloop ループカウンタ private subroutine job__karte_set (self, state_) ジョブカルテの設定終了時の後始末。実際には健康状態カルテに応じた Read more… Arguments Type Intent Optional Attributes Name class( job__karte_t ), intent(out) :: self ジョブカルテ character(len=*), intent(in) :: state_ 設定する状態","tags":"","loc":"module/job_m.html"},{"title":"ut_m – Smoke Ring","text":"ユーティリティライブラリ Note よく使う関数・ルーチンをまとめている。 Note 冒頭でuse constants_mとしているが、\n        このモジュールで使うのはconstants\n        モジュールで定義された定数の中で\n        DR等のFortran関連の定数だけである。\n        それ以外のシミュレーション関係の定数は\n        使用しないこういう場合は単なる\n        use文にonlyというキーワードを\n        つけてDR等だけを使うことを明示的に\n        示すことができる。 Uses constants_m module~~ut_m~~UsesGraph module~ut_m ut_m module~constants_m constants_m module~ut_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ut_m~~UsedByGraph module~ut_m ut_m module~job_m job_m module~job_m->module~ut_m module~solver_m solver_m module~solver_m->module~ut_m module~solver_m->module~job_m module~params_m params_m module~solver_m->module~params_m module~debug_m debug_m module~solver_m->module~debug_m module~grid_m grid_m module~solver_m->module~grid_m module~field_m field_m module~solver_m->module~field_m module~params_m->module~ut_m module~debug_m->module~ut_m module~debug_m->module~params_m module~slicedata_m slicedata_m module~slicedata_m->module~ut_m module~slicedata_m->module~solver_m module~slicedata_m->module~params_m module~slicedata_m->module~debug_m module~slicedata_m->module~field_m program~main_m main_m program~main_m->module~ut_m program~main_m->module~job_m program~main_m->module~solver_m program~main_m->module~params_m program~main_m->module~debug_m program~main_m->module~slicedata_m program~main_m->module~grid_m program~main_m->module~field_m module~grid_m->module~ut_m module~field_m->module~grid_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces ut__message Functions ut__int_to_str3 ut__int_to_str7 Subroutines message_decorated_str message_decorated_str_dint message_decorated_str_sint message_str message_str_dint message_str_dint_double message_str_dint_double_double message_str_double message_str_float message_str_sint message_str_sint_double message_str_sint_double_double ut__assert ut__fatal Interfaces public interface ut__message 文字列（+ 数値）を標準出力に書き出すルーチンの多重定義 Read more… private subroutine message_decorated_str (mark, string) 飾り文字でメーセージ文を囲む Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字でメーセージを囲む character(len=*), intent(in) :: string 出力メーセージ（文字列） private subroutine message_decorated_str_dint (mark, string, int) 飾り文字でメーセージ文と倍精度整数を囲む Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字で全体を囲む character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: int 文字列の後に書く倍精度整数 private subroutine message_decorated_str_sint (mark, string, int) 飾り文字でメーセージ文と単精度整数を囲む Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字で全体を囲む character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: int 文字列の後に書く単精度整数 private subroutine message_str (string) 普通のprint文 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 private subroutine message_str_double (string, double) 文字列 + 倍精度実数2つの出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 real(kind=DR), intent(in) :: double 書き出される実数 private subroutine message_str_float (string, float) 文字列 + 単精度実数2つの出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 real(kind=SR), intent(in) :: float 書き出される実数 private subroutine message_str_dint (string, int) 文字列 + 倍精度整数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: int 書き出される整数 private subroutine message_str_dint_double (string, i1, d1) 文字列 + 倍精度整数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 private subroutine message_str_dint_double_double (string, i1, d1, d2) 文字列 + 倍精度整数 + 倍精度実数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 real(kind=DR), intent(in) :: d2 書き出される実数 private subroutine message_str_sint (string, int) 文字列 + 単精度整数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: int 書き出される整数 private subroutine message_str_sint_double (string, i1, d1) 文字列 + 単精度整数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 private subroutine message_str_sint_double_double (string, i1, d1, d2) 文字列 + 単精度整数 + 倍精度実数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 real(kind=DR), intent(in) :: d2 書き出される実数 Functions public function ut__int_to_str3 (i) result(str3) 整数を文字列（3文字固定）に変換する Read more… Arguments Type Intent Optional Attributes Name integer(kind=SI), intent(in) :: i Return Value character(len=3) public function ut__int_to_str7 (i) result(str7) 整数を文字列（7文字固定）に変換する Read more… Arguments Type Intent Optional Attributes Name integer(kind=SI), intent(in) :: i Return Value character(len=7) Subroutines private subroutine message_decorated_str (mark, string) 飾り文字でメーセージ文を囲む Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字でメーセージを囲む character(len=*), intent(in) :: string 出力メーセージ（文字列） private subroutine message_decorated_str_dint (mark, string, int) 飾り文字でメーセージ文と倍精度整数を囲む Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字で全体を囲む character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: int 文字列の後に書く倍精度整数 private subroutine message_decorated_str_sint (mark, string, int) 飾り文字でメーセージ文と単精度整数を囲む Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: mark この文字で全体を囲む character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: int 文字列の後に書く単精度整数 private subroutine message_str (string) 普通のprint文 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 private subroutine message_str_dint (string, int) 文字列 + 倍精度整数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: int 書き出される整数 private subroutine message_str_dint_double (string, i1, d1) 文字列 + 倍精度整数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 private subroutine message_str_dint_double_double (string, i1, d1, d2) 文字列 + 倍精度整数 + 倍精度実数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=DI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 real(kind=DR), intent(in) :: d2 書き出される実数 private subroutine message_str_double (string, double) 文字列 + 倍精度実数2つの出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 real(kind=DR), intent(in) :: double 書き出される実数 private subroutine message_str_float (string, float) 文字列 + 単精度実数2つの出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 real(kind=SR), intent(in) :: float 書き出される実数 private subroutine message_str_sint (string, int) 文字列 + 単精度整数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: int 書き出される整数 private subroutine message_str_sint_double (string, i1, d1) 文字列 + 単精度整数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 private subroutine message_str_sint_double_double (string, i1, d1, d2) 文字列 + 単精度整数 + 倍精度実数 + 倍精度実数の出力 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string メーセージ文字列 integer(kind=SI), intent(in) :: i1 書き出される整数 real(kind=DR), intent(in) :: d1 書き出される実数 real(kind=DR), intent(in) :: d2 書き出される実数 public subroutine ut__assert (condition, last_will) アサーション Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition 必須条件 character(len=*), intent(in) :: last_will 遺言 public subroutine ut__fatal (last_will) 致命的エラー Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: last_will","tags":"","loc":"module/ut_m.html"},{"title":"slicedata_m – Smoke Ring","text":"断面データの作成とディスクへの出力 書き出されたデータはslice_grapherディレクトリにあるプログラムで\n  可視化される。 Note ここで書き出す断面データは単精度浮動小数点数である。可視化には\n    単精度で十分である。 Note サブルーチンmake_single_precision_fieldでは\n    fieldモジュールで定義されたcurlを計算するルーチンを呼び出している。\n    ここで.curl.などの演算子を使うと記述が簡潔になるが、\n    現在はこれをコメントアウトしている。Fortranコンパイラが\n    自己定義演算子を問題なく使えるのであれば\n    .curl.などを使うようにコメントを外せばよい。\n    詳しくはfieldモジュールを見よ。 Uses ut_m field_m params_m debug_m solver_m module~~slicedata_m~~UsesGraph module~slicedata_m slicedata_m module~ut_m ut_m module~slicedata_m->module~ut_m module~solver_m solver_m module~slicedata_m->module~solver_m module~params_m params_m module~slicedata_m->module~params_m module~debug_m debug_m module~slicedata_m->module~debug_m module~field_m field_m module~slicedata_m->module~field_m module~constants_m constants_m module~ut_m->module~constants_m module~solver_m->module~ut_m module~solver_m->module~params_m module~solver_m->module~debug_m module~solver_m->module~field_m module~job_m job_m module~solver_m->module~job_m module~solver_m->module~constants_m module~grid_m grid_m module~solver_m->module~grid_m module~params_m->module~ut_m module~params_m->module~constants_m module~debug_m->module~ut_m module~debug_m->module~params_m module~debug_m->module~constants_m module~field_m->module~constants_m module~field_m->module~grid_m module~job_m->module~ut_m module~job_m->module~constants_m module~grid_m->module~ut_m module~grid_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~slicedata_m~~UsedByGraph module~slicedata_m slicedata_m program~main_m main_m program~main_m->module~slicedata_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables FILE_SLICEDATA Initialize_done Slice_en Slice_ps Slice_vx Slice_vy Slice_vz Subroutines make_single_precision_field slicedata__initialize slicedata__write Variables Type Visibility Attributes Name Initial integer(kind=SI), private, parameter :: FILE_SLICEDATA = 20 logical, private, save :: Initialize_done = .false. real(kind=SR), private, dimension(:,:), allocatable :: Slice_en real(kind=SR), private, dimension(:,:), allocatable :: Slice_ps real(kind=SR), private, dimension(:,:), allocatable :: Slice_vx real(kind=SR), private, dimension(:,:), allocatable :: Slice_vy real(kind=SR), private, dimension(:,:), allocatable :: Slice_vz Subroutines private subroutine make_single_precision_field (vel, ps) シミュレーションで計算した速度場と圧力場\n のx-z平面での断面データを求める。\n その際、倍精度実数から単精度実数に型変換する。 Read more… Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: vel 速度場（3D） real(kind=DR), intent(in), dimension(NX,NY,NZ) :: ps 圧力場（3D） public subroutine slicedata__initialize () このモジュールの初期化 Read more… Arguments None public subroutine slicedata__write (nloop, time, fluid) 断面データのディスクへの書き出し Arguments Type Intent Optional Attributes Name integer(kind=DI), intent(in) :: nloop 現在のループカウンタ real(kind=DR), intent(in) :: time 現在の時刻 type( field__fluid_t ), intent(in) :: fluid 現在の流体データ","tags":"","loc":"module/slicedata_m.html"},{"title":"params_m – Smoke Ring","text":"シミュレーションパラメータ Note パラメーターはnamelistを使ってファイルから読み込む Note 先頭一文字だけが大文字になっている変数例えば Read_done などは\n     このモジュールを名前空間とする変数を意味する。つまりモジュール\n     外からはアクセスできないがモジュール内のルーチン関数からは\n     アクセスできるものである。\n     このようにスコープの広い変数を乱用するとバグの温床になるが\n     この程度の小さなプログラムであれば問題ないであろう。 Note ファイル番号10番をparams__readで使っている。 Note namelistファイルの内容を変更する場合は:\n      (1) このファイルの少し下の行にあるnamelist文を書き換える。\n      (2) params__readを書き換える。\n      (3) namelist__get_double, _integer等の対応する行も書き換える。 Note namelist文中のスラッシュで囲まれた名称（たとえば/simulation/）\n    や、namelist変数名（たとえばTotal_nloop）はnamelistファイル\n    の中での記述と対応していなければいけない。 Uses constants_m ut_m module~~params_m~~UsesGraph module~params_m params_m module~ut_m ut_m module~params_m->module~ut_m module~constants_m constants_m module~params_m->module~constants_m module~ut_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~params_m~~UsedByGraph module~params_m params_m program~main_m main_m program~main_m->module~params_m module~solver_m solver_m program~main_m->module~solver_m module~debug_m debug_m program~main_m->module~debug_m module~slicedata_m slicedata_m program~main_m->module~slicedata_m module~solver_m->module~params_m module~solver_m->module~debug_m module~debug_m->module~params_m module~slicedata_m->module~params_m module~slicedata_m->module~solver_m module~slicedata_m->module~debug_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Debug Kappa Read_done STRING_LENGTH_MAX Slicedata_nskip Slicedata_tag Total_nloop Viscosity Functions params__get_double params__get_integer params__get_logical params__get_string Subroutines params__read Variables Type Visibility Attributes Name Initial logical, private :: Debug real(kind=DR), private :: Kappa logical, private, save :: Read_done = .false. integer(kind=SI), private, parameter :: STRING_LENGTH_MAX = 200 integer(kind=SI), private :: Slicedata_nskip character(len=STRING_LENGTH_MAX), private :: Slicedata_tag integer(kind=SI), private :: Total_nloop real(kind=DR), private :: Viscosity Functions public function params__get_double (variable) このモジュールの外からの問い合わせに応じてnamelistデータを返す。\n この関数は問い合わせ変数が倍精度浮動小数点数の場合。\n この関数の前にnamelist__readが呼ばれている必要がある。\n この点はassertで確認している。 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value real(kind=DR) その値 public function params__get_integer (variable) このモジュールの外からの問い合わせに応じてnamelistデータを返す。\n この関数は問い合わせ変数が整数の場合。\n この関数の前にnamelist__readが呼ばれている必要がある。\n この点はassertで確認している。 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value integer(kind=SI) その値 public function params__get_logical (variable) このモジュールの外からの問い合わせに応じてnamelistデータを返す。\n この関数は問い合わせ変数が論理値の場合。\n この関数の前にnamelist__readが呼ばれている必要がある。\n この点はassertで確認している。 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value logical その値 public function params__get_string (variable) このモジュールの外からの問い合わせに応じてnamelistデータを返す。\n この関数は問い合わせ変数が文字列の場合。\n この関数の前にnamelist__readが呼ばれている必要がある。\n この点はassertで確認している。 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: variable 問い合わせ変数の名前 Return Value character(len=STRING_LENGTH_MAX) その値 Subroutines public subroutine params__read () namelistファイルをディスクから読み込む。\n ファイル名はコマンド第一引数。 Read more… Arguments None","tags":"","loc":"module/params_m.html"},{"title":"solver_m – Smoke Ring","text":"ナビエ・ストークス方程式ソルバ Note Initialize_done, Viscosity など、頭文字だけが大文字の\n    変数名はこのモジュール全体にscopeを持つ変数である。\n    つまりこのモジュールの中の任意のサブルーチン・関数からアクセスできる。\n    ただし、このモジュールの外からはアクセスできない（privateである） Note サブルーチンsubfield_velでは構造体の割り算\n       vel = fluid%flux / fluid%density \n    をコメントアウトとしている。\n    Fortranコンパイラが自己定義演算子を問題なく使えるのであれば\n    コメントを外してこれを使うほうが記述が簡潔になる。\n    詳しくはfieldモジュールを見よ。 サブルーチンsolver__advanceでの\n    gluid = fluid + dfluid01*0.5_DR\nなどといった記述についても同様。 Bug サブルーチン solver__diagnosis の発散判定で\n        if ( maxval(fluid%flux%x) > ABNORMALLY_LARGE ) then\n    としているところ、正しくは\n        if ( maxval(abs(fluid%flux%x)) > ABNORMALLY_LARGE ) then\n    とすべき。このままだと-x方向に大きな値があるときに引っかからない。 Bug 関数 solver__set_time_step で\n       vmax = maxval(sqrt(vel%x 2+vel%y 2+vel%z 2))\n    という演算はmaxvalとsqrtは交換して\n       vmax = sqrt(maxval(vel%x 2+vel%y 2+vel%z 2))\n    とした方が速くなる可能性が高い。\n    このままだと3次元配列の全要素にsqrt\n    を掛けてからそのmaxvalをとっているが、この順番は\n    逆にした方が速いだろう。 Bug その少し下の\n       sound_v = GAMMA maxval(sqrt(GASS_CONST_FOR_AIR tm)) \n    も同様に\n       sound_v = GAMMA sqrt(maxval(GASS_CONST_FOR_AIR tm)) \n    とすべきだろう。 Uses constants_m grid_m ut_m params_m field_m debug_m job_m module~~solver_m~~UsesGraph module~solver_m solver_m module~job_m job_m module~solver_m->module~job_m module~ut_m ut_m module~solver_m->module~ut_m module~params_m params_m module~solver_m->module~params_m module~debug_m debug_m module~solver_m->module~debug_m module~constants_m constants_m module~solver_m->module~constants_m module~field_m field_m module~solver_m->module~field_m module~grid_m grid_m module~solver_m->module~grid_m module~job_m->module~ut_m module~job_m->module~constants_m module~ut_m->module~constants_m module~params_m->module~ut_m module~params_m->module~constants_m module~debug_m->module~ut_m module~debug_m->module~params_m module~debug_m->module~constants_m module~field_m->module~constants_m module~field_m->module~grid_m module~grid_m->module~ut_m module~grid_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~solver_m~~UsedByGraph module~solver_m solver_m program~main_m main_m program~main_m->module~solver_m module~slicedata_m slicedata_m program~main_m->module~slicedata_m module~slicedata_m->module~solver_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Drive_force GAMMA GASS_CONST_FOR_AIR Gamma1_kappa Initialize_done Viscosity Interfaces solver__get_subfield Functions drive_force_factor solver__set_time_step the_equation Subroutines set_drive_force_field solver__advance solver__diagnosis solver__initialize subfield_vel subfield_vel_tm subfield_vel_tm_divv Variables Type Visibility Attributes Name Initial type( field__vector3d_t ), private, save :: Drive_force real(kind=DR), private, parameter :: GAMMA = 1.4_DR real(kind=DR), private, parameter :: GASS_CONST_FOR_AIR = 2.87e2_DR real(kind=DR), private, save :: Gamma1_kappa logical, private, save :: Initialize_done = .false. real(kind=DR), private, save :: Viscosity Interfaces public interface solver__get_subfield 流体の基本変数（質量フラックス、質量密度、圧力）\n から二次的な量（流れ場、温度場、速度の発散）\n を計算するためのルーチン群の多重定義 private subroutine subfield_vel (fluid, vel) fluidの基本変数から二次的な場vel（流れの速度ベクトル場）\n をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れの速度ベクトル private subroutine subfield_vel_tm (fluid, vel, tm) fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm）\n をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: tm 温度場 private subroutine subfield_vel_tm_divv (fluid, vel, tm, divv) fluidの基本変数から二次的な場（速度ベクトル場velと\n 温度場tmと速度の発散divv）をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: tm 温度場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: divv 流れの発散 Functions private function drive_force_factor (time) 渦輪を駆動する力の時間変化の調整のための係数設定 Read more… Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: time シミュレーション時刻 Return Value real(kind=DR) 力の強さ係数 0から1 public function solver__set_time_step (nloop, fluid) CFL条件に基づいて時間刻み幅dtを設定する Arguments Type Intent Optional Attributes Name integer(kind=DI), intent(in) :: nloop ループカウンタ type( field__fluid_t ), intent(in) :: fluid 流体データ Return Value real(kind=DR) 時間刻み幅 dt private function the_equation (t, dt, vx, vy, vz, tm, divv, fx, fy, fz, ps) ナビエ・ストークス方程式の右辺（時間変化量）dtを掛けたものを計算 Read more… Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: t 時刻と時間刻み幅 real(kind=DR), intent(in) :: dt 時刻と時間刻み幅 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: vx 速度3成分 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: vy 速度3成分 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: vz 速度3成分 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: tm 温度と速度の発散 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: divv 温度と速度の発散 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: fx 質量フラックス real(kind=DR), intent(in), dimension(NX,NY,NZ) :: fy 質量フラックス real(kind=DR), intent(in), dimension(NX,NY,NZ) :: fz 質量フラックス real(kind=DR), intent(in), dimension(NX,NY,NZ) :: ps 圧力 Return Value type( field__fluid_t ) 時間刻みdtでの流体データの微小変化量 Subroutines private subroutine set_drive_force_field () 渦輪を駆動するための力の場を設定する\n その力はシミュレーション開始直後、短い時間だけかける。\n 空間的には局在した力を想定している。その形状は円筒形である。\n 円筒の軸はx軸上にある。 Arguments None public subroutine solver__advance (t, dt, fluid) 4段4次ルンゲ・クッタ積分法による時間積分の実行 Read more… Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout) :: t 時刻 real(kind=DR), intent(in) :: dt 時間刻み幅 type( field__fluid_t ), intent(inout) :: fluid 流体データ public subroutine solver__diagnosis (nloop, time, fluid) 流体の「健康状態」を診断する Arguments Type Intent Optional Attributes Name integer(kind=DI), intent(in) :: nloop ループカウンタ real(kind=DR), intent(in) :: time シミュレーション時刻 type( field__fluid_t ), intent(in) :: fluid 流体データ public subroutine solver__initialize (fluid) モジュールの初期化 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(out) :: fluid 流体データ private subroutine subfield_vel (fluid, vel) fluidの基本変数から二次的な場vel（流れの速度ベクトル場）\n をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れの速度ベクトル private subroutine subfield_vel_tm (fluid, vel, tm) fluidの基本変数から二次的な場（速度ベクトル場velと温度場tm）\n をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: tm 温度場 private subroutine subfield_vel_tm_divv (fluid, vel, tm, divv) fluidの基本変数から二次的な場（速度ベクトル場velと\n 温度場tmと速度の発散divv）をもとめる。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体基本場 type( field__vector3d_t ), intent(out) :: vel 流れ場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: tm 温度場 real(kind=DR), intent(out), dimension(NX,NY,NZ) :: divv 流れの発散","tags":"","loc":"module/solver_m.html"},{"title":"field_m – Smoke Ring","text":"流体場データ構造体 Note コードを簡潔にするため.curl.や.div.などの\n        ベクトル解析演算子をいったんは定義したが、いまは\n        それらの演算子を使う部分はコメントアウトしている。\n        一部のFortranコンパイラでこの部分の挙動が\n        怪しかったからである。\n        演習室のFortranコンパイラでは大丈夫かもしれないが未確認。 Note このバージョンでは古典的な関数呼び出しで\n        curlやdivなどを実行しているが、コメントを付け替える\n        だけで演算子（.curl.等）が使えるはず。 Note 配列演算を多用している。つまり一行で書かれている部分も\n        実際は3重do loopで書かれような大量の演算をしているところが\n        多い。このコードをOpenMP化する時には、そのような部分を\n        3重do loopに展開して書き直す必要がある。 Uses constants_m grid_m module~~field_m~~UsesGraph module~field_m field_m module~constants_m constants_m module~field_m->module~constants_m module~grid_m grid_m module~field_m->module~grid_m module~grid_m->module~constants_m module~ut_m ut_m module~grid_m->module~ut_m module~ut_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~field_m~~UsedByGraph module~field_m field_m program~main_m main_m program~main_m->module~field_m module~solver_m solver_m program~main_m->module~solver_m module~slicedata_m slicedata_m program~main_m->module~slicedata_m module~solver_m->module~field_m module~slicedata_m->module~field_m module~slicedata_m->module~solver_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces field__boundary_condition Derived Types field__fluid_t field__vector3d_t Functions operator_cross_product operator_curl operator_div operator_dot_product operator_energyintegral operator_fluid_add operator_fluid_times_integer operator_fluid_times_real operator_integer_times_fluid operator_laplacian_scalar operator_laplacian_vector operator_real_times_fluid operator_real_times_vector operator_scalar_times_vector operator_scalarintegral operator_vector_add operator_vector_divby_scalar operator_vector_times_real operator_vector_times_scalar Subroutines assignment_real_to_fluid assignment_real_to_vector boundary_condition_fluid boundary_condition_scalar boundary_condition_vector Interfaces public interface field__boundary_condition 境界条件呼び出しルーチンの多重定義\n 境界条件を設定する変数の種類によって\n 実際に使用するルーチンが違うが、\n 呼び出し側では統一した名前でcallする。\n コンパイラは引数の型で使用するルーチンを\n 判断する。 private subroutine boundary_condition_fluid (fluid) 流体構造体の境界条件設定 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(inout) :: fluid 流体場 private subroutine boundary_condition_scalar (scalar) スカラー場の境界条件設定 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout), dimension(NX,NY,NZ) :: scalar スカラー場 private subroutine boundary_condition_vector (vec) ベクトル場の境界条件設定 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(inout) :: vec ベクトル場 Derived Types type, public :: field__fluid_t このシミュレーションコードで最も大事な\n 変数（構造体）。流体の状態を保持する。 Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(NX,NY,NZ) :: density 質量密度場 type( field__vector3d_t ), public :: flux 質量フラックス real(kind=DR), public, dimension(NX,NY,NZ) :: pressure 圧力場 type, public :: field__vector3d_t 3次元ベクトル場構造体\n ここでは配列のサイズを決めているが、\n 実行時に不定にしたい場合はallocatable\n は配列を使えば良い。しミュレーション\n コード全体にサイズ（行数）がそれほど\n 多くない今のような場合は、配列サイズ\n （=シミュレーションの格子点数）を\n 変更する度にコンパイルしてもたいした\n 時間はかからないのでこのように\n 決め打ちにしても問題ない。 Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(NX,NY,NZ) :: x x成分 real(kind=DR), public, dimension(NX,NY,NZ) :: y y成分 real(kind=DR), public, dimension(NX,NY,NZ) :: z z成分 Functions public function operator_cross_product (a, b) ベクトル場の外積 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a 掛けるベクトル場 type( field__vector3d_t ), intent(in) :: b 掛けるベクトル場 Return Value type( field__vector3d_t ) 外積 public function operator_curl (a) ベクトル場のcurl Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a これのcurlをとる Return Value type( field__vector3d_t ) curlした結果 public function operator_div (a) ベクトル場のdivergence Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a これのdivをとる Return Value real(kind=DR),\n  dimension(NX,NY,NZ) 結果 public function operator_dot_product (a, b) ベクトル場の内積 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a 内積をとるベクトル場 type( field__vector3d_t ), intent(in) :: b 内積をとるベクトル場 Return Value real(kind=DR),\n  dimension(NX,NY,NZ) 計算結果 public function operator_energyintegral (a) 流体の運動エネルギーの体積積分 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: a 流体場 Return Value real(kind=DR) 全エネルギー public function operator_fluid_add (a, b) 流体構造体の足し算演算子 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: a 足し算する2つの流体場 type( field__fluid_t ), intent(in) :: b 足し算する2つの流体場 Return Value type( field__fluid_t ) 計算結果 public function operator_fluid_times_integer (fluid, integer) 流体構造体を整数倍するための演算子 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体場 integer(kind=SI), intent(in) :: integer かける整数 Return Value type( field__fluid_t ) public function operator_fluid_times_real (fluid, real) 流体構造体を実数倍するための演算子 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(in) :: fluid 流体場 real(kind=DR), intent(in) :: real かける実数 Return Value type( field__fluid_t ) 計算結果 public function operator_integer_times_fluid (integer, fluid) 整数に流体構造体を掛け算するための演算子 Arguments Type Intent Optional Attributes Name integer(kind=SI), intent(in) :: integer かける整数 type( field__fluid_t ), intent(in) :: fluid 流体場 Return Value type( field__fluid_t ) 計算結果 public function operator_laplacian_scalar (a) スカラー場のラプラシアン Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(NX,NY,NZ) :: a 入力スカラー場 Return Value real(kind=DR),\n  dimension(NX,NY,NZ) 計算結果 public function operator_laplacian_vector (a) ベクトル場のラプラシアン Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a 入力ベクトル場 Return Value type( field__vector3d_t ) 計算結果 public function operator_real_times_fluid (real, fluid) 実数に流体場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( field__fluid_t ), intent(in) :: fluid 流体場 Return Value type( field__fluid_t ) 計算結果 public function operator_real_times_vector (real, vec) 実数にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in) :: real 掛ける実数 type( field__vector3d_t ), intent(in) :: vec 流体場 Return Value type( field__vector3d_t ) 計算結果 public function operator_scalar_times_vector (scalar, vec) スカラー場にベクトル場を掛ける演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(NX,NY,NZ) :: scalar スカラー場 type( field__vector3d_t ), intent(in) :: vec ベクトル場 Return Value type( field__vector3d_t ) 計算結果 public function operator_scalarintegral (a) スカラー場の体積積分演算子 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(in), dimension(NX,NY,NZ) :: a スカラー場 Return Value real(kind=DR) 体積積分結果 public function operator_vector_add (a, b) ベクトル場の和の演算子 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: a 和をとるベクトル場 type( field__vector3d_t ), intent(in) :: b 和をとるベクトル場 Return Value type( field__vector3d_t ) 計算結果 public function operator_vector_divby_scalar (vec, scalar) ベクトル場の各成分をスカラー場で割る Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: scalar スカラー場 Return Value type( field__vector3d_t ) 計算結果 public function operator_vector_times_real (vec, real) ベクトル場の実数倍の演算子 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in) :: real 掛ける実数 Return Value type( field__vector3d_t ) 計算結果 public function operator_vector_times_scalar (vec, scalar) ベクトル場にスカラー場を掛ける Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(in) :: vec ベクトル場 real(kind=DR), intent(in), dimension(NX,NY,NZ) :: scalar スカラー場 Return Value type( field__vector3d_t ) 計算結果 Subroutines private subroutine assignment_real_to_fluid (fluid, real) 流体構造体に実数を代入。\n 初期条件ですべての要素を0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(out) :: fluid 流体場 real(kind=DR), intent(in) :: real 代入する実数 private subroutine assignment_real_to_vector (vector, real) ベクトル場に実数を代入。\n 初期条件で0にセットするときに使う。 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(out) :: vector ベクトル場 real(kind=DR), intent(in) :: real 代入する実数 private subroutine boundary_condition_fluid (fluid) 流体構造体の境界条件設定 Arguments Type Intent Optional Attributes Name type( field__fluid_t ), intent(inout) :: fluid 流体場 private subroutine boundary_condition_scalar (scalar) スカラー場の境界条件設定 Arguments Type Intent Optional Attributes Name real(kind=DR), intent(inout), dimension(NX,NY,NZ) :: scalar スカラー場 private subroutine boundary_condition_vector (vec) ベクトル場の境界条件設定 Arguments Type Intent Optional Attributes Name type( field__vector3d_t ), intent(inout) :: vec ベクトル場","tags":"","loc":"module/field_m.html"},{"title":"debug_m – Smoke Ring","text":"デバッグ用の標準出力ルーチン Note parameterのDebugがtrueのときだけ処理する Uses constants_m ut_m params_m module~~debug_m~~UsesGraph module~debug_m debug_m module~ut_m ut_m module~debug_m->module~ut_m module~constants_m constants_m module~debug_m->module~constants_m module~params_m params_m module~debug_m->module~params_m module~ut_m->module~constants_m module~params_m->module~ut_m module~params_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~debug_m~~UsedByGraph module~debug_m debug_m program~main_m main_m program~main_m->module~debug_m module~solver_m solver_m program~main_m->module~solver_m module~slicedata_m slicedata_m program~main_m->module~slicedata_m module~solver_m->module~debug_m module~slicedata_m->module~debug_m module~slicedata_m->module~solver_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces debug__print Subroutines print_str print_str_dint print_str_dint_double print_str_double print_str_sint print_str_sint_double Interfaces public interface debug__print 各種デバッグ出力の多重定義 private subroutine print_str (string) Debugパラメータがtrueのとき文字列を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 private subroutine print_str_dint (string, int) Debugパラメータがtrueのとき文字列と整数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=DI), intent(in) :: int 出力整数 private subroutine print_str_dint_double (string, i1, d1) Debugパラメータがtrueのとき文字列と整数と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=DI), intent(in) :: i1 出力整数 real(kind=DR), intent(in) :: d1 出力実数 private subroutine print_str_double (string, double) Debugパラメータがtrueのとき文字列と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 real(kind=DR), intent(in) :: double 出力実数 private subroutine print_str_sint (string, int) Debugパラメータがtrueのとき文字列と整数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=SI), intent(in) :: int 出力整数 private subroutine print_str_sint_double (string, i1, d1) Debugパラメータがtrueのとき文字列と整数と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=SI), intent(in) :: i1 出力整数 real(kind=DR), intent(in) :: d1 出力実数 Subroutines private subroutine print_str (string) Debugパラメータがtrueのとき文字列を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 private subroutine print_str_dint (string, int) Debugパラメータがtrueのとき文字列と整数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=DI), intent(in) :: int 出力整数 private subroutine print_str_dint_double (string, i1, d1) Debugパラメータがtrueのとき文字列と整数と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=DI), intent(in) :: i1 出力整数 real(kind=DR), intent(in) :: d1 出力実数 private subroutine print_str_double (string, double) Debugパラメータがtrueのとき文字列と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 real(kind=DR), intent(in) :: double 出力実数 private subroutine print_str_sint (string, int) Debugパラメータがtrueのとき文字列と整数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=SI), intent(in) :: int 出力整数 private subroutine print_str_sint_double (string, i1, d1) Debugパラメータがtrueのとき文字列と整数と実数を出力する Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string 出力文字列 integer(kind=SI), intent(in) :: i1 出力整数 real(kind=DR), intent(in) :: d1 出力実数","tags":"","loc":"module/debug_m.html"},{"title":"grid_m – Smoke Ring","text":"格子点関連情報 Note モジュール名と同じgridというpublicな変数（構造体）を\n     定義し、その実体をこのモジュール内に保持している。 Uses constants_m ut_m module~~grid_m~~UsesGraph module~grid_m grid_m module~ut_m ut_m module~grid_m->module~ut_m module~constants_m constants_m module~grid_m->module~constants_m module~ut_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~grid_m~~UsedByGraph module~grid_m grid_m module~field_m field_m module~field_m->module~grid_m program~main_m main_m program~main_m->module~grid_m program~main_m->module~field_m module~solver_m solver_m program~main_m->module~solver_m module~slicedata_m slicedata_m program~main_m->module~slicedata_m module~solver_m->module~grid_m module~solver_m->module~field_m module~slicedata_m->module~field_m module~slicedata_m->module~solver_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables grid Derived Types grid__delta_t grid__derivative_operator_1st_t grid__derivative_operator_2nd_t grid__pos_t grid__t Subroutines grid__initialize Variables Type Visibility Attributes Name Initial type( grid__t ), public :: grid Derived Types type, private :: grid__delta_t 格子間隔構造体 Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x方向の格子間隔 real(kind=DR), public :: y y方向の格子間隔 real(kind=DR), public :: z z方向の格子間隔 type, private :: grid__derivative_operator_1st_t 1階微分（差分）をとる時の演算子（定数）\n 演算回数の節約のため Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x偏微分 real(kind=DR), public :: y y偏微分 real(kind=DR), public :: z z偏微分 type, private :: grid__derivative_operator_2nd_t 2階微分（差分）をとる時の演算子（定数）\n 演算回数の節約のため Components Type Visibility Attributes Name Initial real(kind=DR), public :: x x偏微分 real(kind=DR), public :: y y偏微分 real(kind=DR), public :: z z偏微分 type, private :: grid__pos_t 格子点位置を収める構造体\n posはpositionの意味 Components Type Visibility Attributes Name Initial real(kind=DR), public, dimension(NX) :: x x座標 real(kind=DR), public, dimension(NY) :: y y座標 real(kind=DR), public, dimension(NZ) :: z z座標 type, public :: grid__t 格子点関係のデータを全て収める構造体 Components Type Visibility Attributes Name Initial type( grid__derivative_operator_1st_t ), public :: d1 1階微分演算子定数 type( grid__derivative_operator_2nd_t ), public :: d2 2階微分演算子定数 type( grid__delta_t ), public :: delta 格子間隔 real(kind=DR), public :: delta_min 最小の格子間隔 type( grid__pos_t ), public :: pos 格子点位置 Type-Bound Procedures procedure, public :: initialize => grid__initialize 初期化関数\n 初期化のためのメンバー関数\n こうするとgrid%initializeという形でcallできる Subroutines private subroutine grid__initialize (self) gridの初期化 Read more… Arguments Type Intent Optional Attributes Name class( grid__t ), intent(out) :: self 格子構造体","tags":"","loc":"module/grid_m.html"},{"title":"main_m – Smoke Ring","text":"Uses constants_m ut_m params_m debug_m grid_m field_m slicedata_m solver_m job_m program~~main_m~~UsesGraph program~main_m main_m module~job_m job_m program~main_m->module~job_m module~ut_m ut_m program~main_m->module~ut_m module~solver_m solver_m program~main_m->module~solver_m module~params_m params_m program~main_m->module~params_m module~debug_m debug_m program~main_m->module~debug_m module~slicedata_m slicedata_m program~main_m->module~slicedata_m module~constants_m constants_m program~main_m->module~constants_m module~field_m field_m program~main_m->module~field_m module~grid_m grid_m program~main_m->module~grid_m module~job_m->module~ut_m module~job_m->module~constants_m module~ut_m->module~constants_m module~solver_m->module~job_m module~solver_m->module~ut_m module~solver_m->module~params_m module~solver_m->module~debug_m module~solver_m->module~constants_m module~solver_m->module~field_m module~solver_m->module~grid_m module~params_m->module~ut_m module~params_m->module~constants_m module~debug_m->module~ut_m module~debug_m->module~params_m module~debug_m->module~constants_m module~slicedata_m->module~ut_m module~slicedata_m->module~solver_m module~slicedata_m->module~params_m module~slicedata_m->module~debug_m module~slicedata_m->module~field_m module~field_m->module~constants_m module~field_m->module~grid_m module~grid_m->module~ut_m module~grid_m->module~constants_m var panprogrammain_mUsesGraph = svgPanZoom('#programmain_mUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. 渦輪 (smoke ring) の形成シミュレーション 神戸大学情報知能工学科の講義 \"HPC\" （B3対象）用サンプルコード ### 形状\n    直方体領域。3次元周期境界条件。カーテシアン座標。 ### 計算手法\n    空間離散化は2次中心差分法。時間積分は4次ルンゲ・クッタ法。 ### 実行方法\n    (1) cd src\n    (2) make\n    (3) cd ../slice_grapher\n    (4) make Calls program~~main_m~~CallsGraph program~main_m main_m proc~slicedata__initialize slicedata__initialize program~main_m->proc~slicedata__initialize interface~debug__print debug__print program~main_m->interface~debug__print proc~slicedata__write slicedata__write program~main_m->proc~slicedata__write proc~params__read params__read program~main_m->proc~params__read proc~solver__initialize solver__initialize program~main_m->proc~solver__initialize proc~job__finalize job__finalize program~main_m->proc~job__finalize proc~solver__advance solver__advance program~main_m->proc~solver__advance proc~solver__set_time_step solver__set_time_step program~main_m->proc~solver__set_time_step proc~solver__diagnosis solver__diagnosis program~main_m->proc~solver__diagnosis proc~params__get_integer params__get_integer program~main_m->proc~params__get_integer proc~slicedata__initialize->interface~debug__print proc~params__get_string params__get_string proc~slicedata__initialize->proc~params__get_string proc~print_str_dint print_str_dint interface~debug__print->proc~print_str_dint proc~print_str_double print_str_double interface~debug__print->proc~print_str_double proc~print_str print_str interface~debug__print->proc~print_str proc~print_str_dint_double print_str_dint_double interface~debug__print->proc~print_str_dint_double proc~print_str_sint print_str_sint interface~debug__print->proc~print_str_sint proc~print_str_sint_double print_str_sint_double interface~debug__print->proc~print_str_sint_double proc~slicedata__write->interface~debug__print proc~slicedata__write->proc~params__get_integer interface~solver__get_subfield solver__get_subfield proc~slicedata__write->interface~solver__get_subfield interface~ut__message ut__message proc~slicedata__write->interface~ut__message proc~ut__assert ut__assert proc~slicedata__write->proc~ut__assert proc~make_single_precision_field make_single_precision_field proc~slicedata__write->proc~make_single_precision_field proc~solver__initialize->interface~debug__print proc~params__get_double params__get_double proc~solver__initialize->proc~params__get_double proc~set_drive_force_field set_drive_force_field proc~solver__initialize->proc~set_drive_force_field proc~job__finalize->interface~ut__message proc~solver__advance->interface~debug__print proc~operator_fluid_add operator_fluid_add proc~solver__advance->proc~operator_fluid_add proc~subfield_vel_tm_divv subfield_vel_tm_divv proc~solver__advance->proc~subfield_vel_tm_divv proc~the_equation the_equation proc~solver__advance->proc~the_equation proc~operator_fluid_times_real operator_fluid_times_real proc~solver__advance->proc~operator_fluid_times_real proc~solver__set_time_step->interface~ut__message proc~params__get_logical params__get_logical proc~solver__set_time_step->proc~params__get_logical proc~solver__set_time_step->proc~ut__assert proc~subfield_vel_tm subfield_vel_tm proc~solver__set_time_step->proc~subfield_vel_tm proc~solver__diagnosis->interface~debug__print proc~solver__diagnosis->interface~ut__message proc~subfield_vel subfield_vel proc~solver__diagnosis->proc~subfield_vel proc~operator_energyintegral operator_energyintegral proc~solver__diagnosis->proc~operator_energyintegral proc~operator_scalarintegral operator_scalarintegral proc~solver__diagnosis->proc~operator_scalarintegral proc~params__get_integer->interface~ut__message proc~params__get_integer->proc~ut__assert proc~ut__fatal ut__fatal proc~params__get_integer->proc~ut__fatal interface~solver__get_subfield->proc~subfield_vel interface~solver__get_subfield->proc~subfield_vel_tm_divv interface~solver__get_subfield->proc~subfield_vel_tm proc~print_str_dint->proc~params__get_logical proc~message_str_double message_str_double interface~ut__message->proc~message_str_double proc~message_str_dint_double message_str_dint_double interface~ut__message->proc~message_str_dint_double proc~message_str_float message_str_float interface~ut__message->proc~message_str_float proc~message_decorated_str_dint message_decorated_str_dint interface~ut__message->proc~message_decorated_str_dint proc~message_decorated_str message_decorated_str interface~ut__message->proc~message_decorated_str proc~message_str_sint message_str_sint interface~ut__message->proc~message_str_sint proc~message_str message_str interface~ut__message->proc~message_str proc~message_str_sint_double_double message_str_sint_double_double interface~ut__message->proc~message_str_sint_double_double proc~message_str_dint message_str_dint interface~ut__message->proc~message_str_dint proc~message_str_dint_double_double message_str_dint_double_double interface~ut__message->proc~message_str_dint_double_double proc~message_str_sint_double message_str_sint_double interface~ut__message->proc~message_str_sint_double proc~message_decorated_str_sint message_decorated_str_sint interface~ut__message->proc~message_decorated_str_sint proc~subfield_vel->interface~debug__print proc~operator_vector_divby_scalar operator_vector_divby_scalar proc~subfield_vel->proc~operator_vector_divby_scalar proc~print_str_double->interface~ut__message proc~print_str_double->proc~params__get_logical proc~params__get_logical->interface~ut__message proc~params__get_logical->proc~ut__assert proc~params__get_logical->proc~ut__fatal proc~print_str->interface~ut__message proc~print_str->proc~params__get_logical proc~print_str_dint_double->proc~params__get_logical proc~params__get_double->interface~ut__message proc~params__get_double->proc~ut__assert proc~params__get_double->proc~ut__fatal proc~subfield_vel_tm_divv->interface~debug__print proc~operator_div operator_div proc~subfield_vel_tm_divv->proc~operator_div proc~subfield_vel_tm_divv->proc~operator_vector_divby_scalar proc~print_str_sint->proc~params__get_logical proc~the_equation->interface~debug__print proc~the_equation->proc~ut__assert interface~field__boundary_condition field__boundary_condition proc~the_equation->interface~field__boundary_condition proc~drive_force_factor drive_force_factor proc~the_equation->proc~drive_force_factor proc~ut__assert->proc~ut__fatal proc~set_drive_force_field->interface~debug__print proc~set_drive_force_field->interface~field__boundary_condition proc~print_str_sint_double->proc~params__get_logical proc~operator_dot_product operator_dot_product proc~operator_energyintegral->proc~operator_dot_product proc~ut__fatal->interface~ut__message proc~params__get_string->interface~ut__message proc~params__get_string->proc~ut__assert proc~params__get_string->proc~ut__fatal proc~subfield_vel_tm->interface~debug__print proc~subfield_vel_tm->proc~operator_vector_divby_scalar proc~make_single_precision_field->interface~debug__print proc~operator_curl operator_curl proc~make_single_precision_field->proc~operator_curl proc~make_single_precision_field->proc~operator_dot_product proc~boundary_condition_vector boundary_condition_vector proc~operator_curl->proc~boundary_condition_vector proc~boundary_condition_scalar boundary_condition_scalar proc~operator_div->proc~boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_scalar interface~field__boundary_condition->proc~boundary_condition_vector proc~boundary_condition_fluid boundary_condition_fluid interface~field__boundary_condition->proc~boundary_condition_fluid proc~message_decorated_str_dint->proc~message_decorated_str proc~drive_force_factor->proc~ut__assert proc~message_decorated_str_sint->proc~message_decorated_str proc~boundary_condition_fluid->proc~boundary_condition_scalar proc~boundary_condition_fluid->proc~boundary_condition_vector var panprogrammain_mCallsGraph = svgPanZoom('#programmain_mCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dt fluid nloop time Source Code main_m Variables Type Attributes Name Initial real(kind=DR) :: dt type( field__fluid_t ) :: fluid integer(kind=DI) :: nloop real(kind=DR) :: time Source Code program main_m use constants_m ! 定数 use ut_m ! ユーティリティ use params_m ! パラメータ use debug_m ! デバッグ use grid_m ! 格子点情報 use field_m ! 流体場の構造体定義 use slicedata_m ! 可視化用断面データ出力 use solver_m ! ナビエ・ストークス方程式ソルバ use job_m ! ジョブ管理 implicit none ! 暗黙の型宣言無効化。必須 integer ( DI ) :: nloop ! シミュレーションのループカウンタ real ( DR ) :: dt , time ! 時間刻み幅と時刻 type ( field__fluid_t ) :: fluid ! 流体場データの構造体 call params__read ! パラメーターの読み込み。paramsの後に続くアンダースコア ! 二つは、これがparamsモジュールの中にあるサブルーチンの ! 呼び出しであることを意味している。paramsモジュールの ! 名前はparams_mである。params_mはparams.f90にある。 call grid % initialize ! gridモジュールの初期化。 ! パーセント記号はメンバアクセス演算子。 ! ここでは構造体のメンバー関数の呼び出しをしている。 ! gridモジュール（grid_m）はgrid.f90で定義されている。 call solver__initialize ( fluid ) ! solverジュール（solver_m）の初期化。ここでは上の ! gridモジュールの場合と異なりメンバアクセス演算子 ! （パーセント記号）を使っていない理由は特にない。 call slicedata__initialize ! slicedataモジュールの初期化。 ! このモジュールはシミュレーション領域の断面図を出力する。 time = 0.0_DR ! 時刻の初期化。単位は秒。 nloop = 0 ! ループカウンタの初期化。 call solver__diagnosis ( nloop , time , fluid ) ! solverモジュールで定義されているdiagnosis（診断） ! サブルーチンを呼び出す。医者が患者を診るのがdiagnosis ! である。そこでの診断結果はjobモジュールのjob__carte ! という構造体にセットする。carteはカルテである。 dt = solver__set_time_step ( nloop , fluid ) ! 時間刻み幅 dt の決定。dtはCFL条件を満足するように決めるが、 ! CFL条件は流体の状態に流体の状態に依存して変化する。 ! たとえば、流体の一部が高温になると、そこでの音速が速くなり、 ! 音速によって決まるCFL条件が厳しくなる（つまりdtが小さくなる） ! ここでは初期状態における流体の状態に基づいてdtが決まる do while ( job__karte % state == \"fine\" ) ! このシミュレーションのメインループである。ジョブカルテが ! 「健康 (fine)」状態である限りシミュレーションを続行する。 call debug__print ( \"running. nloop=\" , nloop ) ! このdebugモジュール中の標準出力書き出しルーチンの ! 呼び出し。通常のプリント文と異なりデバッグフラグがtrue ! の時だけメッセージを書き出すような仕組みにしている。 ! デバッグフラグがfalseのときには何も書き出さない。 ! デバッグフラグはparamsモジュール内で定義している。 call solver__advance ( time , dt , fluid ) ! ナビエ・ストークス方程式に基づいて流体 (fluid) の状態を ! 一時刻ステップ dt だけ進める。 dt = solver__set_time_step ( nloop , fluid ) ! 流体の状態が変わったのでCFL条件に基づき時間刻み幅dt ! を設定し直す。 ! 厳密に言えば毎ステップこの再設定をしているわけではなく、 ! このsolver__set_time_stepルーチンの冒頭で判断し、 ! 数十ステップに一度だけ実際には変更を行うようなskip操作 ! をしている。CFL条件に基づいた計算は時間がかかるが、 ! 毎ステップdtを精密に調整する必要はないからである。 nloop = nloop + 1 ! ループカウンタのインクリメント call solver__diagnosis ( nloop , time , fluid ) ! 診断。異常があればjob__carteにセットする。 call slicedata__write ( nloop , time , fluid ) ! 断面データのディスクへの書き出し if ( nloop >= params__get_integer ( 'Total_nloop' )) & call job__karte % set ( \"loop_max\" ) ! あらかじめparamsモジュールで設定されたループカウンタの ! 上限値に達したらジョブを停止する。 end do call job__finalize ( nloop ) ! ジョブの後始末。実際にはメーセージを標準出力に書くだけ。 end program main_m","tags":"","loc":"program/main_m.html"}]}